val T_DEF : thm = |- T <=> (\p. p) = (\p. p)
val TRUTH : thm = |- T
val AND_DEF : thm = |- (/\) = (\p q. (\f. f p q) = (\f. f T T))
val IMP_DEF : thm = |- (==>) = (\p q. p /\ q <=> p)
val FORALL_DEF : thm = |- (!) = (\P. P = (\x. T))
val EXISTS_DEF : thm = |- (?) = (\P. !q. (!x. P x ==> q) ==> q)
val OR_DEF : thm = |- (\/) = (\p q. !r. (p ==> r) ==> (q ==> r) ==> r)
val F_DEF : thm = |- F <=> (!p. p)
val NOT_DEF : thm = |- (~) = (\p. p ==> F)
val EXISTS_UNIQUE_DEF : thm =
  |- (?!) = (\P. (?) P /\ (!x y. P x /\ P y ==> x = y))
    (int * term) list * (term * term) list * (hol_type * hol_type) list
val _FALSITY_ : thm = |- _FALSITY_ <=> F
val EQ_REFL : thm = |- !x. x = x
val REFL_CLAUSE : thm = |- !x. x = x <=> T
val EQ_SYM : thm = |- !x y. x = y ==> y = x
val EQ_SYM_EQ : thm = |- !x y. x = y <=> y = x
val EQ_TRANS : thm = |- !x y z. x = y /\ y = z ==> x = z
val BETA_THM : thm = |- !f y. (\x. f x) y = f y
val ABS_SIMP : thm = |- !t1 t2. (\x. t1) t2 = t1
val CONJ_ASSOC : thm = |- !t1 t2 t3. t1 /\ t2 /\ t3 <=> (t1 /\ t2) /\ t3
val CONJ_SYM : thm = |- !t1 t2. t1 /\ t2 <=> t2 /\ t1
val CONJ_ACI : thm =
  |- (p /\ q <=> q /\ p) /\
     ((p /\ q) /\ r <=> p /\ q /\ r) /\
     (p /\ q /\ r <=> q /\ p /\ r) /\
     (p /\ p <=> p) /\
     (p /\ p /\ q <=> p /\ q)
val DISJ_ASSOC : thm = |- !t1 t2 t3. t1 \/ t2 \/ t3 <=> (t1 \/ t2) \/ t3
val DISJ_SYM : thm = |- !t1 t2. t1 \/ t2 <=> t2 \/ t1
val DISJ_ACI : thm =
  |- (p \/ q <=> q \/ p) /\
     ((p \/ q) \/ r <=> p \/ q \/ r) /\
     (p \/ q \/ r <=> q \/ p \/ r) /\
     (p \/ p <=> p) /\
     (p \/ p \/ q <=> p \/ q)
val IMP_CONJ : thm = |- p /\ q ==> r <=> p ==> q ==> r
val IMP_IMP : thm = |- p ==> q ==> r <=> p /\ q ==> r
val IMP_CONJ_ALT : thm = |- p /\ q ==> r <=> q ==> p ==> r
val LEFT_OR_DISTRIB : thm = |- !p q r. p /\ (q \/ r) <=> p /\ q \/ p /\ r
val RIGHT_OR_DISTRIB : thm = |- !p q r. (p \/ q) /\ r <=> p /\ r \/ q /\ r
val FORALL_SIMP : thm = |- !t. (!x. t) <=> t
val EXISTS_SIMP : thm = |- !t. (?x. t) <=> t
val EQ_IMP : thm = |- (a <=> b) ==> a ==> b
val EQ_CLAUSES : thm =
  |- !t. ((T <=> t) <=> t) /\
         ((t <=> T) <=> t) /\
         ((F <=> t) <=> ~t) /\
         ((t <=> F) <=> ~t)
val NOT_CLAUSES_WEAK : thm = |- (~T <=> F) /\ (~F <=> T)
val AND_CLAUSES : thm =
  |- !t. (T /\ t <=> t) /\
         (t /\ T <=> t) /\
         (F /\ t <=> F) /\
         (t /\ F <=> F) /\
         (t /\ t <=> t)
val OR_CLAUSES : thm =
  |- !t. (T \/ t <=> T) /\
         (t \/ T <=> T) /\
         (F \/ t <=> t) /\
         (t \/ F <=> t) /\
         (t \/ t <=> t)
val IMP_CLAUSES : thm =
  |- !t. (T ==> t <=> t) /\
         (t ==> T <=> T) /\
         (F ==> t <=> T) /\
         (t ==> t <=> T) /\
         (t ==> F <=> ~t)
val EXISTS_UNIQUE_THM : thm =
  |- !P. (?!x. P x) <=> (?x. P x) /\ (!x x'. P x /\ P x' ==> x = x')
val EXISTS_REFL : thm = |- !a. ?x. x = a
val EXISTS_UNIQUE_REFL : thm = |- !a. ?!x. x = a
val UNWIND_THM1 : thm = |- !P a. (?x. a = x /\ P x) <=> P a
val UNWIND_THM2 : thm = |- !P a. (?x. x = a /\ P x) <=> P a
val FORALL_UNWIND_THM2 : thm = |- !P a. (!x. x = a ==> P x) <=> P a
val FORALL_UNWIND_THM1 : thm = |- !P a. (!x. a = x ==> P x) <=> P a
val SWAP_FORALL_THM : thm = |- !P. (!x y. P x y) <=> (!y x. P x y)
val SWAP_EXISTS_THM : thm = |- !P. (?x y. P x y) <=> (?y x. P x y)
val FORALL_AND_THM : thm =
  |- !P Q. (!x. P x /\ Q x) <=> (!x. P x) /\ (!x. Q x)
val AND_FORALL_THM : thm =
  |- !P Q. (!x. P x) /\ (!x. Q x) <=> (!x. P x /\ Q x)
val LEFT_AND_FORALL_THM : thm = |- !P Q. (!x. P x) /\ Q <=> (!x. P x /\ Q)
val RIGHT_AND_FORALL_THM : thm = |- !P Q. P /\ (!x. Q x) <=> (!x. P /\ Q x)
val EXISTS_OR_THM : thm =
  |- !P Q. (?x. P x \/ Q x) <=> (?x. P x) \/ (?x. Q x)
val OR_EXISTS_THM : thm =
  |- !P Q. (?x. P x) \/ (?x. Q x) <=> (?x. P x \/ Q x)
val LEFT_OR_EXISTS_THM : thm = |- !P Q. (?x. P x) \/ Q <=> (?x. P x \/ Q)
val RIGHT_OR_EXISTS_THM : thm = |- !P Q. P \/ (?x. Q x) <=> (?x. P \/ Q x)
val LEFT_EXISTS_AND_THM : thm = |- !P Q. (?x. P x /\ Q) <=> (?x. P x) /\ Q
val RIGHT_EXISTS_AND_THM : thm = |- !P Q. (?x. P /\ Q x) <=> P /\ (?x. Q x)
val TRIV_EXISTS_AND_THM : thm = |- !P Q. (?x. P /\ Q) <=> (?x. P) /\ (?x. Q)
val LEFT_AND_EXISTS_THM : thm = |- !P Q. (?x. P x) /\ Q <=> (?x. P x /\ Q)
val RIGHT_AND_EXISTS_THM : thm = |- !P Q. P /\ (?x. Q x) <=> (?x. P /\ Q x)
val TRIV_AND_EXISTS_THM : thm = |- !P Q. (?x. P) /\ (?x. Q) <=> (?x. P /\ Q)
val TRIV_FORALL_OR_THM : thm = |- !P Q. (!x. P \/ Q) <=> (!x. P) \/ (!x. Q)
val TRIV_OR_FORALL_THM : thm = |- !P Q. (!x. P) \/ (!x. Q) <=> (!x. P \/ Q)
val RIGHT_IMP_FORALL_THM : thm = |- !P Q. P ==> (!x. Q x) <=> (!x. P ==> Q x)
val RIGHT_FORALL_IMP_THM : thm = |- !P Q. (!x. P ==> Q x) <=> P ==> (!x. Q x)
val LEFT_IMP_EXISTS_THM : thm = |- !P Q. (?x. P x) ==> Q <=> (!x. P x ==> Q)
val LEFT_FORALL_IMP_THM : thm = |- !P Q. (!x. P x ==> Q) <=> (?x. P x) ==> Q
val TRIV_FORALL_IMP_THM : thm =
  |- !P Q. (!x. P ==> Q) <=> (?x. P) ==> (!x. Q)
val TRIV_EXISTS_IMP_THM : thm =
  |- !P Q. (?x. P ==> Q) <=> (!x. P) ==> (?x. Q)
val EXISTS_UNIQUE_ALT : thm = |- !P. (?!x. P x) <=> (?x. !y. P y <=> x = y)
val EXISTS_UNIQUE : thm =
  |- !P. (?!x. P x) <=> (?x. P x /\ (!y. P y ==> y = x))
val MONO_AND : thm = |- (A ==> B) /\ (C ==> D) ==> A /\ C ==> B /\ D
val MONO_OR : thm = |- (A ==> B) /\ (C ==> D) ==> A \/ C ==> B \/ D
val MONO_IMP : thm = |- (B ==> A) /\ (C ==> D) ==> (A ==> C) ==> B ==> D
val MONO_NOT : thm = |- (B ==> A) ==> ~A ==> ~B
val MONO_FORALL : thm = |- (!x. P x ==> Q x) ==> (!x. P x) ==> (!x. Q x)
val MONO_EXISTS : thm = |- (!x. P x ==> Q x) ==> (?x. P x) ==> (?x. Q x)
val ETA_AX : thm = |- !t. (\x. t x) = t
val EQ_EXT : thm = |- !f g. (!x. f x = g x) ==> f = g
val FUN_EQ_THM : thm = |- !f g. f = g <=> (!x. f x = g x)
val SELECT_AX : thm = |- !P x. P x ==> P ((@) P)
val EXISTS_THM : thm = |- (?) = (\P. P ((@) P))
val SELECT_REFL : thm = |- !x. (@y. y = x) = x
val SELECT_UNIQUE : thm = |- !P x. (!y. P y <=> y = x) ==> (@) P = x
val EXCLUDED_MIDDLE : thm = |- !t. t \/ ~t
val BOOL_CASES_AX : thm = |- !t. (t <=> T) \/ (t <=> F)
val DE_MORGAN_THM : thm =
  |- !t1 t2. (~(t1 /\ t2) <=> ~t1 \/ ~t2) /\ (~(t1 \/ t2) <=> ~t1 /\ ~t2)
val NOT_CLAUSES : thm = |- (!t. ~ ~t <=> t) /\ (~T <=> F) /\ (~F <=> T)
val NOT_IMP : thm = |- !t1 t2. ~(t1 ==> t2) <=> t1 /\ ~t2
val CONTRAPOS_THM : thm = |- !t1 t2. ~t1 ==> ~t2 <=> t2 ==> t1
val NOT_EXISTS_THM : thm = |- !P. ~(?x. P x) <=> (!x. ~P x)
val EXISTS_NOT_THM : thm = |- !P. (?x. ~P x) <=> ~(!x. P x)
val NOT_FORALL_THM : thm = |- !P. ~(!x. P x) <=> (?x. ~P x)
val FORALL_NOT_THM : thm = |- !P. (!x. ~P x) <=> ~(?x. P x)
val FORALL_BOOL_THM : thm = |- (!b. P b) <=> P T /\ P F
val EXISTS_BOOL_THM : thm = |- (?b. P b) <=> P T \/ P F
val LEFT_FORALL_OR_THM : thm = |- !P Q. (!x. P x \/ Q) <=> (!x. P x) \/ Q
val RIGHT_FORALL_OR_THM : thm = |- !P Q. (!x. P \/ Q x) <=> P \/ (!x. Q x)
val LEFT_OR_FORALL_THM : thm = |- !P Q. (!x. P x) \/ Q <=> (!x. P x \/ Q)
val RIGHT_OR_FORALL_THM : thm = |- !P Q. P \/ (!x. Q x) <=> (!x. P \/ Q x)
val LEFT_IMP_FORALL_THM : thm = |- !P Q. (!x. P x) ==> Q <=> (?x. P x ==> Q)
val LEFT_EXISTS_IMP_THM : thm = |- !P Q. (?x. P x ==> Q) <=> (!x. P x) ==> Q
val RIGHT_IMP_EXISTS_THM : thm = |- !P Q. P ==> (?x. Q x) <=> (?x. P ==> Q x)
val RIGHT_EXISTS_IMP_THM : thm = |- !P Q. (?x. P ==> Q x) <=> P ==> (?x. Q x)
val COND_DEF : thm =
  |- COND = (\t t1 t2. @x. ((t <=> T) ==> x = t1) /\ ((t <=> F) ==> x = t2))
val COND_CLAUSES : thm =
  |- !t1 t2. (if T then t1 else t2) = t1 /\ (if F then t1 else t2) = t2
val COND_EXPAND : thm =
  |- !b t1 t2. (if b then t1 else t2) <=> (~b \/ t1) /\ (b \/ t2)
val COND_ID : thm = |- !b t. (if b then t else t) = t
val COND_RAND : thm =
  |- !b f x y. f (if b then x else y) = (if b then f x else f y)
val COND_RATOR : thm =
  |- !b f g x. (if b then f else g) x = (if b then f x else g x)
val COND_ABS : thm =
  |- !b f g. (\x. if b then f x else g x) = (if b then f else g)
val MONO_COND : thm =
  |- (A ==> B) /\ (C ==> D) ==> (if b then A else C) ==> (if b then B else D)
val COND_ELIM_THM : thm =
  |- P (if c then x else y) <=> (c ==> P x) /\ (~c ==> P y)
val SKOLEM_THM : thm = |- !P. (!x. ?y. P x y) <=> (?y. !x. P x (y x))
val SKOLEM_THM_GEN : thm =
  |- !P s. (!x. P x ==> (?y. R x y)) <=> (?f. !x. P x ==> R x (f x))
val UNIQUE_SKOLEM_ALT : thm =
  |- !P. (!x. ?!y. P x y) <=> (?f. !x y. P x y <=> f x = y)
val UNIQUE_SKOLEM_THM : thm =
  |- !P. (!x. ?!y. P x y) <=> (?!f. !x. P x (f x))
val bool_INDUCT : thm = |- !P. P F /\ P T ==> (!x. P x)
val bool_RECURSION : thm = |- !a b. ?f. f F = a /\ f T = b
val o_DEF : thm = |- !f g. f o g = (\x. f (g x))
val I_DEF : thm = |- I = (\x. x)
val o_THM : thm = |- !f g x. (f o g) x = f (g x)
val o_ASSOC : thm = |- !f g h. f o g o h = (f o g) o h
val I_THM : thm = |- !x. I x = x
val I_O_ID : thm = |- !f. I o f = f /\ f o I = f
val EXISTS_ONE_REP : thm = |- ?b. b
val one_tydef : thm =
  |- (!a. one_ABS (one_REP a) = a) /\ (!r. r <=> one_REP (one_ABS r) <=> r)
val one_DEF : thm = |- one = (@x. T)
val one : thm = |- !v. v = one
val one_axiom : thm = |- !f g. f = g
val one_INDUCT : thm = |- !P. P one ==> (!x. P x)
val one_RECURSION : thm = |- !e. ?fn. fn one = e
val one_Axiom : thm = |- !e. ?!fn. fn one = e
val LET_DEF : thm = |- !f x. LET f x = f x
val LET_END_DEF : thm = |- !t. LET_END t = t
val GABS_DEF : thm = |- !P. GABS P = (@) P
val GEQ_DEF : thm = |- !a b. GEQ a b <=> a = b
val _SEQPATTERN : thm =
  |- _SEQPATTERN = (\r s x. if ?y. r x y then r x else s x)
val _UNGUARDED_PATTERN : thm = |- _UNGUARDED_PATTERN = (\p r. p /\ r)
val _GUARDED_PATTERN : thm = |- _GUARDED_PATTERN = (\p g r. p /\ g /\ r)
val _MATCH : thm =
  |- _MATCH = (\e r. if (?!) (r e) then (@) (r e) else @z. F)
val _FUNCTION : thm =
  |- _FUNCTION = (\r x. if (?!) (r x) then (@) (r x) else @z. F)
val mk_pair_def : thm = |- !x y. mk_pair x y = (\a b. a = x /\ b = y)
val PAIR_EXISTS_THM : thm = |- ?x a b. x = mk_pair a b
val prod_tybij : thm =
  |- (!a. ABS_prod (REP_prod a) = a) /\
     (!r. (?a b. r = mk_pair a b) <=> REP_prod (ABS_prod r) = r)
val REP_ABS_PAIR : thm =
  |- !x y. REP_prod (ABS_prod (mk_pair x y)) = mk_pair x y
val COMMA_DEF : thm = |- !x y. x,y = ABS_prod (mk_pair x y)
val FST_DEF : thm = |- !p. FST p = (@x. ?y. p = x,y)
val SND_DEF : thm = |- !p. SND p = (@y. ?x. p = x,y)
val PAIR_EQ : thm = |- !x y a b. x,y = a,b <=> x = a /\ y = b
val PAIR_SURJECTIVE : thm = |- !p. ?x y. p = x,y
val FST : thm = |- !x y. FST (x,y) = x
val SND : thm = |- !x y. SND (x,y) = y
val PAIR : thm = |- !x. FST x,SND x = x
val pair_INDUCT : thm = |- !P. (!x y. P (x,y)) ==> (!p. P p)
val pair_RECURSION : thm = |- !PAIR'. ?fn. !a0 a1. fn (a0,a1) = PAIR' a0 a1
val CURRY_DEF : thm = |- !f x y. CURRY f x y = f (x,y)
val UNCURRY_DEF : thm = |- !f x y. UNCURRY f (x,y) = f x y
val PASSOC_DEF : thm = |- !f x y z. PASSOC f (x,y,z) = f ((x,y),z)
val FORALL_PAIR_THM : thm = |- !P. (!p. P p) <=> (!p1 p2. P (p1,p2))
val EXISTS_PAIR_THM : thm = |- !P. (?p. P p) <=> (?p1 p2. P (p1,p2))
val LAMBDA_PAIR_THM : thm = |- !t. (\p. t p) = (\(x,y). t (x,y))
val PAIRED_ETA_THM : thm =
  |- (!f. (\(x,y). f (x,y)) = f) /\
     (!f. (\(x,y,z). f (x,y,z)) = f) /\
     (!f. (\(w,x,y,z). f (w,x,y,z)) = f)
val FORALL_UNCURRY : thm = |- !P. (!f. P f) <=> (!f. P (\a b. f (a,b)))
val EXISTS_UNCURRY : thm = |- !P. (?f. P f) <=> (?f. P (\a b. f (a,b)))
val EXISTS_CURRY : thm = |- !P. (?f. P f) <=> (?f. P (\(a,b). f a b))
val FORALL_CURRY : thm = |- !P. (!f. P f) <=> (!f. P (\(a,b). f a b))
val FORALL_UNPAIR_THM : thm =
  |- !P. (!x y. P x y) <=> (!z. P (FST z) (SND z))
val EXISTS_UNPAIR_THM : thm =
  |- !P. (?x y. P x y) <=> (?z. P (FST z) (SND z))
val FORALL_PAIRED_THM : thm = |- !P. (!(x,y). P x y) <=> (!x y. P x y)
val EXISTS_PAIRED_THM : thm = |- !P. (?(x,y). P x y) <=> (?x y. P x y)
val FORALL_TRIPLED_THM : thm =
  |- !P. (!(x,y,z). P x y z) <=> (!x y z. P x y z)
val EXISTS_TRIPLED_THM : thm =
  |- !P. (?(x,y,z). P x y z) <=> (?x y z. P x y z)
val ONE_ONE : thm = |- !f. ONE_ONE f <=> (!x1 x2. f x1 = f x2 ==> x1 = x2)
val ONTO : thm = |- !f. ONTO f <=> (!y. ?x. y = f x)
val INFINITY_AX : thm = |- ?f. ONE_ONE f /\ ~ONTO f
val IND_SUC_0_EXISTS : thm =
  |- ?f z. (!x1 x2. f x1 = f x2 <=> x1 = x2) /\ (!x. ~(f x = z))
val IND_SUC_SPEC : thm =
  |- (!x1 x2. IND_SUC x1 = IND_SUC x2 <=> x1 = x2) /\
     (!x. ~(IND_SUC x = IND_0))
val IND_SUC_INJ : thm = |- !x1 x2. IND_SUC x1 = IND_SUC x2 <=> x1 = x2
val IND_SUC_0 : thm = |- !x. ~(IND_SUC x = IND_0)
val NUM_REP_RULES : thm =
  |- NUM_REP IND_0 /\ (!i. NUM_REP i ==> NUM_REP (IND_SUC i))
val NUM_REP_INDUCT : thm =
  |- !NUM_REP'. NUM_REP' IND_0 /\ (!i. NUM_REP' i ==> NUM_REP' (IND_SUC i))
                ==> (!a. NUM_REP a ==> NUM_REP' a)
val NUM_REP_CASES : thm =
  |- !a. NUM_REP a <=> a = IND_0 \/ (?i. a = IND_SUC i /\ NUM_REP i)
  (|- mk_num (dest_num a) = a, |- NUM_REP r <=> dest_num (mk_num r) = r)
val ZERO_DEF : thm = |- _0 = mk_num IND_0
val SUC_DEF : thm = |- !n. SUC n = mk_num (IND_SUC (dest_num n))
val NOT_SUC : thm = |- !n. ~(SUC n = _0)
val SUC_INJ : thm = |- !m n. SUC m = SUC n <=> m = n
val num_INDUCTION : thm =
  |- !P. P _0 /\ (!n. P n ==> P (SUC n)) ==> (!n. P n)
val num_Axiom : thm =
  |- !e f. ?!fn. fn _0 = e /\ (!n. fn (SUC n) = f (fn n) n)
val NUMERAL : thm = |- !n. NUMERAL n = n
val NOT_SUC : thm = |- !n. ~(SUC n = 0)
val num_INDUCTION : thm = |- !P. P 0 /\ (!n. P n ==> P (SUC n)) ==> (!n. P n)
val num_Axiom : thm =
  |- !e f. ?!fn. fn 0 = e /\ (!n. fn (SUC n) = f (fn n) n)
val num_RECURSION : thm =
  |- !e f. ?fn. fn 0 = e /\ (!n. fn (SUC n) = f (fn n) n)
val num_CASES : thm = |- !m. m = 0 \/ (?n. m = SUC n)
val num_RECURSION_STD : thm =
  |- !e f. ?fn. fn 0 = e /\ (!n. fn (SUC n) = f n (fn n))
val BIT0_DEF : thm = |- BIT0 0 = 0 /\ (!n. BIT0 (SUC n) = SUC (SUC (BIT0 n)))
val BIT1_DEF : thm = |- !n. BIT1 n = SUC (BIT0 n)
val PRE : thm = |- PRE 0 = 0 /\ (!n. PRE (SUC n) = n)
val ADD : thm = |- (!n. 0 + n = n) /\ (!m n. SUC m + n = SUC (m + n))
val ADD_0 : thm = |- !m. m + 0 = m
val ADD_SUC : thm = |- !m n. m + SUC n = SUC (m + n)
val ADD_CLAUSES : thm =
  |- (!n. 0 + n = n) /\
     (!m. m + 0 = m) /\
     (!m n. SUC m + n = SUC (m + n)) /\
     (!m n. m + SUC n = SUC (m + n))
val ADD_SYM : thm = |- !m n. m + n = n + m
val ADD_ASSOC : thm = |- !m n p. m + n + p = (m + n) + p
val ADD_AC : thm =
  |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
val ADD_EQ_0 : thm = |- !m n. m + n = 0 <=> m = 0 /\ n = 0
val EQ_ADD_LCANCEL : thm = |- !m n p. m + n = m + p <=> n = p
val EQ_ADD_RCANCEL : thm = |- !m n p. m + p = n + p <=> m = n
val EQ_ADD_LCANCEL_0 : thm = |- !m n. m + n = m <=> n = 0
val EQ_ADD_RCANCEL_0 : thm = |- !m n. m + n = n <=> m = 0
val BIT0 : thm = |- !n. BIT0 n = n + n
val BIT1 : thm = |- !n. BIT1 n = SUC (n + n)
val BIT0_THM : thm = |- !n. NUMERAL (BIT0 n) = NUMERAL n + NUMERAL n
val BIT1_THM : thm = |- !n. NUMERAL (BIT1 n) = SUC (NUMERAL n + NUMERAL n)
val ONE : thm = |- 1 = SUC 0
val TWO : thm = |- 2 = SUC 1
val ADD1 : thm = |- !m. SUC m = m + 1
val MULT : thm = |- (!n. 0 * n = 0) /\ (!m n. SUC m * n = m * n + n)
val MULT_0 : thm = |- !m. m * 0 = 0
val MULT_SUC : thm = |- !m n. m * SUC n = m + m * n
val MULT_CLAUSES : thm =
  |- (!n. 0 * n = 0) /\
     (!m. m * 0 = 0) /\
     (!n. 1 * n = n) /\
     (!m. m * 1 = m) /\
     (!m n. SUC m * n = m * n + n) /\
     (!m n. m * SUC n = m + m * n)
val MULT_SYM : thm = |- !m n. m * n = n * m
val LEFT_ADD_DISTRIB : thm = |- !m n p. m * (n + p) = m * n + m * p
val RIGHT_ADD_DISTRIB : thm = |- !m n p. (m + n) * p = m * p + n * p
val MULT_ASSOC : thm = |- !m n p. m * n * p = (m * n) * p
val MULT_AC : thm =
  |- m * n = n * m /\ (m * n) * p = m * n * p /\ m * n * p = n * m * p
val MULT_EQ_0 : thm = |- !m n. m * n = 0 <=> m = 0 \/ n = 0
val EQ_MULT_LCANCEL : thm = |- !m n p. m * n = m * p <=> m = 0 \/ n = p
val EQ_MULT_RCANCEL : thm = |- !m n p. m * p = n * p <=> m = n \/ p = 0
val MULT_2 : thm = |- !n. 2 * n = n + n
val MULT_EQ_1 : thm = |- !m n. m * n = 1 <=> m = 1 /\ n = 1
val EXP : thm = |- (!m. m EXP 0 = 1) /\ (!m n. m EXP SUC n = m * m EXP n)
val EXP_EQ_0 : thm = |- !m n. m EXP n = 0 <=> m = 0 /\ ~(n = 0)
val EXP_EQ_1 : thm = |- !x n. x EXP n = 1 <=> x = 1 \/ n = 0
val EXP_ZERO : thm = |- !n. 0 EXP n = (if n = 0 then 1 else 0)
val EXP_ADD : thm = |- !m n p. m EXP (n + p) = m EXP n * m EXP p
val EXP_ONE : thm = |- !n. 1 EXP n = 1
val EXP_1 : thm = |- !n. n EXP 1 = n
val EXP_2 : thm = |- !n. n EXP 2 = n * n
val MULT_EXP : thm = |- !p m n. (m * n) EXP p = m EXP p * n EXP p
val EXP_MULT : thm = |- !m n p. m EXP (n * p) = m EXP n EXP p
val LE : thm =
  |- (!m. m <= 0 <=> m = 0) /\ (!m n. m <= SUC n <=> m = SUC n \/ m <= n)
val LT : thm = |- (!m. m < 0 <=> F) /\ (!m n. m < SUC n <=> m = n \/ m < n)
val GE : thm = |- !n m. m >= n <=> n <= m
val GT : thm = |- !n m. m > n <=> n < m
val MAX : thm = |- !m n. MAX m n = (if m <= n then n else m)
val MIN : thm = |- !m n. MIN m n = (if m <= n then m else n)
val LE_SUC_LT : thm = |- !m n. SUC m <= n <=> m < n
val LT_SUC_LE : thm = |- !m n. m < SUC n <=> m <= n
val LE_SUC : thm = |- !m n. SUC m <= SUC n <=> m <= n
val LT_SUC : thm = |- !m n. SUC m < SUC n <=> m < n
val LE_0 : thm = |- !n. 0 <= n
val LT_0 : thm = |- !n. 0 < SUC n
val LE_REFL : thm = |- !n. n <= n
val LT_REFL : thm = |- !n. ~(n < n)
val LE_ANTISYM : thm = |- !m n. m <= n /\ n <= m <=> m = n
val LT_ANTISYM : thm = |- !m n. ~(m < n /\ n < m)
val LET_ANTISYM : thm = |- !m n. ~(m <= n /\ n < m)
val LTE_ANTISYM : thm = |- !m n. ~(m < n /\ n <= m)
val LE_TRANS : thm = |- !m n p. m <= n /\ n <= p ==> m <= p
val LT_TRANS : thm = |- !m n p. m < n /\ n < p ==> m < p
val LET_TRANS : thm = |- !m n p. m <= n /\ n < p ==> m < p
val LTE_TRANS : thm = |- !m n p. m < n /\ n <= p ==> m < p
val LE_CASES : thm = |- !m n. m <= n \/ n <= m
val LT_CASES : thm = |- !m n. m < n \/ n < m \/ m = n
val LET_CASES : thm = |- !m n. m <= n \/ n < m
val LTE_CASES : thm = |- !m n. m < n \/ n <= m
val LE_LT : thm = |- !m n. m <= n <=> m < n \/ m = n
val LT_LE : thm = |- !m n. m < n <=> m <= n /\ ~(m = n)
val NOT_LE : thm = |- !m n. ~(m <= n) <=> n < m
val NOT_LT : thm = |- !m n. ~(m < n) <=> n <= m
val LT_IMP_LE : thm = |- !m n. m < n ==> m <= n
val EQ_IMP_LE : thm = |- !m n. m = n ==> m <= n
val LT_NZ : thm = |- !n. 0 < n <=> ~(n = 0)
val LE_1 : thm =
  |- (!n. ~(n = 0) ==> 0 < n) /\
     (!n. ~(n = 0) ==> 1 <= n) /\
     (!n. 0 < n ==> ~(n = 0)) /\
     (!n. 0 < n ==> 1 <= n) /\
     (!n. 1 <= n ==> 0 < n) /\
     (!n. 1 <= n ==> ~(n = 0))
val LE_EXISTS : thm = |- !m n. m <= n <=> (?d. n = m + d)
val LT_EXISTS : thm = |- !m n. m < n <=> (?d. n = m + SUC d)
val LE_ADD : thm = |- !m n. m <= m + n
val LE_ADDR : thm = |- !m n. n <= m + n
val LT_ADD : thm = |- !m n. m < m + n <=> 0 < n
val LT_ADDR : thm = |- !m n. n < m + n <=> 0 < m
val LE_ADD_LCANCEL : thm = |- !m n p. m + n <= m + p <=> n <= p
val LE_ADD_RCANCEL : thm = |- !m n p. m + p <= n + p <=> m <= n
val LT_ADD_LCANCEL : thm = |- !m n p. m + n < m + p <=> n < p
val LT_ADD_RCANCEL : thm = |- !m n p. m + p < n + p <=> m < n
val LE_ADD2 : thm = |- !m n p q. m <= p /\ n <= q ==> m + n <= p + q
val LET_ADD2 : thm = |- !m n p q. m <= p /\ n < q ==> m + n < p + q
val LTE_ADD2 : thm = |- !m n p q. m < p /\ n <= q ==> m + n < p + q
val LT_ADD2 : thm = |- !m n p q. m < p /\ n < q ==> m + n < p + q
val LT_MULT : thm = |- !m n. 0 < m * n <=> 0 < m /\ 0 < n
val LE_MULT2 : thm = |- !m n p q. m <= n /\ p <= q ==> m * p <= n * q
val LT_LMULT : thm = |- !m n p. ~(m = 0) /\ n < p ==> m * n < m * p
val LE_MULT_LCANCEL : thm = |- !m n p. m * n <= m * p <=> m = 0 \/ n <= p
val LE_MULT_RCANCEL : thm = |- !m n p. m * p <= n * p <=> m <= n \/ p = 0
val LT_MULT_LCANCEL : thm = |- !m n p. m * n < m * p <=> ~(m = 0) /\ n < p
val LT_MULT_RCANCEL : thm = |- !m n p. m * p < n * p <=> m < n /\ ~(p = 0)
val LT_MULT2 : thm = |- !m n p q. m < n /\ p < q ==> m * p < n * q
val LE_SQUARE_REFL : thm = |- !n. n <= n * n
val LT_POW2_REFL : thm = |- !n. n < 2 EXP n
val WLOG_LE : thm =
  |- (!m n. P m n <=> P n m) /\ (!m n. m <= n ==> P m n) ==> (!m n. P m n)
val WLOG_LT : thm =
  |- (!m. P m m) /\ (!m n. P m n <=> P n m) /\ (!m n. m < n ==> P m n)
     ==> (!m y. P m y)
val num_WF : thm = |- !P. (!n. (!m. m < n ==> P m) ==> P n) ==> (!n. P n)
val num_WOP : thm = |- !P. (?n. P n) <=> (?n. P n /\ (!m. m < n ==> ~P m))
val num_MAX : thm =
  |- !P. (?x. P x) /\ (?M. !x. P x ==> x <= M) <=>
         (?m. P m /\ (!x. P x ==> x <= m))
val EVEN : thm = |- (EVEN 0 <=> T) /\ (!n. EVEN (SUC n) <=> ~EVEN n)
val ODD : thm = |- (ODD 0 <=> F) /\ (!n. ODD (SUC n) <=> ~ODD n)
val NOT_EVEN : thm = |- !n. ~EVEN n <=> ODD n
val NOT_ODD : thm = |- !n. ~ODD n <=> EVEN n
val EVEN_OR_ODD : thm = |- !n. EVEN n \/ ODD n
val EVEN_AND_ODD : thm = |- !n. ~(EVEN n /\ ODD n)
val EVEN_ADD : thm = |- !m n. EVEN (m + n) <=> EVEN m <=> EVEN n
val EVEN_MULT : thm = |- !m n. EVEN (m * n) <=> EVEN m \/ EVEN n
val EVEN_EXP : thm = |- !m n. EVEN (m EXP n) <=> EVEN m /\ ~(n = 0)
val ODD_ADD : thm = |- !m n. ODD (m + n) <=> ~(ODD m <=> ODD n)
val ODD_MULT : thm = |- !m n. ODD (m * n) <=> ODD m /\ ODD n
val ODD_EXP : thm = |- !m n. ODD (m EXP n) <=> ODD m \/ n = 0
val EVEN_DOUBLE : thm = |- !n. EVEN (2 * n)
val ODD_DOUBLE : thm = |- !n. ODD (SUC (2 * n))
val EVEN_EXISTS_LEMMA : thm =
  |- !n. (EVEN n ==> (?m. n = 2 * m)) /\ (~EVEN n ==> (?m. n = SUC (2 * m)))
val EVEN_EXISTS : thm = |- !n. EVEN n <=> (?m. n = 2 * m)
val ODD_EXISTS : thm = |- !n. ODD n <=> (?m. n = SUC (2 * m))
val EVEN_ODD_DECOMPOSITION : thm =
  |- !n. (?k m. ODD m /\ n = 2 EXP k * m) <=> ~(n = 0)
val SUB : thm = |- (!m. m - 0 = m) /\ (!m n. m - SUC n = PRE (m - n))
val SUB_0 : thm = |- !m. 0 - m = 0 /\ m - 0 = m
val SUB_PRESUC : thm = |- !m n. PRE (SUC m - n) = m - n
val SUB_SUC : thm = |- !m n. SUC m - SUC n = m - n
val SUB_REFL : thm = |- !n. n - n = 0
val ADD_SUB : thm = |- !m n. (m + n) - n = m
val ADD_SUB2 : thm = |- !m n. (m + n) - m = n
val SUB_EQ_0 : thm = |- !m n. m - n = 0 <=> m <= n
val ADD_SUBR2 : thm = |- !m n. m - (m + n) = 0
val ADD_SUBR : thm = |- !m n. n - (m + n) = 0
val SUB_ADD : thm = |- !m n. n <= m ==> m - n + n = m
val SUB_ADD_LCANCEL : thm = |- !m n p. (m + n) - (m + p) = n - p
val SUB_ADD_RCANCEL : thm = |- !m n p. (m + p) - (n + p) = m - n
val LEFT_SUB_DISTRIB : thm = |- !m n p. m * (n - p) = m * n - m * p
val RIGHT_SUB_DISTRIB : thm = |- !m n p. (m - n) * p = m * p - n * p
val SUC_SUB1 : thm = |- !n. SUC n - 1 = n
val EVEN_SUB : thm = |- !m n. EVEN (m - n) <=> m <= n \/ (EVEN m <=> EVEN n)
val ODD_SUB : thm = |- !m n. ODD (m - n) <=> n < m /\ ~(ODD m <=> ODD n)
val FACT : thm = |- FACT 0 = 1 /\ (!n. FACT (SUC n) = SUC n * FACT n)
val FACT_LT : thm = |- !n. 0 < FACT n
val FACT_LE : thm = |- !n. 1 <= FACT n
val FACT_NZ : thm = |- !n. ~(FACT n = 0)
val FACT_MONO : thm = |- !m n. m <= n ==> FACT m <= FACT n
val EXP_LT_0 : thm = |- !n x. 0 < x EXP n <=> ~(x = 0) \/ n = 0
val LT_EXP : thm =
  |- !x m n.
         x EXP m < x EXP n <=> 2 <= x /\ m < n \/ x = 0 /\ ~(m = 0) /\ n = 0
val LE_EXP : thm =
  |- !x m n.
         x EXP m <= x EXP n <=>
         (if x = 0 then m = 0 ==> n = 0 else x = 1 \/ m <= n)
val EQ_EXP : thm =
  |- !x m n.
         x EXP m = x EXP n <=>
         (if x = 0 then m = 0 <=> n = 0 else x = 1 \/ m = n)
val EXP_MONO_LE_IMP : thm = |- !x y n. x <= y ==> x EXP n <= y EXP n
val EXP_MONO_LT_IMP : thm =
  |- !x y n. x < y /\ ~(n = 0) ==> x EXP n < y EXP n
val EXP_MONO_LE : thm = |- !x y n. x EXP n <= y EXP n <=> x <= y \/ n = 0
val EXP_MONO_LT : thm = |- !x y n. x EXP n < y EXP n <=> x < y /\ ~(n = 0)
val EXP_MONO_EQ : thm = |- !x y n. x EXP n = y EXP n <=> x = y \/ n = 0
val DIVMOD_EXIST : thm = |- !m n. ~(n = 0) ==> (?q r. m = q * n + r /\ r < n)
val DIVMOD_EXIST_0 : thm =
  |- !m n. ?q r. if n = 0 then q = 0 /\ r = m else m = q * n + r /\ r < n
val DIVISION_0 : thm =
  |- !m n.
         if n = 0
         then m DIV n = 0 /\ m MOD n = m
         else m = m DIV n * n + m MOD n /\ m MOD n < n
val DIVISION : thm =
  |- !m n. ~(n = 0) ==> m = m DIV n * n + m MOD n /\ m MOD n < n
val DIVISION_SIMP : thm =
  |- (!m n. ~(n = 0) ==> m DIV n * n + m MOD n = m) /\
     (!m n. ~(n = 0) ==> n * m DIV n + m MOD n = m)
val DIVMOD_UNIQ_LEMMA : thm =
  |- !m n q1 r1 q2 r2.
         (m = q1 * n + r1 /\ r1 < n) /\ m = q2 * n + r2 /\ r2 < n
         ==> q1 = q2 /\ r1 = r2
val DIVMOD_UNIQ : thm =
  |- !m n q r. m = q * n + r /\ r < n ==> m DIV n = q /\ m MOD n = r
val MOD_UNIQ : thm = |- !m n q r. m = q * n + r /\ r < n ==> m MOD n = r
val DIV_UNIQ : thm = |- !m n q r. m = q * n + r /\ r < n ==> m DIV n = q
val DIV_MULT : thm = |- !m n. ~(m = 0) ==> (m * n) DIV m = n
val MOD_MULT : thm = |- !m n. ~(m = 0) ==> (m * n) MOD m = 0
val MOD_LT : thm = |- !m n. m < n ==> m MOD n = m
val MOD_EQ : thm = |- !m n p q. m = n + q * p ==> m MOD p = n MOD p
val DIV_LE : thm = |- !m n. ~(n = 0) ==> m DIV n <= m
val DIV_MUL_LE : thm = |- !m n. n * m DIV n <= m
val DIV_0 : thm = |- !n. ~(n = 0) ==> 0 DIV n = 0
val MOD_0 : thm = |- !n. ~(n = 0) ==> 0 MOD n = 0
val DIV_1 : thm = |- !n. n DIV 1 = n
val MOD_1 : thm = |- !n. n MOD 1 = 0
val DIV_LT : thm = |- !m n. m < n ==> m DIV n = 0
val MOD_MOD : thm = |- !m n p. ~(n * p = 0) ==> m MOD (n * p) MOD n = m MOD n
val MOD_MOD_REFL : thm = |- !m n. ~(n = 0) ==> m MOD n MOD n = m MOD n
val DIV_MULT2 : thm =
  |- !m n p. ~(m * p = 0) ==> (m * n) DIV (m * p) = n DIV p
val MOD_MULT2 : thm =
  |- !m n p. ~(m * p = 0) ==> (m * n) MOD (m * p) = m * n MOD p
val MOD_EXISTS : thm =
  |- !m n. (?q. m = n * q) <=> (if n = 0 then m = 0 else m MOD n = 0)
val LE_RDIV_EQ : thm = |- !a b n. ~(a = 0) ==> (n <= b DIV a <=> a * n <= b)
val LE_LDIV_EQ : thm =
  |- !a b n. ~(a = 0) ==> (b DIV a <= n <=> b < a * (n + 1))
val LE_LDIV : thm = |- !a b n. ~(a = 0) /\ b <= a * n ==> b DIV a <= n
val DIV_MONO : thm = |- !m n p. ~(p = 0) /\ m <= n ==> m DIV p <= n DIV p
val DIV_MONO_LT : thm =
  |- !m n p. ~(p = 0) /\ m + p <= n ==> m DIV p < n DIV p
val DIV_EQ_0 : thm = |- !m n. ~(n = 0) ==> (m DIV n = 0 <=> m < n)
val MOD_EQ_0 : thm = |- !m n. ~(n = 0) ==> (m MOD n = 0 <=> (?q. m = q * n))
val MOD_REFL : thm = |- !n. ~(n = 0) ==> n MOD n = 0
val EVEN_MOD : thm = |- !n. EVEN n <=> n MOD 2 = 0
val ODD_MOD : thm = |- !n. ODD n <=> n MOD 2 = 1
val MOD_MULT_RMOD : thm =
  |- !m n p. ~(n = 0) ==> (m * p MOD n) MOD n = (m * p) MOD n
val MOD_MULT_LMOD : thm =
  |- !m n p. ~(n = 0) ==> (m MOD n * p) MOD n = (m * p) MOD n
val MOD_MULT_MOD2 : thm =
  |- !m n p. ~(n = 0) ==> (m MOD n * p MOD n) MOD n = (m * p) MOD n
val MOD_EXP_MOD : thm =
  |- !m n p. ~(n = 0) ==> (m MOD n) EXP p MOD n = m EXP p MOD n
val MOD_MULT_ADD : thm = |- !m n p. (m * n + p) MOD n = p MOD n
val DIV_MULT_ADD : thm =
  |- !a b n. ~(n = 0) ==> (a * n + b) DIV n = a + b DIV n
val MOD_ADD_MOD : thm =
  |- !a b n. ~(n = 0) ==> (a MOD n + b MOD n) MOD n = (a + b) MOD n
val DIV_ADD_MOD : thm =
  |- !a b n.
         ~(n = 0)
         ==> ((a + b) MOD n = a MOD n + b MOD n <=>
              (a + b) DIV n = a DIV n + b DIV n)
val DIV_REFL : thm = |- !n. ~(n = 0) ==> n DIV n = 1
val MOD_LE : thm = |- !m n. ~(n = 0) ==> m MOD n <= m
val DIV_MONO2 : thm = |- !m n p. ~(p = 0) /\ p <= m ==> n DIV m <= n DIV p
val DIV_LE_EXCLUSION : thm =
  |- !a b c d. ~(b = 0) /\ b * c < (a + 1) * d ==> c DIV d <= a DIV b
val DIV_EQ_EXCLUSION : thm =
  |- b * c < (a + 1) * d /\ a * d < (c + 1) * b ==> a DIV b = c DIV d
val MULT_DIV_LE : thm = |- !m n p. ~(p = 0) ==> m * n DIV p <= (m * n) DIV p
val DIV_DIV : thm = |- !m n p. ~(n * p = 0) ==> m DIV n DIV p = m DIV (n * p)
val DIV_MOD : thm =
  |- !m n p. ~(n * p = 0) ==> (m DIV n) MOD p = (m MOD (n * p)) DIV n
val MOD_MOD_EXP_MIN : thm =
  |- !x p m n. ~(p = 0) ==> x MOD p EXP m MOD p EXP n = x MOD p EXP MIN m n
val PRE_ELIM_THM : thm =
  |- P (PRE n) <=> (!m. n = SUC m \/ m = 0 /\ n = 0 ==> P m)
val PRE_ELIM_THM' : thm =
  |- P (PRE n) <=> (?m. (n = SUC m \/ m = 0 /\ n = 0) /\ P m)
val SUB_ELIM_THM : thm =
  |- P (a - b) <=> (!d. a = b + d \/ a < b /\ d = 0 ==> P d)
val SUB_ELIM_THM' : thm =
  |- P (a - b) <=> (?d. (a = b + d \/ a < b /\ d = 0) /\ P d)
val DIVMOD_ELIM_THM : thm =
  |- P (m DIV n) (m MOD n) <=>
     (!q r. n = 0 /\ q = 0 /\ r = m \/ m = q * n + r /\ r < n ==> P q r)
val DIVMOD_ELIM_THM' : thm =
  |- P (m DIV n) (m MOD n) <=>
     (?q r. (n = 0 /\ q = 0 /\ r = m \/ m = q * n + r /\ r < n) /\ P q r)
val minimal : thm = |- !P. (minimal) P = (@n. P n /\ (!m. m < n ==> ~P m))
val MINIMAL : thm =
  |- !P. (?n. P n) <=> P ((minimal) P) /\ (!m. m < (minimal) P ==> ~P m)
val TRANSITIVE_STEPWISE_LT_EQ : thm =
  |- !R. (!x y z. R x y /\ R y z ==> R x z)
         ==> ((!m n. m < n ==> R m n) <=> (!n. R n (SUC n)))
val TRANSITIVE_STEPWISE_LT : thm =
  |- !R. (!x y z. R x y /\ R y z ==> R x z) /\ (!n. R n (SUC n))
         ==> (!m n. m < n ==> R m n)
val TRANSITIVE_STEPWISE_LE_EQ : thm =
  |- !R. (!x. R x x) /\ (!x y z. R x y /\ R y z ==> R x z)
         ==> ((!m n. m <= n ==> R m n) <=> (!n. R n (SUC n)))
val TRANSITIVE_STEPWISE_LE : thm =
  |- !R. (!x. R x x) /\
         (!x y z. R x y /\ R y z ==> R x z) /\
         (!n. R n (SUC n))
         ==> (!m n. m <= n ==> R m n)
val DEPENDENT_CHOICE_FIXED : thm =
  |- !P R a.
         P 0 a /\ (!n x. P n x ==> (?y. P (SUC n) y /\ R n x y))
         ==> (?f. f 0 = a /\ (!n. P n (f n)) /\ (!n. R n (f n) (f (SUC n))))
val DEPENDENT_CHOICE : thm =
  |- !P R.
         (?a. P 0 a) /\ (!n x. P n x ==> (?y. P (SUC n) y /\ R n x y))
         ==> (?f. (!n. P n (f n)) /\ (!n. R n (f n) (f (SUC n))))
val WF : thm =
  |- !(<<). WF (<<) <=>
            (!P. (?x. P x) ==> (?x. P x /\ (!y. y << x ==> ~P y)))
val WF_EQ : thm =
  |- WF (<<) <=> (!P. (?x. P x) <=> (?x. P x /\ (!y. y << x ==> ~P y)))
val WF_IND : thm =
  |- WF (<<) <=> (!P. (!x. (!y. y << x ==> P y) ==> P x) ==> (!x. P x))
val WF_DCHAIN : thm = |- WF (<<) <=> ~(?s. !n. s (SUC n) << s n)
val WF_UREC : thm =
  |- WF (<<)
     ==> (!H. (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x)
              ==> (!f g. (!x. f x = H f x) /\ (!x. g x = H g x) ==> f = g))
val WF_UREC_WF : thm =
  |- (!H. (!f g x. (!z. z << x ==> (f z <=> g z)) ==> (H f x <=> H g x))
          ==> (!f g. (!x. f x <=> H f x) /\ (!x. g x <=> H g x) ==> f = g))
     ==> WF (<<)
val WF_REC_INVARIANT : thm =
  |- WF (<<)
     ==> (!H S.
              (!f g x.
                   (!z. z << x ==> f z = g z /\ S z (f z))
                   ==> H f x = H g x /\ S x (H f x))
              ==> (?f. !x. f x = H f x))
val WF_REC : thm =
  |- WF (<<)
     ==> (!H. (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x)
              ==> (?f. !x. f x = H f x))
val WF_REC_WF : thm =
  |- (!H. (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x)
          ==> (?f. !x. f x = H f x))
     ==> WF (<<)
val WF_EREC : thm =
  |- WF (<<)
     ==> (!H. (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x)
              ==> (?!f. !x. f x = H f x))
val WF_SUBSET : thm = |- (!x y. x << y ==> x <<< y) /\ WF (<<<) ==> WF (<<)
val WF_MEASURE_GEN : thm = |- !m. WF (<<) ==> WF (\x x'. m x << m x')
val WF_LEX_DEPENDENT : thm =
  |- !R S.
         WF R /\ (!a. WF (S a))
         ==> WF (\(r1,s1) (r2,s2). R r1 r2 \/ r1 = r2 /\ S r1 s1 s2)
val WF_LEX : thm =
  |- !R S.
         WF R /\ WF S
         ==> WF (\(r1,s1) (r2,s2). R r1 r2 \/ r1 = r2 /\ S s1 s2)
val WF_POINTWISE : thm =
  |- WF (<<) /\ WF (<<<) ==> WF (\(x1,y1) (x2,y2). x1 << x2 /\ y1 <<< y2)
val WF_num : thm = |- WF (<)
val WF_REC_num : thm =
  |- !H. (!f g n. (!m. m < n ==> f m = g m) ==> H f n = H g n)
         ==> (?f. !n. f n = H f n)
val MEASURE : thm = |- !m. MEASURE m = (\x y. m x < m y)
val WF_MEASURE : thm = |- !m. WF (MEASURE m)
val MEASURE_LE : thm =
  |- (!y. MEASURE m y a ==> MEASURE m y b) <=> m a <= m b
val WF_REFL : thm = |- !x. WF (<<) ==> ~(x << x)
val WF_FALSE : thm = |- WF (\x y. F)
val WF_REC_TAIL : thm =
  |- !P g h. ?f. !x. f x = (if P x then f (g x) else h x)
val WF_REC_TAIL_GENERAL : thm =
  |- !P G H.
         WF (<<) /\
         (!f g x.
              (!z. z << x ==> f z = g z)
              ==> (P f x <=> P g x) /\ G f x = G g x /\ H f x = H g x) /\
         (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x) /\
         (!f x y. P f x /\ y << G f x ==> y << x)
         ==> (?f. !x. f x = (if P f x then f (G f x) else H f x))
val ARITH_ZERO : thm = |- NUMERAL 0 = 0 /\ BIT0 _0 = _0
val ARITH_SUC : thm =
  |- (!n. SUC (NUMERAL n) = NUMERAL (SUC n)) /\
     SUC _0 = BIT1 _0 /\
     (!n. SUC (BIT0 n) = BIT1 n) /\
     (!n. SUC (BIT1 n) = BIT0 (SUC n))
val ARITH_PRE : thm =
  |- (!n. PRE (NUMERAL n) = NUMERAL (PRE n)) /\
     PRE _0 = _0 /\
     (!n. PRE (BIT0 n) = (if n = _0 then _0 else BIT1 (PRE n))) /\
     (!n. PRE (BIT1 n) = BIT0 n)
val ARITH_ADD : thm =
  |- (!m n. NUMERAL m + NUMERAL n = NUMERAL (m + n)) /\
     _0 + _0 = _0 /\
     (!n. _0 + BIT0 n = BIT0 n) /\
     (!n. _0 + BIT1 n = BIT1 n) /\
     (!n. BIT0 n + _0 = BIT0 n) /\
     (!n. BIT1 n + _0 = BIT1 n) /\
     (!m n. BIT0 m + BIT0 n = BIT0 (m + n)) /\
     (!m n. BIT0 m + BIT1 n = BIT1 (m + n)) /\
     (!m n. BIT1 m + BIT0 n = BIT1 (m + n)) /\
     (!m n. BIT1 m + BIT1 n = BIT0 (SUC (m + n)))
val ARITH_MULT : thm =
  |- (!m n. NUMERAL m * NUMERAL n = NUMERAL (m * n)) /\
     _0 * _0 = _0 /\
     (!n. _0 * BIT0 n = _0) /\
     (!n. _0 * BIT1 n = _0) /\
     (!n. BIT0 n * _0 = _0) /\
     (!n. BIT1 n * _0 = _0) /\
     (!m n. BIT0 m * BIT0 n = BIT0 (BIT0 (m * n))) /\
     (!m n. BIT0 m * BIT1 n = BIT0 m + BIT0 (BIT0 (m * n))) /\
     (!m n. BIT1 m * BIT0 n = BIT0 n + BIT0 (BIT0 (m * n))) /\
     (!m n. BIT1 m * BIT1 n = BIT1 m + BIT0 n + BIT0 (BIT0 (m * n)))
val ARITH_EXP : thm =
  |- (!m n. NUMERAL m EXP NUMERAL n = NUMERAL (m EXP n)) /\
     _0 EXP _0 = BIT1 _0 /\
     (!m. BIT0 m EXP _0 = BIT1 _0) /\
     (!m. BIT1 m EXP _0 = BIT1 _0) /\
     (!n. _0 EXP BIT0 n = _0 EXP n * _0 EXP n) /\
     (!m n. BIT0 m EXP BIT0 n = BIT0 m EXP n * BIT0 m EXP n) /\
     (!m n. BIT1 m EXP BIT0 n = BIT1 m EXP n * BIT1 m EXP n) /\
     (!n. _0 EXP BIT1 n = _0) /\
     (!m n. BIT0 m EXP BIT1 n = BIT0 m * BIT0 m EXP n * BIT0 m EXP n) /\
     (!m n. BIT1 m EXP BIT1 n = BIT1 m * BIT1 m EXP n * BIT1 m EXP n)
val ARITH_EVEN : thm =
  |- (!n. EVEN (NUMERAL n) <=> EVEN n) /\
     (EVEN _0 <=> T) /\
     (!n. EVEN (BIT0 n) <=> T) /\
     (!n. EVEN (BIT1 n) <=> F)
val ARITH_ODD : thm =
  |- (!n. ODD (NUMERAL n) <=> ODD n) /\
     (ODD _0 <=> F) /\
     (!n. ODD (BIT0 n) <=> F) /\
     (!n. ODD (BIT1 n) <=> T)
val ARITH_LE : thm =
  |- (!m n. NUMERAL m <= NUMERAL n <=> m <= n) /\
     (_0 <= _0 <=> T) /\
     (!n. BIT0 n <= _0 <=> n <= _0) /\
     (!n. BIT1 n <= _0 <=> F) /\
     (!n. _0 <= BIT0 n <=> T) /\
     (!n. _0 <= BIT1 n <=> T) /\
     (!m n. BIT0 m <= BIT0 n <=> m <= n) /\
     (!m n. BIT0 m <= BIT1 n <=> m <= n) /\
     (!m n. BIT1 m <= BIT0 n <=> m < n) /\
     (!m n. BIT1 m <= BIT1 n <=> m <= n)
val ARITH_LT : thm =
  |- (!m n. NUMERAL m < NUMERAL n <=> m < n) /\
     (_0 < _0 <=> F) /\
     (!n. BIT0 n < _0 <=> F) /\
     (!n. BIT1 n < _0 <=> F) /\
     (!n. _0 < BIT0 n <=> _0 < n) /\
     (!n. _0 < BIT1 n <=> T) /\
     (!m n. BIT0 m < BIT0 n <=> m < n) /\
     (!m n. BIT0 m < BIT1 n <=> m <= n) /\
     (!m n. BIT1 m < BIT0 n <=> m < n) /\
     (!m n. BIT1 m < BIT1 n <=> m < n)
val ARITH_GE : thm =
  |- (!m n. NUMERAL n >= NUMERAL m <=> n >= m) /\
     _0 >= _0 /\
     (!n. _0 >= BIT0 n <=> _0 >= n) /\
     (!n. ~(_0 >= BIT1 n)) /\
     (!n. BIT0 n >= _0) /\
     (!n. BIT1 n >= _0) /\
     (!m n. BIT0 n >= BIT0 m <=> n >= m) /\
     (!m n. BIT1 n >= BIT0 m <=> n >= m) /\
     (!m n. BIT0 n >= BIT1 m <=> n > m) /\
     (!m n. BIT1 n >= BIT1 m <=> n >= m)
val ARITH_GT : thm =
  |- (!m n. NUMERAL n > NUMERAL m <=> n > m) /\
     ~(_0 > _0) /\
     (!n. ~(_0 > BIT0 n)) /\
     (!n. ~(_0 > BIT1 n)) /\
     (!n. BIT0 n > _0 <=> n > _0) /\
     (!n. BIT1 n > _0) /\
     (!m n. BIT0 n > BIT0 m <=> n > m) /\
     (!m n. BIT1 n > BIT0 m <=> n >= m) /\
     (!m n. BIT0 n > BIT1 m <=> n > m) /\
     (!m n. BIT1 n > BIT1 m <=> n > m)
val ARITH_EQ : thm =
  |- (!m n. NUMERAL m = NUMERAL n <=> m = n) /\
     (_0 = _0 <=> T) /\
     (!n. BIT0 n = _0 <=> n = _0) /\
     (!n. BIT1 n = _0 <=> F) /\
     (!n. _0 = BIT0 n <=> _0 = n) /\
     (!n. _0 = BIT1 n <=> F) /\
     (!m n. BIT0 m = BIT0 n <=> m = n) /\
     (!m n. BIT0 m = BIT1 n <=> F) /\
     (!m n. BIT1 m = BIT0 n <=> F) /\
     (!m n. BIT1 m = BIT1 n <=> m = n)
val ARITH_SUB : thm =
  |- (!m n. NUMERAL m - NUMERAL n = NUMERAL (m - n)) /\
     _0 - _0 = _0 /\
     (!n. _0 - BIT0 n = _0) /\
     (!n. _0 - BIT1 n = _0) /\
     (!n. BIT0 n - _0 = BIT0 n) /\
     (!n. BIT1 n - _0 = BIT1 n) /\
     (!m n. BIT0 m - BIT0 n = BIT0 (m - n)) /\
     (!m n. BIT0 m - BIT1 n = PRE (BIT0 (m - n))) /\
     (!m n. BIT1 m - BIT0 n = (if n <= m then BIT1 (m - n) else _0)) /\
     (!m n. BIT1 m - BIT1 n = BIT0 (m - n))
val ARITH : thm =
  |- (NUMERAL 0 = 0 /\ BIT0 _0 = _0) /\
     ((!n. SUC (NUMERAL n) = NUMERAL (SUC n)) /\
      SUC _0 = BIT1 _0 /\
      (!n. SUC (BIT0 n) = BIT1 n) /\
      (!n. SUC (BIT1 n) = BIT0 (SUC n))) /\
     ((!n. PRE (NUMERAL n) = NUMERAL (PRE n)) /\
      PRE _0 = _0 /\
      (!n. PRE (BIT0 n) = (if n = _0 then _0 else BIT1 (PRE n))) /\
      (!n. PRE (BIT1 n) = BIT0 n)) /\
     ((!m n. NUMERAL m + NUMERAL n = NUMERAL (m + n)) /\
      _0 + _0 = _0 /\
      (!n. _0 + BIT0 n = BIT0 n) /\
      (!n. _0 + BIT1 n = BIT1 n) /\
      (!n. BIT0 n + _0 = BIT0 n) /\
      (!n. BIT1 n + _0 = BIT1 n) /\
      (!m n. BIT0 m + BIT0 n = BIT0 (m + n)) /\
      (!m n. BIT0 m + BIT1 n = BIT1 (m + n)) /\
      (!m n. BIT1 m + BIT0 n = BIT1 (m + n)) /\
      (!m n. BIT1 m + BIT1 n = BIT0 (SUC (m + n)))) /\
     ((!m n. NUMERAL m * NUMERAL n = NUMERAL (m * n)) /\
      _0 * _0 = _0 /\
      (!n. _0 * BIT0 n = _0) /\
      (!n. _0 * BIT1 n = _0) /\
      (!n. BIT0 n * _0 = _0) /\
      (!n. BIT1 n * _0 = _0) /\
      (!m n. BIT0 m * BIT0 n = BIT0 (BIT0 (m * n))) /\
      (!m n. BIT0 m * BIT1 n = BIT0 m + BIT0 (BIT0 (m * n))) /\
      (!m n. BIT1 m * BIT0 n = BIT0 n + BIT0 (BIT0 (m * n))) /\
      (!m n. BIT1 m * BIT1 n = BIT1 m + BIT0 n + BIT0 (BIT0 (m * n)))) /\
     ((!m n. NUMERAL m EXP NUMERAL n = NUMERAL (m EXP n)) /\
      _0 EXP _0 = BIT1 _0 /\
      (!m. BIT0 m EXP _0 = BIT1 _0) /\
      (!m. BIT1 m EXP _0 = BIT1 _0) /\
      (!n. _0 EXP BIT0 n = _0 EXP n * _0 EXP n) /\
      (!m n. BIT0 m EXP BIT0 n = BIT0 m EXP n * BIT0 m EXP n) /\
      (!m n. BIT1 m EXP BIT0 n = BIT1 m EXP n * BIT1 m EXP n) /\
      (!n. _0 EXP BIT1 n = _0) /\
      (!m n. BIT0 m EXP BIT1 n = BIT0 m * BIT0 m EXP n * BIT0 m EXP n) /\
      (!m n. BIT1 m EXP BIT1 n = BIT1 m * BIT1 m EXP n * BIT1 m EXP n)) /\
     ((!n. EVEN (NUMERAL n) <=> EVEN n) /\
      (EVEN _0 <=> T) /\
      (!n. EVEN (BIT0 n) <=> T) /\
      (!n. EVEN (BIT1 n) <=> F)) /\
     ((!n. ODD (NUMERAL n) <=> ODD n) /\
      (ODD _0 <=> F) /\
      (!n. ODD (BIT0 n) <=> F) /\
      (!n. ODD (BIT1 n) <=> T)) /\
     ((!m n. NUMERAL m = NUMERAL n <=> m = n) /\
      (_0 = _0 <=> T) /\
      (!n. BIT0 n = _0 <=> n = _0) /\
      (!n. BIT1 n = _0 <=> F) /\
      (!n. _0 = BIT0 n <=> _0 = n) /\
      (!n. _0 = BIT1 n <=> F) /\
      (!m n. BIT0 m = BIT0 n <=> m = n) /\
      (!m n. BIT0 m = BIT1 n <=> F) /\
      (!m n. BIT1 m = BIT0 n <=> F) /\
      (!m n. BIT1 m = BIT1 n <=> m = n)) /\
     ((!m n. NUMERAL m <= NUMERAL n <=> m <= n) /\
      (_0 <= _0 <=> T) /\
      (!n. BIT0 n <= _0 <=> n <= _0) /\
      (!n. BIT1 n <= _0 <=> F) /\
      (!n. _0 <= BIT0 n <=> T) /\
      (!n. _0 <= BIT1 n <=> T) /\
      (!m n. BIT0 m <= BIT0 n <=> m <= n) /\
      (!m n. BIT0 m <= BIT1 n <=> m <= n) /\
      (!m n. BIT1 m <= BIT0 n <=> m < n) /\
      (!m n. BIT1 m <= BIT1 n <=> m <= n)) /\
     ((!m n. NUMERAL m < NUMERAL n <=> m < n) /\
      (_0 < _0 <=> F) /\
      (!n. BIT0 n < _0 <=> F) /\
      (!n. BIT1 n < _0 <=> F) /\
      (!n. _0 < BIT0 n <=> _0 < n) /\
      (!n. _0 < BIT1 n <=> T) /\
      (!m n. BIT0 m < BIT0 n <=> m < n) /\
      (!m n. BIT0 m < BIT1 n <=> m <= n) /\
      (!m n. BIT1 m < BIT0 n <=> m < n) /\
      (!m n. BIT1 m < BIT1 n <=> m < n)) /\
     ((!m n. NUMERAL n >= NUMERAL m <=> n >= m) /\
      _0 >= _0 /\
      (!n. _0 >= BIT0 n <=> _0 >= n) /\
      (!n. ~(_0 >= BIT1 n)) /\
      (!n. BIT0 n >= _0) /\
      (!n. BIT1 n >= _0) /\
      (!m n. BIT0 n >= BIT0 m <=> n >= m) /\
      (!m n. BIT1 n >= BIT0 m <=> n >= m) /\
      (!m n. BIT0 n >= BIT1 m <=> n > m) /\
      (!m n. BIT1 n >= BIT1 m <=> n >= m)) /\
     ((!m n. NUMERAL n > NUMERAL m <=> n > m) /\
      ~(_0 > _0) /\
      (!n. ~(_0 > BIT0 n)) /\
      (!n. ~(_0 > BIT1 n)) /\
      (!n. BIT0 n > _0 <=> n > _0) /\
      (!n. BIT1 n > _0) /\
      (!m n. BIT0 n > BIT0 m <=> n > m) /\
      (!m n. BIT1 n > BIT0 m <=> n >= m) /\
      (!m n. BIT0 n > BIT1 m <=> n > m) /\
      (!m n. BIT1 n > BIT1 m <=> n > m)) /\
     (!m n. NUMERAL m - NUMERAL n = NUMERAL (m - n)) /\
     _0 - _0 = _0 /\
     (!n. _0 - BIT0 n = _0) /\
     (!n. _0 - BIT1 n = _0) /\
     (!n. BIT0 n - _0 = BIT0 n) /\
     (!n. BIT1 n - _0 = BIT1 n) /\
     (!m n. BIT0 m - BIT0 n = BIT0 (m - n)) /\
     (!m n. BIT0 m - BIT1 n = PRE (BIT0 (m - n))) /\
     (!m n. BIT1 m - BIT0 n = (if n <= m then BIT1 (m - n) else _0)) /\
     (!m n. BIT1 m - BIT1 n = BIT0 (m - n))
  thm ->
  thm ->
  (term -> bool) * (term -> thm) * (term -> thm) * (term -> thm) ->
  (term -> term -> bool) ->
  (term -> thm) * (term -> thm) * (term -> thm) * (term -> thm) *
  (term -> thm) * (term -> thm) = <fun>
    Start of int
  | Mmul of (num * int list) * history
  | Add of history * history
  (term -> num) * (num -> term) * conv * term * term * term * term * 
  term * term * term * thm * thm * (term -> thm) ->
  (term -> thm) * (term list -> term -> term list) = <fun>
  (term -> num) * (num -> term) * conv * term * term * term * term * 
  term * term * term * thm * thm * (term -> thm) -> term -> thm = <fun>
  (term -> num) * (num -> term) * conv * term * term * term * term * 
  term * term * term * thm * thm * (term -> thm) ->
  term list -> term -> term list = <fun>
val INJ_INVERSE2 : thm =
  |- !P. (!x1 y1 x2 y2. P x1 y1 = P x2 y2 <=> x1 = x2 /\ y1 = y2)
         ==> (?X Y. !x y. X (P x y) = x /\ Y (P x y) = y)
val NUMPAIR : thm = |- !x y. NUMPAIR x y = 2 EXP x * (2 * y + 1)
val NUMPAIR_INJ_LEMMA : thm =
  |- !x1 y1 x2 y2. NUMPAIR x1 y1 = NUMPAIR x2 y2 ==> x1 = x2
val NUMPAIR_INJ : thm =
  |- !x1 y1 x2 y2. NUMPAIR x1 y1 = NUMPAIR x2 y2 <=> x1 = x2 /\ y1 = y2
val NUMPAIR_DEST : thm =
  |- !x y. NUMFST (NUMPAIR x y) = x /\ NUMSND (NUMPAIR x y) = y
val NUMSUM : thm = |- !b x. NUMSUM b x = (if b then SUC (2 * x) else 2 * x)
val NUMSUM_INJ : thm =
  |- !b1 x1 b2 x2. NUMSUM b1 x1 = NUMSUM b2 x2 <=> (b1 <=> b2) /\ x1 = x2
val NUMSUM_DEST : thm =
  |- !x y. (NUMLEFT (NUMSUM x y) <=> x) /\ NUMRIGHT (NUMSUM x y) = y
val INJN : thm = |- !m. INJN m = (\n a. n = m)
val INJN_INJ : thm = |- !n1 n2. INJN n1 = INJN n2 <=> n1 = n2
val INJA : thm = |- !a. INJA a = (\n b. b = a)
val INJA_INJ : thm = |- !a1 a2. INJA a1 = INJA a2 <=> a1 = a2
val INJF : thm = |- !f. INJF f = (\n. f (NUMFST n) (NUMSND n))
val INJF_INJ : thm = |- !f1 f2. INJF f1 = INJF f2 <=> f1 = f2
val INJP : thm =
  |- !f1 f2.
         INJP f1 f2 =
         (\n a. if NUMLEFT n then f1 (NUMRIGHT n) a else f2 (NUMRIGHT n) a)
val INJP_INJ : thm =
  |- !f1 f1' f2 f2'. INJP f1 f2 = INJP f1' f2' <=> f1 = f1' /\ f2 = f2'
val ZCONSTR : thm =
  |- !c i r. ZCONSTR c i r = INJP (INJN (SUC c)) (INJP (INJA i) (INJF r))
val ZBOT : thm = |- ZBOT = INJP (INJN 0) (@z. T)
val ZCONSTR_ZBOT : thm = |- !c i r. ~(ZCONSTR c i r = ZBOT)
val ZRECSPACE_RULES : thm =
  |- ZRECSPACE ZBOT /\
     (!c i r. (!n. ZRECSPACE (r n)) ==> ZRECSPACE (ZCONSTR c i r))
val ZRECSPACE_INDUCT : thm =
  |- !ZRECSPACE'. ZRECSPACE' ZBOT /\
                  (!c i r.
                       (!n. ZRECSPACE' (r n)) ==> ZRECSPACE' (ZCONSTR c i r))
                  ==> (!a. ZRECSPACE a ==> ZRECSPACE' a)
val ZRECSPACE_CASES : thm =
  |- !a. ZRECSPACE a <=>
         a = ZBOT \/ (?c i r. a = ZCONSTR c i r /\ (!n. ZRECSPACE (r n)))
  (|- _mk_rec (_dest_rec a) = a,
   |- ZRECSPACE r <=> _dest_rec (_mk_rec r) = r)
val BOTTOM : thm = |- BOTTOM = _mk_rec ZBOT
val CONSTR : thm =
  |- !c i r. CONSTR c i r = _mk_rec (ZCONSTR c i (\n. _dest_rec (r n)))
val MK_REC_INJ : thm =
  |- !x y. _mk_rec x = _mk_rec y ==> ZRECSPACE x /\ ZRECSPACE y ==> x = y
val DEST_REC_INJ : thm = |- !x y. _dest_rec x = _dest_rec y <=> x = y
val CONSTR_BOT : thm = |- !c i r. ~(CONSTR c i r = BOTTOM)
val CONSTR_INJ : thm =
  |- !c1 i1 r1 c2 i2 r2.
         CONSTR c1 i1 r1 = CONSTR c2 i2 r2 <=> c1 = c2 /\ i1 = i2 /\ r1 = r2
val CONSTR_IND : thm =
  |- !P. P BOTTOM /\ (!c i r. (!n. P (r n)) ==> P (CONSTR c i r))
         ==> (!x. P x)
val CONSTR_REC : thm =
  |- !Fn. ?f. !c i r. f (CONSTR c i r) = Fn c i r (\n. f (r n))
val FCONS : thm =
  |- (!a f. FCONS a f 0 = a) /\ (!a f n. FCONS a f (SUC n) = f n)
val FCONS_UNDO : thm = |- !f. f = FCONS (f 0) (f o SUC)
val FNIL : thm = |- !n. FNIL n = (@x. T)
val sum_INDUCT : thm =
  |- !P. (!a. P (INL a)) /\ (!a. P (INR a)) ==> (!x. P x)
val sum_RECURSION : thm =
  |- !INL' INR'. ?fn. (!a. fn (INL a) = INL' a) /\ (!a. fn (INR a) = INR' a)
val OUTL : thm = |- OUTL (INL x) = x
val OUTR : thm = |- OUTR (INR y) = y
val option_INDUCT : thm = |- !P. P NONE /\ (!a. P (SOME a)) ==> (!x. P x)
val option_RECURSION : thm =
  |- !NONE' SOME'. ?fn. fn NONE = NONE' /\ (!a. fn (SOME a) = SOME' a)
val list_INDUCT : thm =
  |- !P. P [] /\ (!a0 a1. P a1 ==> P (CONS a0 a1)) ==> (!x. P x)
val list_RECURSION : thm =
  |- !NIL' CONS'.
         ?fn. fn [] = NIL' /\ (!a0 a1. fn (CONS a0 a1) = CONS' a0 a1 (fn a1))
  {contents = [("bool", |- (T <=> F) <=> F)]}
val ISO : thm = |- !g f. ISO f g <=> (!x. f (g x) = x) /\ (!y. g (f y) = y)
val ISO_REFL : thm = |- ISO (\x. x) (\x. x)
val ISO_FUN : thm =
  |- ISO f f' /\ ISO g g' ==> ISO (\h a'. g (h (f' a'))) (\h a. g' (h (f a)))
val ISO_USAGE : thm =
  |- ISO f g
     ==> (!P. (!x. P x) <=> (!x. P (g x))) /\
         (!P. (?x. P x) <=> (?x. P (g x))) /\
         (!a b. a = g b <=> f a = b)
  (hol_type * (string * hol_type list) list) list -> thm * thm = <fun>
  {contents =
    [("list = NIL | CONS A list",
      (|- !P. P [] /\ (!a0 a1. P a1 ==> P (CONS a0 a1)) ==> (!x. P x),
       |- !NIL' CONS'.
              ?fn. fn [] = NIL' /\
                   (!a0 a1. fn (CONS a0 a1) = CONS' a0 a1 (fn a1))));
     ("option = NONE | SOME A",
      (|- !P. P NONE /\ (!a. P (SOME a)) ==> (!x. P x),
       |- !NONE' SOME'. ?fn. fn NONE = NONE' /\ (!a. fn (SOME a) = SOME' a)));
     ("sum = INL A | INR B",
      (|- !P. (!a. P (INL a)) /\ (!a. P (INR a)) ==> (!x. P x),
       |- !INL' INR'.
              ?fn. (!a. fn (INL a) = INL' a) /\ (!a. fn (INR a) = INR' a)))]}
val HD : thm = |- HD (CONS h t) = h
val TL : thm = |- TL (CONS h t) = t
val APPEND : thm =
  |- (!l. APPEND [] l = l) /\
     (!h t l. APPEND (CONS h t) l = CONS h (APPEND t l))
val REVERSE : thm =
  |- REVERSE [] = [] /\ REVERSE (CONS x l) = APPEND (REVERSE l) [x]
val LENGTH : thm =
  |- LENGTH [] = 0 /\ (!h t. LENGTH (CONS h t) = SUC (LENGTH t))
val MAP : thm =
  |- (!f. MAP f [] = []) /\ (!f h t. MAP f (CONS h t) = CONS (f h) (MAP f t))
val LAST : thm = |- LAST (CONS h t) = (if t = [] then h else LAST t)
val BUTLAST : thm =
  |- BUTLAST [] = [] /\
     BUTLAST (CONS h t) = (if t = [] then [] else CONS h (BUTLAST t))
val REPLICATE : thm =
  |- REPLICATE 0 x = [] /\ REPLICATE (SUC n) x = CONS x (REPLICATE n x)
val NULL : thm = |- (NULL [] <=> T) /\ (NULL (CONS h t) <=> F)
val ALL : thm = |- (ALL P [] <=> T) /\ (ALL P (CONS h t) <=> P h /\ ALL P t)
val EX : thm = |- (EX P [] <=> F) /\ (EX P (CONS h t) <=> P h \/ EX P t)
val ITLIST : thm =
  |- ITLIST f [] b = b /\ ITLIST f (CONS h t) b = f h (ITLIST f t b)
val MEM : thm =
  |- (MEM x [] <=> F) /\ (MEM x (CONS h t) <=> x = h \/ MEM x t)
val ALL2_DEF : thm =
  |- (ALL2 P [] l2 <=> l2 = []) /\
     (ALL2 P (CONS h1 t1) l2 <=>
      (if l2 = [] then F else P h1 (HD l2) /\ ALL2 P t1 (TL l2)))
val ALL2 : thm =
  |- (ALL2 P [] [] <=> T) /\
     (ALL2 P (CONS h1 t1) [] <=> F) /\
     (ALL2 P [] (CONS h2 t2) <=> F) /\
     (ALL2 P (CONS h1 t1) (CONS h2 t2) <=> P h1 h2 /\ ALL2 P t1 t2)
val MAP2_DEF : thm =
  |- MAP2 f [] l = [] /\
     MAP2 f (CONS h1 t1) l = CONS (f h1 (HD l)) (MAP2 f t1 (TL l))
val MAP2 : thm =
  |- MAP2 f [] [] = [] /\
     MAP2 f (CONS h1 t1) (CONS h2 t2) = CONS (f h1 h2) (MAP2 f t1 t2)
val EL : thm = |- EL 0 l = HD l /\ EL (SUC n) l = EL n (TL l)
val FILTER : thm =
  |- FILTER P [] = [] /\
     FILTER P (CONS h t) = (if P h then CONS h (FILTER P t) else FILTER P t)
val ASSOC : thm =
  |- ASSOC a (CONS h t) = (if FST h = a then SND h else ASSOC a t)
val ITLIST2_DEF : thm =
  |- ITLIST2 f [] l2 b = b /\
     ITLIST2 f (CONS h1 t1) l2 b = f h1 (HD l2) (ITLIST2 f t1 (TL l2) b)
val ITLIST2 : thm =
  |- ITLIST2 f [] [] b = b /\
     ITLIST2 f (CONS h1 t1) (CONS h2 t2) b = f h1 h2 (ITLIST2 f t1 t2 b)
val ZIP_DEF : thm =
  |- ZIP [] l2 = [] /\ ZIP (CONS h1 t1) l2 = CONS (h1,HD l2) (ZIP t1 (TL l2))
val ZIP : thm =
  |- ZIP [] [] = [] /\
     ZIP (CONS h1 t1) (CONS h2 t2) = CONS (h1,h2) (ZIP t1 t2)
val NOT_CONS_NIL : thm = |- !h t. ~(CONS h t = [])
val LAST_CLAUSES : thm =
  |- LAST [h] = h /\ LAST (CONS h (CONS k t)) = LAST (CONS k t)
val APPEND_NIL : thm = |- !l. APPEND l [] = l
val APPEND_ASSOC : thm =
  |- !l m n. APPEND l (APPEND m n) = APPEND (APPEND l m) n
val REVERSE_APPEND : thm =
  |- !l m. REVERSE (APPEND l m) = APPEND (REVERSE m) (REVERSE l)
val REVERSE_REVERSE : thm = |- !l. REVERSE (REVERSE l) = l
val CONS_11 : thm =
  |- !h1 h2 t1 t2. CONS h1 t1 = CONS h2 t2 <=> h1 = h2 /\ t1 = t2
val list_CASES : thm = |- !l. l = [] \/ (?h t. l = CONS h t)
val LENGTH_APPEND : thm = |- !l m. LENGTH (APPEND l m) = LENGTH l + LENGTH m
val MAP_APPEND : thm =
  |- !f l1 l2. MAP f (APPEND l1 l2) = APPEND (MAP f l1) (MAP f l2)
val LENGTH_MAP : thm = |- !l f. LENGTH (MAP f l) = LENGTH l
val LENGTH_EQ_NIL : thm = |- !l. LENGTH l = 0 <=> l = []
val LENGTH_EQ_CONS : thm =
  |- !l n. LENGTH l = SUC n <=> (?h t. l = CONS h t /\ LENGTH t = n)
val MAP_o : thm = |- !f g l. MAP (g o f) l = MAP g (MAP f l)
val MAP_EQ : thm = |- !f g l. ALL (\x. f x = g x) l ==> MAP f l = MAP g l
val ALL_IMP : thm =
  |- !P Q l. (!x. MEM x l /\ P x ==> Q x) /\ ALL P l ==> ALL Q l
val NOT_EX : thm = |- !P l. ~EX P l <=> ALL (\x. ~P x) l
val NOT_ALL : thm = |- !P l. ~ALL P l <=> EX (\x. ~P x) l
val ALL_MAP : thm = |- !P f l. ALL P (MAP f l) <=> ALL (P o f) l
val ALL_T : thm = |- !l. ALL (\x. T) l
val MAP_EQ_ALL2 : thm =
  |- !l m. ALL2 (\x y. f x = f y) l m ==> MAP f l = MAP f m
val ALL2_MAP : thm = |- !P f l. ALL2 P (MAP f l) l <=> ALL (\a. P (f a) a) l
val MAP_EQ_DEGEN : thm = |- !l f. ALL (\x. f x = x) l ==> MAP f l = l
val ALL2_AND_RIGHT : thm =
  |- !l m P Q. ALL2 (\x y. P x /\ Q x y) l m <=> ALL P l /\ ALL2 Q l m
val ITLIST_APPEND : thm =
  |- !f a l1 l2. ITLIST f (APPEND l1 l2) a = ITLIST f l1 (ITLIST f l2 a)
val ITLIST_EXTRA : thm =
  |- !l. ITLIST f (APPEND l [a]) b = ITLIST f l (f a b)
val ALL_MP : thm = |- !P Q l. ALL (\x. P x ==> Q x) l /\ ALL P l ==> ALL Q l
val AND_ALL : thm = |- !l. ALL P l /\ ALL Q l <=> ALL (\x. P x /\ Q x) l
val EX_IMP : thm =
  |- !P Q l. (!x. MEM x l /\ P x ==> Q x) /\ EX P l ==> EX Q l
val ALL_MEM : thm = |- !P l. (!x. MEM x l ==> P x) <=> ALL P l
val LENGTH_REPLICATE : thm = |- !n x. LENGTH (REPLICATE n x) = n
val EX_MAP : thm = |- !P f l. EX P (MAP f l) <=> EX (P o f) l
val EXISTS_EX : thm = |- !P l. (?x. EX (P x) l) <=> EX (\s. ?x. P x s) l
val FORALL_ALL : thm = |- !P l. (!x. ALL (P x) l) <=> ALL (\s. !x. P x s) l
val MEM_APPEND : thm =
  |- !x l1 l2. MEM x (APPEND l1 l2) <=> MEM x l1 \/ MEM x l2
val MEM_MAP : thm = |- !f y l. MEM y (MAP f l) <=> (?x. MEM x l /\ y = f x)
val FILTER_APPEND : thm =
  |- !P l1 l2. FILTER P (APPEND l1 l2) = APPEND (FILTER P l1) (FILTER P l2)
val FILTER_MAP : thm =
  |- !P f l. FILTER P (MAP f l) = MAP f (FILTER (P o f) l)
val MEM_FILTER : thm = |- !P l x. MEM x (FILTER P l) <=> P x /\ MEM x l
val EX_MEM : thm = |- !P l. (?x. P x /\ MEM x l) <=> EX P l
val MAP_FST_ZIP : thm =
  |- !l1 l2. LENGTH l1 = LENGTH l2 ==> MAP FST (ZIP l1 l2) = l1
val MAP_SND_ZIP : thm =
  |- !l1 l2. LENGTH l1 = LENGTH l2 ==> MAP SND (ZIP l1 l2) = l2
val MEM_ASSOC : thm = |- !l x. MEM (x,ASSOC x l) l <=> MEM x (MAP FST l)
val ALL_APPEND : thm =
  |- !P l1 l2. ALL P (APPEND l1 l2) <=> ALL P l1 /\ ALL P l2
val MEM_EL : thm = |- !l n. n < LENGTH l ==> MEM (EL n l) l
val MEM_EXISTS_EL : thm =
  |- !l x. MEM x l <=> (?i. i < LENGTH l /\ x = EL i l)
val ALL_EL : thm = |- !P l. (!i. i < LENGTH l ==> P (EL i l)) <=> ALL P l
val ALL2_MAP2 : thm =
  |- !l m. ALL2 P (MAP f l) (MAP g m) <=> ALL2 (\x y. P (f x) (g y)) l m
val AND_ALL2 : thm =
  |- !P Q l m. ALL2 P l m /\ ALL2 Q l m <=> ALL2 (\x y. P x y /\ Q x y) l m
val ALL2_ALL : thm = |- !P l. ALL2 P l l <=> ALL (\x. P x x) l
val APPEND_EQ_NIL : thm = |- !l m. APPEND l m = [] <=> l = [] /\ m = []
val LENGTH_MAP2 : thm =
  |- !f l m. LENGTH l = LENGTH m ==> LENGTH (MAP2 f l m) = LENGTH m
val MAP_EQ_NIL : thm = |- !f l. MAP f l = [] <=> l = []
val INJECTIVE_MAP : thm =
  |- !f. (!l m. MAP f l = MAP f m ==> l = m) <=> (!x y. f x = f y ==> x = y)
val SURJECTIVE_MAP : thm = |- !f. (!m. ?l. MAP f l = m) <=> (!y. ?x. f x = y)
val MAP_ID : thm = |- !l. MAP (\x. x) l = l
val MAP_I : thm = |- MAP I = I
val APPEND_BUTLAST_LAST : thm =
  |- !l. ~(l = []) ==> APPEND (BUTLAST l) [LAST l] = l
val LAST_APPEND : thm =
  |- !p q. LAST (APPEND p q) = (if q = [] then LAST p else LAST q)
val LENGTH_TL : thm = |- !l. ~(l = []) ==> LENGTH (TL l) = LENGTH l - 1
val EL_APPEND : thm =
  |- !k l m.
         EL k (APPEND l m) =
         (if k < LENGTH l then EL k l else EL (k - LENGTH l) m)
val EL_TL : thm = |- !n. EL n (TL l) = EL (n + 1) l
val EL_CONS : thm =
  |- !n h t. EL n (CONS h t) = (if n = 0 then h else EL (n - 1) t)
val LAST_EL : thm = |- !l. ~(l = []) ==> LAST l = EL (LENGTH l - 1) l
val HD_APPEND : thm =
  |- !l m. HD (APPEND l m) = (if l = [] then HD m else HD l)
val CONS_HD_TL : thm = |- !l. ~(l = []) ==> l = CONS (HD l) (TL l)
val EL_MAP : thm = |- !f n l. n < LENGTH l ==> EL n (MAP f l) = f (EL n l)
val MAP_REVERSE : thm = |- !f l. REVERSE (MAP f l) = MAP f (REVERSE l)
val ALL_FILTER : thm =
  |- !P Q l. ALL P (FILTER Q l) <=> ALL (\x. Q x ==> P x) l
val APPEND_SING : thm = |- !h t. APPEND [h] t = CONS h t
val MEM_APPEND_DECOMPOSE_LEFT : thm =
  |- !x l. MEM x l <=> (?l1 l2. ~MEM x l1 /\ l = APPEND l1 (CONS x l2))
val MEM_APPEND_DECOMPOSE : thm =
  |- !x l. MEM x l <=> (?l1 l2. l = APPEND l1 (CONS x l2))
val MONO_ALL : thm = |- (!x. P x ==> Q x) ==> ALL P l ==> ALL Q l
val MONO_ALL2 : thm =
  |- (!x y. P x y ==> Q x y) ==> ALL2 P l l' ==> ALL2 Q l l'
val char_INDUCT : thm =
  |- !P. (!a0 a1 a2 a3 a4 a5 a6 a7. P (ASCII a0 a1 a2 a3 a4 a5 a6 a7))
         ==> (!x. P x)
val char_RECURSION : thm =
  |- !f. ?fn. !a0 a1 a2 a3 a4 a5 a6 a7.
                  fn (ASCII a0 a1 a2 a3 a4 a5 a6 a7) =
                  f a0 a1 a2 a3 a4 a5 a6 a7
val dist : thm = |- !n m. dist (m,n) = m - n + n - m
val DIST_REFL : thm = |- !n. dist (n,n) = 0
val DIST_LZERO : thm = |- !n. dist (0,n) = n
val DIST_RZERO : thm = |- !n. dist (n,0) = n
val DIST_SYM : thm = |- !m n. dist (m,n) = dist (n,m)
val DIST_LADD : thm = |- !m p n. dist (m + n,m + p) = dist (n,p)
val DIST_RADD : thm = |- !m p n. dist (m + p,n + p) = dist (m,n)
val DIST_LADD_0 : thm = |- !m n. dist (m + n,m) = n
val DIST_RADD_0 : thm = |- !m n. dist (m,m + n) = n
val DIST_LMUL : thm = |- !m n p. m * dist (n,p) = dist (m * n,m * p)
val DIST_RMUL : thm = |- !m n p. dist (m,n) * p = dist (m * p,n * p)
val DIST_EQ_0 : thm = |- !m n. dist (m,n) = 0 <=> m = n
val DIST_ELIM_THM : thm =
  |- P (dist (x,y)) <=> (!d. (x = y + d ==> P d) /\ (y = x + d ==> P d))
val DIST_LE_CASES : thm =
  |- !m n p. dist (m,n) <= p <=> m <= n + p /\ n <= m + p
val DIST_ADDBOUND : thm = |- !m n. dist (m,n) <= m + n
val DIST_TRIANGLE : thm = |- !m n p. dist (m,p) <= dist (m,n) + dist (n,p)
val DIST_ADD2 : thm =
  |- !m n p q. dist (m + n,p + q) <= dist (m,p) + dist (n,q)
val DIST_ADD2_REV : thm =
  |- !m n p q. dist (m,p) <= dist (m + n,p + q) + dist (n,q)
val DIST_TRIANGLE_LE : thm =
  |- !m n p q. dist (m,n) + dist (n,p) <= q ==> dist (m,p) <= q
val DIST_TRIANGLES_LE : thm =
  |- !m n p q r s.
         dist (m,n) <= r /\ dist (p,q) <= s
         ==> dist (m,p) <= dist (n,q) + r + s
val BOUNDS_LINEAR : thm = |- !A B C. (!n. A * n <= B * n + C) <=> A <= B
val BOUNDS_LINEAR_0 : thm = |- !A B. (!n. A * n <= B) <=> A = 0
val BOUNDS_DIVIDED : thm =
  |- !P. (?B. !n. P n <= B) <=> (?A B. !n. n * P n <= A * n + B)
val BOUNDS_NOTZERO : thm =
  |- !P A B.
         P 0 0 = 0 /\ (!m n. P m n <= A * (m + n) + B)
         ==> (?B. !m n. P m n <= B * (m + n))
val BOUNDS_IGNORE : thm =
  |- !P Q. (?B. !i. P i <= Q i + B) <=> (?B N. !i. N <= i ==> P i <= Q i + B)
val is_nadd : thm =
  |- !x. is_nadd x <=> (?B. !m n. dist (m * x n,n * x m) <= B * (m + n))
val is_nadd_0 : thm = |- is_nadd (\n. 0)
val nadd_abs : thm = |- mk_nadd (dest_nadd a) = a
val nadd_rep : thm = |- is_nadd r <=> dest_nadd (mk_nadd r) = r
val NADD_CAUCHY : thm =
  |- !x. ?B. !m n. dist (m * fn x n,n * fn x m) <= B * (m + n)
val NADD_BOUND : thm = |- !x. ?A B. !n. fn x n <= A * n + B
val NADD_MULTIPLICATIVE : thm =
  |- !x. ?B. !m n. dist (fn x (m * n),m * fn x n) <= B * m + B
val NADD_ADDITIVE : thm =
  |- !x. ?B. !m n. dist (fn x (m + n),fn x m + fn x n) <= B
val NADD_SUC : thm = |- !x. ?B. !n. dist (fn x (SUC n),fn x n) <= B
val NADD_DIST_LEMMA : thm =
  |- !x. ?B. !m n. dist (fn x (m + n),fn x m) <= B * n
val NADD_DIST : thm = |- !x. ?B. !m n. dist (fn x m,fn x n) <= B * dist (m,n)
val NADD_ALTMUL : thm =
  |- !x y. ?A B. !n. dist (n * fn x (fn y n),fn x n * fn y n) <= A * n + B
val nadd_eq : thm = |- !x y. x === y <=> (?B. !n. dist (fn x n,fn y n) <= B)
val NADD_EQ_REFL : thm = |- !x. x === x
val NADD_EQ_SYM : thm = |- !x y. x === y <=> y === x
val NADD_EQ_TRANS : thm = |- !x y z. x === y /\ y === z ==> x === z
val nadd_of_num : thm = |- !k. & k = afn (\n. k * n)
val NADD_OF_NUM : thm = |- !k. fn (& k) = (\n. k * n)
val NADD_OF_NUM_WELLDEF : thm = |- !m n. m = n ==> & m === & n
val NADD_OF_NUM_EQ : thm = |- !m n. & m === & n <=> m = n
val nadd_le : thm = |- !x y. x <<= y <=> (?B. !n. fn x n <= fn y n + B)
val NADD_LE_WELLDEF_LEMMA : thm =
  |- !x x' y y'. x === x' /\ y === y' /\ x <<= y ==> x' <<= y'
val NADD_LE_WELLDEF : thm =
  |- !x x' y y'. x === x' /\ y === y' ==> (x <<= y <=> x' <<= y')
val NADD_LE_REFL : thm = |- !x. x <<= x
val NADD_LE_TRANS : thm = |- !x y z. x <<= y /\ y <<= z ==> x <<= z
val NADD_LE_ANTISYM : thm = |- !x y. x <<= y /\ y <<= x <=> x === y
val NADD_LE_TOTAL_LEMMA : thm =
  |- !x y. ~(x <<= y) ==> (!B. ?n. ~(n = 0) /\ fn y n + B < fn x n)
val NADD_LE_TOTAL : thm = |- !x y. x <<= y \/ y <<= x
val NADD_ARCH : thm = |- !x. ?n. x <<= & n
val NADD_OF_NUM_LE : thm = |- !m n. & m <<= & n <=> m <= n
val nadd_add : thm = |- !x y. x ++ y = afn (\n. fn x n + fn y n)
val NADD_ADD : thm = |- !x y. fn (x ++ y) = (\n. fn x n + fn y n)
val NADD_ADD_WELLDEF : thm =
  |- !x x' y y'. x === x' /\ y === y' ==> x ++ y === x' ++ y'
val NADD_ADD_SYM : thm = |- !x y. x ++ y === y ++ x
val NADD_ADD_ASSOC : thm = |- !x y z. x ++ y ++ z === (x ++ y) ++ z
val NADD_ADD_LID : thm = |- !x. & 0 ++ x === x
val NADD_ADD_LCANCEL : thm = |- !x y z. x ++ y === x ++ z ==> y === z
val NADD_LE_ADD : thm = |- !x y. x <<= x ++ y
val NADD_LE_EXISTS : thm = |- !x y. x <<= y ==> (?d. y === x ++ d)
val NADD_OF_NUM_ADD : thm = |- !m n. & m ++ & n === & (m + n)
val nadd_mul : thm = |- !x y. x ** y = afn (\n. fn x (fn y n))
val NADD_MUL : thm = |- !x y. fn (x ** y) = (\n. fn x (fn y n))
val NADD_MUL_SYM : thm = |- !x y. x ** y === y ** x
val NADD_MUL_ASSOC : thm = |- !x y z. x ** y ** z === (x ** y) ** z
val NADD_MUL_LID : thm = |- !x. & 1 ** x === x
val NADD_LDISTRIB : thm = |- !x y z. x ** (y ++ z) === x ** y ++ x ** z
val NADD_MUL_WELLDEF_LEMMA : thm =
  |- !x y y'. y === y' ==> x ** y === x ** y'
val NADD_MUL_WELLDEF : thm =
  |- !x x' y y'. x === x' /\ y === y' ==> x ** y === x' ** y'
val NADD_OF_NUM_MUL : thm = |- !m n. & m ** & n === & (m * n)
val NADD_LE_0 : thm = |- !x. & 0 <<= x
val NADD_EQ_IMP_LE : thm = |- !x y. x === y ==> x <<= y
val NADD_LE_LMUL : thm = |- !x y z. y <<= z ==> x ** y <<= x ** z
val NADD_LE_RMUL : thm = |- !x y z. x <<= y ==> x ** z <<= y ** z
val NADD_LE_RADD : thm = |- !x y z. x ++ z <<= y ++ z <=> x <<= y
val NADD_LE_LADD : thm = |- !x y z. x ++ y <<= x ++ z <=> y <<= z
val NADD_RDISTRIB : thm = |- !x y z. (x ++ y) ** z === x ** z ++ y ** z
val NADD_ARCH_MULT : thm = |- !x k. ~(x === & 0) ==> (?N. & k <<= & N ** x)
val NADD_ARCH_ZERO : thm = |- !x k. (!n. & n ** x <<= k) ==> x === & 0
val NADD_ARCH_LEMMA : thm =
  |- !x y z. (!n. & n ** x <<= & n ** y ++ z) ==> x <<= y
val NADD_COMPLETE : thm =
  |- !P. (?x. P x) /\ (?M. !x. P x ==> x <<= M)
         ==> (?M. (!x. P x ==> x <<= M) /\
                  (!M'. (!x. P x ==> x <<= M') ==> M <<= M'))
val NADD_UBOUND : thm = |- !x. ?B N. !n. N <= n ==> fn x n <= B * n
val NADD_NONZERO : thm =
  |- !x. ~(x === & 0) ==> (?N. !n. N <= n ==> ~(fn x n = 0))
val NADD_LBOUND : thm =
  |- !x. ~(x === & 0) ==> (?A N. !n. N <= n ==> n <= A * fn x n)
val nadd_rinv : thm = |- !x. nadd_rinv x = (\n. (n * n) DIV fn x n)
val NADD_MUL_LINV_LEMMA0 : thm =
  |- !x. ~(x === & 0) ==> (?A B. !n. nadd_rinv x n <= A * n + B)
val NADD_MUL_LINV_LEMMA1 : thm =
  |- !x n. ~(fn x n = 0) ==> dist (fn x n * nadd_rinv x n,n * n) <= fn x n
val NADD_MUL_LINV_LEMMA2 : thm =
  |- !x. ~(x === & 0)
         ==> (?N. !n. N <= n
                      ==> dist (fn x n * nadd_rinv x n,n * n) <= fn x n)
val NADD_MUL_LINV_LEMMA3 : thm =
  |- !x. ~(x === & 0)
         ==> (?N. !m n.
                      N <= n
                      ==> dist
                          (m * fn x m * fn x n * nadd_rinv x n,
                           m * fn x m * n * n) <=
                          m * fn x m * fn x n)
val NADD_MUL_LINV_LEMMA4 : thm =
  |- !x. ~(x === & 0)
         ==> (?N. !m n.
                      N <= m /\ N <= n
                      ==> (fn x m * fn x n) *
                          dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                          (m * n) * dist (m * fn x n,n * fn x m) +
                          (fn x m * fn x n) * (m + n))
val NADD_MUL_LINV_LEMMA5 : thm =
  |- !x. ~(x === & 0)
         ==> (?B N.
                  !m n.
                      N <= m /\ N <= n
                      ==> (fn x m * fn x n) *
                          dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                          B * (m * n) * (m + n))
val NADD_MUL_LINV_LEMMA6 : thm =
  |- !x. ~(x === & 0)
         ==> (?B N.
                  !m n.
                      N <= m /\ N <= n
                      ==> (m * n) *
                          dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                          B * (m * n) * (m + n))
val NADD_MUL_LINV_LEMMA7 : thm =
  |- !x. ~(x === & 0)
         ==> (?B N.
                  !m n.
                      N <= m /\ N <= n
                      ==> dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                          B * (m + n))
val NADD_MUL_LINV_LEMMA7a : thm =
  |- !x. ~(x === & 0)
         ==> (!N. ?A B.
                      !m n.
                          m <= N
                          ==> dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                              A * n + B)
val NADD_MUL_LINV_LEMMA8 : thm =
  |- !x. ~(x === & 0)
         ==> (?B. !m n.
                      dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                      B * (m + n))
val nadd_inv : thm =
  |- !x. nadd_inv x = (if x === & 0 then & 0 else afn (nadd_rinv x))
val NADD_INV : thm =
  |- !x. fn (inv x) = (if x === & 0 then \n. 0 else nadd_rinv x)
val NADD_MUL_LINV : thm = |- !x. ~(x === & 0) ==> inv x ** x === & 1
val NADD_INV_0 : thm = |- inv (& 0) === & 0
val NADD_INV_WELLDEF : thm = |- !x y. x === y ==> inv x === inv y
val hreal_of_num : thm = |- & m = mk_hreal (\u. nadd_of_num m === u)
val hreal_of_num_th : thm = |- mk_hreal ((===) (nadd_of_num m)) = & m
val hreal_add : thm =
  |- x + y =
     mk_hreal (\u. ?x y. x ++ y === u /\ dest_hreal x x /\ dest_hreal y y)
val hreal_add_th : thm =
  |- mk_hreal ((===) (x ++ y)) = mk_hreal ((===) x) + mk_hreal ((===) y)
val hreal_mul : thm =
  |- x * y =
     mk_hreal (\u. ?x y. x ** y === u /\ dest_hreal x x /\ dest_hreal y y)
val hreal_mul_th : thm =
  |- mk_hreal ((===) (x ** y)) = mk_hreal ((===) x) * mk_hreal ((===) y)
val hreal_le : thm =
  |- x <= y <=>
     (@u. ?x y. (x <<= y <=> u) /\ dest_hreal x x /\ dest_hreal y y)
val hreal_le_th : thm =
  |- x <<= y <=> mk_hreal ((===) x) <= mk_hreal ((===) y)
val hreal_inv : thm =
  |- inv x = mk_hreal (\u. ?x. nadd_inv x === u /\ dest_hreal x x)
val hreal_inv_th : thm =
  |- mk_hreal ((===) (nadd_inv x)) = inv (mk_hreal ((===) x))
val HREAL_COMPLETE : thm =
  |- !P. (?x. P x) /\ (?M. !x. P x ==> x <= M)
         ==> (?M. (!x. P x ==> x <= M) /\
                  (!M'. (!x. P x ==> x <= M') ==> M <= M'))
val HREAL_OF_NUM_EQ : thm = |- !m n. & m = & n <=> m = n
val HREAL_OF_NUM_LE : thm = |- !m n. & m <= & n <=> m <= n
val HREAL_OF_NUM_ADD : thm = |- !m n. & m + & n = & (m + n)
val HREAL_OF_NUM_MUL : thm = |- !m n. & m * & n = & (m * n)
val HREAL_LE_REFL : thm = |- !x. x <= x
val HREAL_LE_TRANS : thm = |- !x y z. x <= y /\ y <= z ==> x <= z
val HREAL_LE_ANTISYM : thm = |- !x y. x <= y /\ y <= x <=> x = y
val HREAL_LE_TOTAL : thm = |- !x y. x <= y \/ y <= x
val HREAL_LE_ADD : thm = |- !x y. x <= x + y
val HREAL_LE_EXISTS : thm = |- !x y. x <= y ==> (?d. y = x + d)
val HREAL_ARCH : thm = |- !x. ?n. x <= & n
val HREAL_ADD_SYM : thm = |- !x y. x + y = y + x
val HREAL_ADD_ASSOC : thm = |- !x y z. x + y + z = (x + y) + z
val HREAL_ADD_LID : thm = |- !x. & 0 + x = x
val HREAL_ADD_LCANCEL : thm = |- !x y z. x + y = x + z ==> y = z
val HREAL_MUL_SYM : thm = |- !x y. x * y = y * x
val HREAL_MUL_ASSOC : thm = |- !x y z. x * y * z = (x * y) * z
val HREAL_MUL_LID : thm = |- !x. & 1 * x = x
val HREAL_ADD_LDISTRIB : thm = |- !x y z. x * (y + z) = x * y + x * z
val HREAL_MUL_LINV : thm = |- !x. ~(x = & 0) ==> inv x * x = & 1
val HREAL_INV_0 : thm = |- inv (& 0) = & 0
val HREAL_LE_EXISTS_DEF : thm = |- !m n. m <= n <=> (?d. n = m + d)
val HREAL_EQ_ADD_LCANCEL : thm = |- !m n p. m + n = m + p <=> n = p
val HREAL_EQ_ADD_RCANCEL : thm = |- !m n p. m + p = n + p <=> m = n
val HREAL_LE_ADD_LCANCEL : thm = |- !m n p. m + n <= m + p <=> n <= p
val HREAL_LE_ADD_RCANCEL : thm = |- !m n p. m + p <= n + p <=> m <= n
val HREAL_ADD_RID : thm = |- !n. n + & 0 = n
val HREAL_ADD_RDISTRIB : thm = |- !m n p. (m + n) * p = m * p + n * p
val HREAL_MUL_LZERO : thm = |- !m. & 0 * m = & 0
val HREAL_MUL_RZERO : thm = |- !m. m * & 0 = & 0
val HREAL_ADD_AC : thm =
  |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
val HREAL_LE_ADD2 : thm = |- !a b c d. a <= b /\ c <= d ==> a + c <= b + d
val HREAL_LE_MUL_RCANCEL_IMP : thm = |- !a b c. a <= b ==> a * c <= b * c
val treal_of_num : thm = |- !n. treal_of_num n = & n,& 0
val treal_neg : thm = |- !y x. treal_neg (x,y) = y,x
val treal_add : thm =
  |- !x1 x2 y1 y2. (x1,y1) treal_add (x2,y2) = x1 + x2,y1 + y2
val treal_mul : thm =
  |- !x1 y2 y1 x2.
         (x1,y1) treal_mul (x2,y2) = x1 * x2 + y1 * y2,x1 * y2 + y1 * x2
val treal_le : thm =
  |- !x1 y2 x2 y1. x1,y1 treal_le x2,y2 <=> x1 + y2 <= x2 + y1
val treal_inv : thm =
  |- !y x.
         treal_inv (x,y) =
         (if x = y
          then & 0,& 0
          else if y <= x
               then inv (@d. x = y + d),& 0
               else & 0,inv (@d. y = x + d))
val treal_eq : thm =
  |- !x1 y2 x2 y1. x1,y1 treal_eq x2,y2 <=> x1 + y2 = x2 + y1
val TREAL_EQ_REFL : thm = |- !x. x treal_eq x
val TREAL_EQ_SYM : thm = |- !x y. x treal_eq y <=> y treal_eq x
val TREAL_EQ_TRANS : thm =
  |- !x y z. x treal_eq y /\ y treal_eq z ==> x treal_eq z
val TREAL_EQ_AP : thm = |- !x y. x = y ==> x treal_eq y
val TREAL_OF_NUM_EQ : thm =
  |- !m n. treal_of_num m treal_eq treal_of_num n <=> m = n
val TREAL_OF_NUM_LE : thm =
  |- !m n. treal_of_num m treal_le treal_of_num n <=> m <= n
val TREAL_OF_NUM_ADD : thm =
  |- !m n.
         treal_of_num m treal_add treal_of_num n treal_eq
         treal_of_num (m + n)
val TREAL_OF_NUM_MUL : thm =
  |- !m n.
         treal_of_num m treal_mul treal_of_num n treal_eq
         treal_of_num (m * n)
val TREAL_ADD_SYM_EQ : thm = |- !x y. x treal_add y = y treal_add x
val TREAL_MUL_SYM_EQ : thm = |- !x y. x treal_mul y = y treal_mul x
val TREAL_ADD_SYM : thm = |- !x y. x treal_add y treal_eq y treal_add x
val TREAL_ADD_ASSOC : thm =
  |- !x y z. x treal_add y treal_add z treal_eq (x treal_add y) treal_add z
val TREAL_ADD_LID : thm = |- !x. treal_of_num 0 treal_add x treal_eq x
val TREAL_ADD_LINV : thm =
  |- !x. treal_neg x treal_add x treal_eq treal_of_num 0
val TREAL_MUL_SYM : thm = |- !x y. x treal_mul y treal_eq y treal_mul x
val TREAL_MUL_ASSOC : thm =
  |- !x y z. x treal_mul y treal_mul z treal_eq (x treal_mul y) treal_mul z
val TREAL_MUL_LID : thm = |- !x. treal_of_num 1 treal_mul x treal_eq x
val TREAL_ADD_LDISTRIB : thm =
  |- !x y z.
         x treal_mul (y treal_add z) treal_eq
         x treal_mul y treal_add x treal_mul z
val TREAL_LE_REFL : thm = |- !x. x treal_le x
val TREAL_LE_ANTISYM : thm =
  |- !x y. x treal_le y /\ y treal_le x <=> x treal_eq y
val TREAL_LE_TRANS : thm =
  |- !x y z. x treal_le y /\ y treal_le z ==> x treal_le z
val TREAL_LE_TOTAL : thm = |- !x y. x treal_le y \/ y treal_le x
val TREAL_LE_LADD_IMP : thm =
  |- !x y z. y treal_le z ==> x treal_add y treal_le x treal_add z
val TREAL_LE_MUL : thm =
  |- !x y.
         treal_of_num 0 treal_le x /\ treal_of_num 0 treal_le y
         ==> treal_of_num 0 treal_le x treal_mul y
val TREAL_INV_0 : thm = |- treal_inv (treal_of_num 0) treal_eq treal_of_num 0
val TREAL_MUL_LINV : thm =
  |- !x. ~(x treal_eq treal_of_num 0)
         ==> treal_inv x treal_mul x treal_eq treal_of_num 1
val TREAL_OF_NUM_WELLDEF : thm =
  |- !m n. m = n ==> treal_of_num m treal_eq treal_of_num n
val TREAL_NEG_WELLDEF : thm =
  |- !x1 x2. x1 treal_eq x2 ==> treal_neg x1 treal_eq treal_neg x2
val TREAL_ADD_WELLDEFR : thm =
  |- !x1 x2 y. x1 treal_eq x2 ==> x1 treal_add y treal_eq x2 treal_add y
val TREAL_ADD_WELLDEF : thm =
  |- !x1 x2 y1 y2.
         x1 treal_eq x2 /\ y1 treal_eq y2
         ==> x1 treal_add y1 treal_eq x2 treal_add y2
val TREAL_MUL_WELLDEFR : thm =
  |- !x1 x2 y. x1 treal_eq x2 ==> x1 treal_mul y treal_eq x2 treal_mul y
val TREAL_MUL_WELLDEF : thm =
  |- !x1 x2 y1 y2.
         x1 treal_eq x2 /\ y1 treal_eq y2
         ==> x1 treal_mul y1 treal_eq x2 treal_mul y2
val TREAL_EQ_IMP_LE : thm = |- !x y. x treal_eq y ==> x treal_le y
val TREAL_LE_WELLDEF : thm =
  |- !x1 x2 y1 y2.
         x1 treal_eq x2 /\ y1 treal_eq y2
         ==> (x1 treal_le y1 <=> x2 treal_le y2)
val TREAL_INV_WELLDEF : thm =
  |- !x y. x treal_eq y ==> treal_inv x treal_eq treal_inv y
  (|- mk_real (dest_real a) = a,
   |- (?x. r = (treal_eq) x) <=> dest_real (mk_real r) = r)
val real_of_num : thm =
  |- real_of_numm = mk_real (\u. treal_of_num m treal_eq u)
val real_of_num_th : thm =
  |- mk_real ((treal_eq) (treal_of_num m)) = real_of_numm
val real_neg : thm =
  |- real_neg x1 =
     mk_real (\u. ?x1. treal_neg x1 treal_eq u /\ dest_real x1 x1)
val real_neg_th : thm =
  |- mk_real ((treal_eq) (treal_neg x1)) = real_neg (mk_real ((treal_eq) x1))
val real_add : thm =
  |- real_add x1 y1 =
     mk_real
     (\u. ?x1 y1.
              x1 treal_add y1 treal_eq u /\
              dest_real x1 x1 /\
              dest_real y1 y1)
val real_add_th : thm =
  |- mk_real ((treal_eq) (x1 treal_add y1)) =
     real_add (mk_real ((treal_eq) x1)) (mk_real ((treal_eq) y1))
val real_mul : thm =
  |- real_mul x1 y1 =
     mk_real
     (\u. ?x1 y1.
              x1 treal_mul y1 treal_eq u /\
              dest_real x1 x1 /\
              dest_real y1 y1)
val real_mul_th : thm =
  |- mk_real ((treal_eq) (x1 treal_mul y1)) =
     real_mul (mk_real ((treal_eq) x1)) (mk_real ((treal_eq) y1))
val real_le : thm =
  |- real_le x1 y1 <=>
     (@u. ?x1 y1.
              (x1 treal_le y1 <=> u) /\ dest_real x1 x1 /\ dest_real y1 y1)
val real_le_th : thm =
  |- x1 treal_le y1 <=>
     real_le (mk_real ((treal_eq) x1)) (mk_real ((treal_eq) y1))
val real_inv : thm =
  |- real_inv x = mk_real (\u. ?x. treal_inv x treal_eq u /\ dest_real x x)
val real_inv_th : thm =
  |- mk_real ((treal_eq) (treal_inv x)) = real_inv (mk_real ((treal_eq) x))
val REAL_ADD_SYM : thm = |- !x y. real_add x y = real_add y x
val REAL_ADD_ASSOC : thm =
  |- !x y z. real_add x (real_add y z) = real_add (real_add x y) z
val REAL_ADD_LID : thm = |- !x. real_add (real_of_num0) x = x
val REAL_ADD_LINV : thm = |- !x. real_add (real_neg x) x = real_of_num0
val REAL_MUL_SYM : thm = |- !x y. real_mul x y = real_mul y x
val REAL_MUL_ASSOC : thm =
  |- !x y z. real_mul x (real_mul y z) = real_mul (real_mul x y) z
val REAL_MUL_LID : thm = |- !x. real_mul (real_of_num1) x = x
val REAL_ADD_LDISTRIB : thm =
  |- !x y z.
         real_mul x (real_add y z) = real_add (real_mul x y) (real_mul x z)
val REAL_LE_REFL : thm = |- !x. real_le x x
val REAL_LE_ANTISYM : thm = |- !x y. real_le x y /\ real_le y x <=> x = y
val REAL_LE_TRANS : thm =
  |- !x y z. real_le x y /\ real_le y z ==> real_le x z
val REAL_LE_TOTAL : thm = |- !x y. real_le x y \/ real_le y x
val REAL_LE_LADD_IMP : thm =
  |- !x y z. real_le y z ==> real_le (real_add x y) (real_add x z)
val REAL_LE_MUL : thm =
  |- !x y.
         real_le (real_of_num0) x /\ real_le (real_of_num0) y
         ==> real_le (real_of_num0) (real_mul x y)
val REAL_INV_0 : thm = |- real_inv (real_of_num0) = real_of_num0
val REAL_MUL_LINV : thm =
  |- !x. ~(x = real_of_num0) ==> real_mul (real_inv x) x = real_of_num1
val REAL_OF_NUM_EQ : thm = |- !m n. real_of_numm = real_of_numn <=> m = n
val REAL_OF_NUM_LE : thm =
  |- !m n. real_le (real_of_numm) (real_of_numn) <=> m <= n
val REAL_OF_NUM_ADD : thm =
  |- !m n. real_add (real_of_numm) (real_of_numn) = real_of_num(m + n)
val REAL_OF_NUM_MUL : thm =
  |- !m n. real_mul (real_of_numm) (real_of_numn) = real_of_num(m * n)
val real_sub : thm = |- !x y. x - y = x + --y
val real_lt : thm = |- !y x. x < y <=> ~(y <= x)
val real_ge : thm = |- !y x. x >= y <=> y <= x
val real_gt : thm = |- !y x. x > y <=> y < x
val real_abs : thm = |- !x. abs x = (if &0 <= x then x else --x)
val real_pow : thm = |- x pow 0 = &1 /\ (!n. x pow SUC n = x * x pow n)
val real_div : thm = |- !x y. x / y = x * inv y
val real_max : thm = |- !n m. max m n = (if m <= n then n else m)
val real_min : thm = |- !m n. min m n = (if m <= n then m else n)
val REAL_HREAL_LEMMA1 : thm =
  |- ?r. (!x. &0 <= x <=> (?y. x = r y)) /\ (!y z. y <= z <=> r y <= r z)
val REAL_HREAL_LEMMA2 : thm =
  |- ?h r.
         (!x. h (r x) = x) /\
         (!x. &0 <= x ==> r (h x) = x) /\
         (!x. &0 <= r x) /\
         (!x y. x <= y <=> r x <= r y)
val REAL_COMPLETE_SOMEPOS : thm =
  |- !P. (?x. P x /\ &0 <= x) /\ (?M. !x. P x ==> x <= M)
         ==> (?M. (!x. P x ==> x <= M) /\
                  (!M'. (!x. P x ==> x <= M') ==> M <= M'))
val REAL_COMPLETE : thm =
  |- !P. (?x. P x) /\ (?M. !x. P x ==> x <= M)
         ==> (?M. (!x. P x ==> x <= M) /\
                  (!M'. (!x. P x ==> x <= M') ==> M <= M'))
val REAL_ADD_AC : thm =
  |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
val REAL_ADD_RINV : thm = |- !x. x + --x = &0
val REAL_EQ_ADD_LCANCEL : thm = |- !x y z. x + y = x + z <=> y = z
val REAL_EQ_ADD_RCANCEL : thm = |- !x y z. x + z = y + z <=> x = y
val REAL_MUL_RZERO : thm = |- !x. x * &0 = &0
val REAL_MUL_LZERO : thm = |- !x. &0 * x = &0
val REAL_NEG_NEG : thm = |- !x. -- --x = x
val REAL_MUL_RNEG : thm = |- !x y. x * --y = --(x * y)
val REAL_MUL_LNEG : thm = |- !x y. --x * y = --(x * y)
val REAL_NEG_ADD : thm = |- !x y. --(x + y) = --x + --y
val REAL_ADD_RID : thm = |- !x. x + &0 = x
val REAL_NEG_0 : thm = |- -- &0 = &0
val REAL_LE_LNEG : thm = |- !x y. --x <= y <=> &0 <= x + y
val REAL_LE_NEG2 : thm = |- !x y. --x <= --y <=> y <= x
val REAL_LE_RNEG : thm = |- !x y. x <= --y <=> x + y <= &0
val REAL_OF_NUM_POW : thm = |- !x n. &x pow n = &(x EXP n)
val REAL_POW_NEG : thm =
  |- !x n. --x pow n = (if EVEN n then x pow n else --(x pow n))
val REAL_ABS_NUM : thm = |- !n. abs (&n) = &n
val REAL_ABS_NEG : thm = |- !x. abs (--x) = abs x
val REAL_LTE_TOTAL : thm = |- !x y. x < y \/ y <= x
val REAL_LET_TOTAL : thm = |- !x y. x <= y \/ y < x
val REAL_LT_IMP_LE : thm = |- !x y. x < y ==> x <= y
val REAL_LTE_TRANS : thm = |- !x y z. x < y /\ y <= z ==> x < z
val REAL_LET_TRANS : thm = |- !x y z. x <= y /\ y < z ==> x < z
val REAL_LT_TRANS : thm = |- !x y z. x < y /\ y < z ==> x < z
val REAL_LE_ADD : thm = |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x + y
val REAL_LTE_ANTISYM : thm = |- !x y. ~(x < y /\ y <= x)
val REAL_SUB_LE : thm = |- !x y. &0 <= x - y <=> y <= x
val REAL_NEG_SUB : thm = |- !x y. --(x - y) = y - x
val REAL_LE_LT : thm = |- !x y. x <= y <=> x < y \/ x = y
val REAL_SUB_LT : thm = |- !x y. &0 < x - y <=> y < x
val REAL_NOT_LT : thm = |- !x y. ~(x < y) <=> y <= x
val REAL_SUB_0 : thm = |- !x y. x - y = &0 <=> x = y
val REAL_LT_LE : thm = |- !x y. x < y <=> x <= y /\ ~(x = y)
val REAL_LT_REFL : thm = |- !x. ~(x < x)
val REAL_LTE_ADD : thm = |- !x y. &0 < x /\ &0 <= y ==> &0 < x + y
val REAL_LET_ADD : thm = |- !x y. &0 <= x /\ &0 < y ==> &0 < x + y
val REAL_LT_ADD : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x + y
val REAL_ENTIRE : thm = |- !x y. x * y = &0 <=> x = &0 \/ y = &0
val REAL_LE_NEGTOTAL : thm = |- !x. &0 <= x \/ &0 <= --x
val REAL_LE_SQUARE : thm = |- !x. &0 <= x * x
val REAL_MUL_RID : thm = |- !x. x * &1 = x
val REAL_POW_2 : thm = |- !x. x pow 2 = x * x
val REAL_POLY_CLAUSES : thm =
  |- (!x y z. x + y + z = (x + y) + z) /\
     (!x y. x + y = y + x) /\
     (!x. &0 + x = x) /\
     (!x y z. x * y * z = (x * y) * z) /\
     (!x y. x * y = y * x) /\
     (!x. &1 * x = x) /\
     (!x. &0 * x = &0) /\
     (!x y z. x * (y + z) = x * y + x * z) /\
     (!x. x pow 0 = &1) /\
     (!x n. x pow SUC n = x * x pow n)
val REAL_POLY_NEG_CLAUSES : thm =
  |- (!x. --x = -- &1 * x) /\ (!x y. x - y = x + -- &1 * y)
val REAL_POS : thm = |- !n. &0 <= &n
val REAL_OF_NUM_LT : thm = |- !m n. &m < &n <=> m < n
val REAL_OF_NUM_GE : thm = |- !m n. &m >= &n <=> m >= n
val REAL_OF_NUM_GT : thm = |- !m n. &m > &n <=> m > n
val REAL_OF_NUM_MAX : thm = |- !m n. max (&m) (&n) = &(MAX m n)
val REAL_OF_NUM_MIN : thm = |- !m n. min (&m) (&n) = &(MIN m n)
val REAL_OF_NUM_SUC : thm = |- !n. &n + &1 = &(SUC n)
val REAL_OF_NUM_SUB : thm = |- !m n. m <= n ==> &n - &m = &(n - m)
val REAL_OF_NUM_SUB_CASES : thm =
  |- !m n. &m - &n = (if n <= m then &(m - n) else -- &(n - m))
val REAL_MUL_AC : thm =
  |- m * n = n * m /\ (m * n) * p = m * n * p /\ m * n * p = n * m * p
val REAL_ADD_RDISTRIB : thm = |- !x y z. (x + y) * z = x * z + y * z
val REAL_LT_LADD_IMP : thm = |- !x y z. y < z ==> x + y < x + z
val REAL_LT_MUL : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x * y
val REAL_EQ_ADD_LCANCEL_0 : thm = |- !x y. x + y = x <=> y = &0
val REAL_EQ_ADD_RCANCEL_0 : thm = |- !x y. x + y = y <=> x = &0
val REAL_LNEG_UNIQ : thm = |- !x y. x + y = &0 <=> x = --y
val REAL_RNEG_UNIQ : thm = |- !x y. x + y = &0 <=> y = --x
val REAL_NEG_LMUL : thm = |- !x y. --(x * y) = --x * y
val REAL_NEG_RMUL : thm = |- !x y. --(x * y) = x * --y
val REAL_NEGNEG : thm = |- !x. -- --x = x
val REAL_NEG_MUL2 : thm = |- !x y. --x * --y = x * y
val REAL_LT_LADD : thm = |- !x y z. x + y < x + z <=> y < z
val REAL_LT_RADD : thm = |- !x y z. x + z < y + z <=> x < y
val REAL_LT_ANTISYM : thm = |- !x y. ~(x < y /\ y < x)
val REAL_LT_GT : thm = |- !x y. x < y ==> ~(y < x)
val REAL_NOT_EQ : thm = |- !x y. ~(x = y) <=> x < y \/ y < x
val REAL_NOT_LE : thm = |- !x y. ~(x <= y) <=> y < x
val REAL_LET_ANTISYM : thm = |- !x y. ~(x <= y /\ y < x)
val REAL_NEG_LT0 : thm = |- !x. --x < &0 <=> &0 < x
val REAL_NEG_GT0 : thm = |- !x. &0 < --x <=> x < &0
val REAL_NEG_LE0 : thm = |- !x. --x <= &0 <=> &0 <= x
val REAL_NEG_GE0 : thm = |- !x. &0 <= --x <=> x <= &0
val REAL_LT_TOTAL : thm = |- !x y. x = y \/ x < y \/ y < x
val REAL_LT_NEGTOTAL : thm = |- !x. x = &0 \/ &0 < x \/ &0 < --x
val REAL_LE_01 : thm = |- &0 <= &1
val REAL_LT_01 : thm = |- &0 < &1
val REAL_LE_LADD : thm = |- !x y z. x + y <= x + z <=> y <= z
val REAL_LE_RADD : thm = |- !x y z. x + z <= y + z <=> x <= y
val REAL_LT_ADD2 : thm = |- !w x y z. w < x /\ y < z ==> w + y < x + z
val REAL_LE_ADD2 : thm = |- !w x y z. w <= x /\ y <= z ==> w + y <= x + z
val REAL_LT_LNEG : thm = |- !x y. --x < y <=> &0 < x + y
val REAL_LT_RNEG : thm = |- !x y. x < --y <=> x + y < &0
val REAL_LT_ADDNEG : thm = |- !x y z. y < x + --z <=> y + z < x
val REAL_LT_ADDNEG2 : thm = |- !x y z. x + --y < z <=> x < z + y
val REAL_LT_ADD1 : thm = |- !x y. x <= y ==> x < y + &1
val REAL_SUB_ADD : thm = |- !x y. x - y + y = x
val REAL_SUB_ADD2 : thm = |- !x y. y + x - y = x
val REAL_SUB_REFL : thm = |- !x. x - x = &0
val REAL_LE_DOUBLE : thm = |- !x. &0 <= x + x <=> &0 <= x
val REAL_LE_NEGL : thm = |- !x. --x <= x <=> &0 <= x
val REAL_LE_NEGR : thm = |- !x. x <= --x <=> x <= &0
val REAL_NEG_EQ_0 : thm = |- !x. --x = &0 <=> x = &0
val REAL_ADD_SUB : thm = |- !x y. (x + y) - x = y
val REAL_NEG_EQ : thm = |- !x y. --x = y <=> x = --y
val REAL_NEG_MINUS1 : thm = |- !x. --x = -- &1 * x
val REAL_LT_IMP_NE : thm = |- !x y. x < y ==> ~(x = y)
val REAL_LE_ADDR : thm = |- !x y. x <= x + y <=> &0 <= y
val REAL_LE_ADDL : thm = |- !x y. y <= x + y <=> &0 <= x
val REAL_LT_ADDR : thm = |- !x y. x < x + y <=> &0 < y
val REAL_LT_ADDL : thm = |- !x y. y < x + y <=> &0 < x
val REAL_SUB_SUB : thm = |- !x y. x - y - x = --y
val REAL_LT_ADD_SUB : thm = |- !x y z. x + y < z <=> x < z - y
val REAL_LT_SUB_RADD : thm = |- !x y z. x - y < z <=> x < z + y
val REAL_LT_SUB_LADD : thm = |- !x y z. x < y - z <=> x + z < y
val REAL_LE_SUB_LADD : thm = |- !x y z. x <= y - z <=> x + z <= y
val REAL_LE_SUB_RADD : thm = |- !x y z. x - y <= z <=> x <= z + y
val REAL_LT_NEG : thm = |- !x y. --x < --y <=> y < x
val REAL_LE_NEG : thm = |- !x y. --x <= --y <=> y <= x
val REAL_ADD2_SUB2 : thm = |- !a b c d. (a + b) - (c + d) = a - c + b - d
val REAL_SUB_LZERO : thm = |- !x. &0 - x = --x
val REAL_SUB_RZERO : thm = |- !x. x - &0 = x
val REAL_LET_ADD2 : thm = |- !w x y z. w <= x /\ y < z ==> w + y < x + z
val REAL_LTE_ADD2 : thm = |- !w x y z. w < x /\ y <= z ==> w + y < x + z
val REAL_SUB_LNEG : thm = |- !x y. --x - y = --(x + y)
val REAL_SUB_RNEG : thm = |- !x y. x - --y = x + y
val REAL_SUB_NEG2 : thm = |- !x y. --x - --y = y - x
val REAL_SUB_TRIANGLE : thm = |- !a b c. a - b + b - c = a - c
val REAL_EQ_SUB_LADD : thm = |- !x y z. x = y - z <=> x + z = y
val REAL_EQ_SUB_RADD : thm = |- !x y z. x - y = z <=> x = z + y
val REAL_SUB_SUB2 : thm = |- !x y. x - (x - y) = y
val REAL_ADD_SUB2 : thm = |- !x y. x - (x + y) = --y
val REAL_EQ_IMP_LE : thm = |- !x y. x = y ==> x <= y
val REAL_POS_NZ : thm = |- !x. &0 < x ==> ~(x = &0)
val REAL_DIFFSQ : thm = |- !x y. (x + y) * (x - y) = x * x - y * y
val REAL_EQ_NEG2 : thm = |- !x y. --x = --y <=> x = y
val REAL_LT_NEG2 : thm = |- !x y. --x < --y <=> y < x
val REAL_SUB_LDISTRIB : thm = |- !x y z. x * (y - z) = x * y - x * z
val REAL_SUB_RDISTRIB : thm = |- !x y z. (x - y) * z = x * z - y * z
val REAL_ABS_ZERO : thm = |- !x. abs x = &0 <=> x = &0
val REAL_ABS_0 : thm = |- abs (&0) = &0
val REAL_ABS_1 : thm = |- abs (&1) = &1
val REAL_ABS_TRIANGLE : thm = |- !x y. abs (x + y) <= abs x + abs y
val REAL_ABS_TRIANGLE_LE : thm =
  |- !x y z. abs x + abs (y - x) <= z ==> abs y <= z
val REAL_ABS_TRIANGLE_LT : thm =
  |- !x y z. abs x + abs (y - x) < z ==> abs y < z
val REAL_ABS_POS : thm = |- !x. &0 <= abs x
val REAL_ABS_SUB : thm = |- !x y. abs (x - y) = abs (y - x)
val REAL_ABS_NZ : thm = |- !x. ~(x = &0) <=> &0 < abs x
val REAL_ABS_ABS : thm = |- !x. abs (abs x) = abs x
val REAL_ABS_LE : thm = |- !x. x <= abs x
val REAL_ABS_REFL : thm = |- !x. abs x = x <=> &0 <= x
val REAL_ABS_BETWEEN : thm =
  |- !x y d. &0 < d /\ x - d < y /\ y < x + d <=> abs (y - x) < d
val REAL_ABS_BOUND : thm = |- !x y d. abs (x - y) < d ==> y < x + d
val REAL_ABS_STILLNZ : thm = |- !x y. abs (x - y) < abs y ==> ~(x = &0)
val REAL_ABS_CASES : thm = |- !x. x = &0 \/ &0 < abs x
val REAL_ABS_BETWEEN1 : thm =
  |- !x y z. x < z /\ abs (y - x) < z - x ==> y < z
val REAL_ABS_SIGN : thm = |- !x y. abs (x - y) < y ==> &0 < x
val REAL_ABS_SIGN2 : thm = |- !x y. abs (x - y) < --y ==> x < &0
val REAL_ABS_CIRCLE : thm =
  |- !x y h. abs h < abs y - abs x ==> abs (x + h) < abs y
val REAL_SUB_ABS : thm = |- !x y. abs x - abs y <= abs (x - y)
val REAL_ABS_SUB_ABS : thm = |- !x y. abs (abs x - abs y) <= abs (x - y)
val REAL_ABS_BETWEEN2 : thm =
  |- !x0 x y0 y.
         x0 < y0 /\
         &2 * abs (x - x0) < y0 - x0 /\
         &2 * abs (y - y0) < y0 - x0
         ==> x < y
val REAL_ABS_BOUNDS : thm = |- !x k. abs x <= k <=> --k <= x /\ x <= k
val REAL_BOUNDS_LE : thm = |- !x k. --k <= x /\ x <= k <=> abs x <= k
val REAL_BOUNDS_LT : thm = |- !x k. --k < x /\ x < k <=> abs x < k
val REAL_MIN_MAX : thm = |- !x y. min x y = --max (--x) (--y)
val REAL_MAX_MIN : thm = |- !x y. max x y = --min (--x) (--y)
val REAL_MAX_MAX : thm = |- !x y. x <= max x y /\ y <= max x y
val REAL_MIN_MIN : thm = |- !x y. min x y <= x /\ min x y <= y
val REAL_MAX_SYM : thm = |- !x y. max x y = max y x
val REAL_MIN_SYM : thm = |- !x y. min x y = min y x
val REAL_LE_MAX : thm = |- !x y z. z <= max x y <=> z <= x \/ z <= y
val REAL_LE_MIN : thm = |- !x y z. z <= min x y <=> z <= x /\ z <= y
val REAL_LT_MAX : thm = |- !x y z. z < max x y <=> z < x \/ z < y
val REAL_LT_MIN : thm = |- !x y z. z < min x y <=> z < x /\ z < y
val REAL_MAX_LE : thm = |- !x y z. max x y <= z <=> x <= z /\ y <= z
val REAL_MIN_LE : thm = |- !x y z. min x y <= z <=> x <= z \/ y <= z
val REAL_MAX_LT : thm = |- !x y z. max x y < z <=> x < z /\ y < z
val REAL_MIN_LT : thm = |- !x y z. min x y < z <=> x < z \/ y < z
val REAL_MAX_ASSOC : thm = |- !x y z. max x (max y z) = max (max x y) z
val REAL_MIN_ASSOC : thm = |- !x y z. min x (min y z) = min (min x y) z
val REAL_MAX_ACI : thm =
  |- max x y = max y x /\
     max (max x y) z = max x (max y z) /\
     max x (max y z) = max y (max x z) /\
     max x x = x /\
     max x (max x y) = max x y
val REAL_MIN_ACI : thm =
  |- min x y = min y x /\
     min (min x y) z = min x (min y z) /\
     min x (min y z) = min y (min x z) /\
     min x x = x /\
     min x (min x y) = min x y
val REAL_ABS_MUL : thm = |- !x y. abs (x * y) = abs x * abs y
val REAL_POW_LE : thm = |- !x n. &0 <= x ==> &0 <= x pow n
val REAL_POW_LT : thm = |- !x n. &0 < x ==> &0 < x pow n
val REAL_ABS_POW : thm = |- !x n. abs (x pow n) = abs x pow n
val REAL_LE_LMUL : thm = |- !x y z. &0 <= x /\ y <= z ==> x * y <= x * z
val REAL_LE_RMUL : thm = |- !x y z. x <= y /\ &0 <= z ==> x * z <= y * z
val REAL_LT_LMUL : thm = |- !x y z. &0 < x /\ y < z ==> x * y < x * z
val REAL_LT_RMUL : thm = |- !x y z. x < y /\ &0 < z ==> x * z < y * z
val REAL_EQ_MUL_LCANCEL : thm = |- !x y z. x * y = x * z <=> x = &0 \/ y = z
val REAL_EQ_MUL_RCANCEL : thm = |- !x y z. x * z = y * z <=> x = y \/ z = &0
val REAL_MUL_LINV_UNIQ : thm = |- !x y. x * y = &1 ==> inv y = x
val REAL_MUL_RINV_UNIQ : thm = |- !x y. x * y = &1 ==> inv x = y
val REAL_INV_INV : thm = |- !x. inv (inv x) = x
val REAL_EQ_INV2 : thm = |- !x y. inv x = inv y <=> x = y
val REAL_INV_EQ_0 : thm = |- !x. inv x = &0 <=> x = &0
val REAL_LT_INV : thm = |- !x. &0 < x ==> &0 < inv x
val REAL_LT_INV_EQ : thm = |- !x. &0 < inv x <=> &0 < x
val REAL_INV_NEG : thm = |- !x. inv (--x) = --inv x
val REAL_LE_INV_EQ : thm = |- !x. &0 <= inv x <=> &0 <= x
val REAL_LE_INV : thm = |- !x. &0 <= x ==> &0 <= inv x
val REAL_MUL_RINV : thm = |- !x. ~(x = &0) ==> x * inv x = &1
val REAL_INV_1 : thm = |- inv (&1) = &1
val REAL_INV_EQ_1 : thm = |- !x. inv x = &1 <=> x = &1
val REAL_DIV_1 : thm = |- !x. x / &1 = x
val REAL_DIV_REFL : thm = |- !x. ~(x = &0) ==> x / x = &1
val REAL_DIV_RMUL : thm = |- !x y. ~(y = &0) ==> x / y * y = x
val REAL_DIV_LMUL : thm = |- !x y. ~(y = &0) ==> y * x / y = x
val REAL_ABS_INV : thm = |- !x. abs (inv x) = inv (abs x)
val REAL_ABS_DIV : thm = |- !x y. abs (x / y) = abs x / abs y
val REAL_INV_MUL : thm = |- !x y. inv (x * y) = inv x * inv y
val REAL_INV_DIV : thm = |- !x y. inv (x / y) = y / x
val REAL_POW_MUL : thm = |- !x y n. (x * y) pow n = x pow n * y pow n
val REAL_POW_INV : thm = |- !x n. inv x pow n = inv (x pow n)
val REAL_INV_POW : thm = |- !x n. inv (x pow n) = inv x pow n
val REAL_POW_DIV : thm = |- !x y n. (x / y) pow n = x pow n / y pow n
val REAL_DIV_EQ_0 : thm = |- !x y. x / y = &0 <=> x = &0 \/ y = &0
val REAL_POW_ADD : thm = |- !x m n. x pow (m + n) = x pow m * x pow n
val REAL_POW_NZ : thm = |- !x n. ~(x = &0) ==> ~(x pow n = &0)
val REAL_POW_SUB : thm =
  |- !x m n. ~(x = &0) /\ m <= n ==> x pow (n - m) = x pow n / x pow m
val REAL_LT_IMP_NZ : thm = |- !x. &0 < x ==> ~(x = &0)
val REAL_LT_LCANCEL_IMP : thm = |- !x y z. &0 < x /\ x * y < x * z ==> y < z
val REAL_LT_RCANCEL_IMP : thm = |- !x y z. &0 < z /\ x * z < y * z ==> x < y
val REAL_LE_LCANCEL_IMP : thm =
  |- !x y z. &0 < x /\ x * y <= x * z ==> y <= z
val REAL_LE_RCANCEL_IMP : thm =
  |- !x y z. &0 < z /\ x * z <= y * z ==> x <= y
val REAL_LE_RMUL_EQ : thm = |- !x y z. &0 < z ==> (x * z <= y * z <=> x <= y)
val REAL_LE_LMUL_EQ : thm = |- !x y z. &0 < z ==> (z * x <= z * y <=> x <= y)
val REAL_LT_RMUL_EQ : thm = |- !x y z. &0 < z ==> (x * z < y * z <=> x < y)
val REAL_LT_LMUL_EQ : thm = |- !x y z. &0 < z ==> (z * x < z * y <=> x < y)
val REAL_LE_MUL_EQ : thm =
  |- (!x y. &0 < x ==> (&0 <= x * y <=> &0 <= y)) /\
     (!x y. &0 < y ==> (&0 <= x * y <=> &0 <= x))
val REAL_LT_MUL_EQ : thm =
  |- (!x y. &0 < x ==> (&0 < x * y <=> &0 < y)) /\
     (!x y. &0 < y ==> (&0 < x * y <=> &0 < x))
val REAL_MUL_POS_LT : thm =
  |- !x y. &0 < x * y <=> &0 < x /\ &0 < y \/ x < &0 /\ y < &0
val REAL_MUL_POS_LE : thm =
  |- !x y.
         &0 <= x * y <=>
         x = &0 \/ y = &0 \/ &0 < x /\ &0 < y \/ x < &0 /\ y < &0
val REAL_LE_RDIV_EQ : thm = |- !x y z. &0 < z ==> (x <= y / z <=> x * z <= y)
val REAL_LE_LDIV_EQ : thm = |- !x y z. &0 < z ==> (x / z <= y <=> x <= y * z)
val REAL_LT_RDIV_EQ : thm = |- !x y z. &0 < z ==> (x < y / z <=> x * z < y)
val REAL_LT_LDIV_EQ : thm = |- !x y z. &0 < z ==> (x / z < y <=> x < y * z)
val REAL_EQ_RDIV_EQ : thm = |- !x y z. &0 < z ==> (x = y / z <=> x * z = y)
val REAL_EQ_LDIV_EQ : thm = |- !x y z. &0 < z ==> (x / z = y <=> x = y * z)
val REAL_LT_DIV2_EQ : thm = |- !x y z. &0 < z ==> (x / z < y / z <=> x < y)
val REAL_LE_DIV2_EQ : thm = |- !x y z. &0 < z ==> (x / z <= y / z <=> x <= y)
val REAL_MUL_2 : thm = |- !x. &2 * x = x + x
val REAL_POW_EQ_0 : thm = |- !x n. x pow n = &0 <=> x = &0 /\ ~(n = 0)
val REAL_LE_MUL2 : thm =
  |- !w x y z. &0 <= w /\ w <= x /\ &0 <= y /\ y <= z ==> w * y <= x * z
val REAL_LT_MUL2 : thm =
  |- !w x y z. &0 <= w /\ w < x /\ &0 <= y /\ y < z ==> w * y < x * z
val REAL_LT_SQUARE : thm = |- !x. &0 < x * x <=> ~(x = &0)
val REAL_POW_1 : thm = |- !x. x pow 1 = x
val REAL_POW_ONE : thm = |- !n. &1 pow n = &1
val REAL_LT_INV2 : thm = |- !x y. &0 < x /\ x < y ==> inv y < inv x
val REAL_LE_INV2 : thm = |- !x y. &0 < x /\ x <= y ==> inv y <= inv x
val REAL_LT_LINV : thm = |- !x y. &0 < y /\ inv y < x ==> inv x < y
val REAL_LT_RINV : thm = |- !x y. &0 < x /\ x < inv y ==> y < inv x
val REAL_LE_LINV : thm = |- !x y. &0 < y /\ inv y <= x ==> inv x <= y
val REAL_LE_RINV : thm = |- !x y. &0 < x /\ x <= inv y ==> y <= inv x
val REAL_INV_LE_1 : thm = |- !x. &1 <= x ==> inv x <= &1
val REAL_INV_1_LE : thm = |- !x. &0 < x /\ x <= &1 ==> &1 <= inv x
val REAL_INV_LT_1 : thm = |- !x. &1 < x ==> inv x < &1
val REAL_INV_1_LT : thm = |- !x. &0 < x /\ x < &1 ==> &1 < inv x
val REAL_SUB_INV : thm =
  |- !x y. ~(x = &0) /\ ~(y = &0) ==> inv x - inv y = (y - x) / (x * y)
val REAL_DOWN : thm = |- !d. &0 < d ==> (?e. &0 < e /\ e < d)
val REAL_DOWN2 : thm =
  |- !d1 d2. &0 < d1 /\ &0 < d2 ==> (?e. &0 < e /\ e < d1 /\ e < d2)
val REAL_POW_LE2 : thm = |- !n x y. &0 <= x /\ x <= y ==> x pow n <= y pow n
val REAL_POW_LE_1 : thm = |- !n x. &1 <= x ==> &1 <= x pow n
val REAL_POW_1_LE : thm = |- !n x. &0 <= x /\ x <= &1 ==> x pow n <= &1
val REAL_POW_MONO : thm = |- !m n x. &1 <= x /\ m <= n ==> x pow m <= x pow n
val REAL_POW_LT2 : thm =
  |- !n x y. ~(n = 0) /\ &0 <= x /\ x < y ==> x pow n < y pow n
val REAL_POW_LT_1 : thm = |- !n x. ~(n = 0) /\ &1 < x ==> &1 < x pow n
val REAL_POW_1_LT : thm =
  |- !n x. ~(n = 0) /\ &0 <= x /\ x < &1 ==> x pow n < &1
val REAL_POW_MONO_LT : thm = |- !m n x. &1 < x /\ m < n ==> x pow m < x pow n
val REAL_POW_POW : thm = |- !x m n. x pow m pow n = x pow (m * n)
val REAL_EQ_RCANCEL_IMP : thm =
  |- !x y z. ~(z = &0) /\ x * z = y * z ==> x = y
val REAL_EQ_LCANCEL_IMP : thm =
  |- !x y z. ~(z = &0) /\ z * x = z * y ==> x = y
val REAL_LT_DIV : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x / y
val REAL_LE_DIV : thm = |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x / y
val REAL_DIV_POW2 : thm =
  |- !x m n.
         ~(x = &0)
         ==> x pow m / x pow n =
             (if n <= m then x pow (m - n) else inv (x pow (n - m)))
val REAL_DIV_POW2_ALT : thm =
  |- !x m n.
         ~(x = &0)
         ==> x pow m / x pow n =
             (if n < m then x pow (m - n) else inv (x pow (n - m)))
val REAL_LT_POW2 : thm = |- !n. &0 < &2 pow n
val REAL_LE_POW2 : thm = |- !n. &1 <= &2 pow n
val REAL_POW2_ABS : thm = |- !x. abs x pow 2 = x pow 2
val REAL_LE_SQUARE_ABS : thm = |- !x y. abs x <= abs y <=> x pow 2 <= y pow 2
val REAL_LT_SQUARE_ABS : thm = |- !x y. abs x < abs y <=> x pow 2 < y pow 2
val REAL_EQ_SQUARE_ABS : thm = |- !x y. abs x = abs y <=> x pow 2 = y pow 2
val REAL_LE_POW_2 : thm = |- !x. &0 <= x pow 2
val REAL_LT_POW_2 : thm = |- !x. &0 < x pow 2 <=> ~(x = &0)
val REAL_SOS_EQ_0 : thm =
  |- !x y. x pow 2 + y pow 2 = &0 <=> x = &0 /\ y = &0
val REAL_POW_ZERO : thm = |- !n. &0 pow n = (if n = 0 then &1 else &0)
val REAL_POW_MONO_INV : thm =
  |- !m n x. &0 <= x /\ x <= &1 /\ n <= m ==> x pow m <= x pow n
val REAL_POW_LE2_REV : thm =
  |- !n x y. ~(n = 0) /\ &0 <= y /\ x pow n <= y pow n ==> x <= y
val REAL_POW_LT2_REV : thm =
  |- !n x y. &0 <= y /\ x pow n < y pow n ==> x < y
val REAL_POW_EQ : thm =
  |- !n x y. ~(n = 0) /\ &0 <= x /\ &0 <= y /\ x pow n = y pow n ==> x = y
val REAL_POW_EQ_ABS : thm =
  |- !n x y. ~(n = 0) /\ x pow n = y pow n ==> abs x = abs y
val REAL_POW_EQ_1_IMP : thm =
  |- !x n. ~(n = 0) /\ x pow n = &1 ==> abs x = &1
val REAL_POW_EQ_1 : thm =
  |- !x n. x pow n = &1 <=> abs x = &1 /\ (x < &0 ==> EVEN n) \/ n = 0
val REAL_POW_LT2_ODD : thm = |- !n x y. x < y /\ ODD n ==> x pow n < y pow n
val REAL_POW_LE2_ODD : thm =
  |- !n x y. x <= y /\ ODD n ==> x pow n <= y pow n
val REAL_POW_LT2_ODD_EQ : thm =
  |- !n x y. ODD n ==> (x pow n < y pow n <=> x < y)
val REAL_POW_LE2_ODD_EQ : thm =
  |- !n x y. ODD n ==> (x pow n <= y pow n <=> x <= y)
val REAL_POW_EQ_ODD_EQ : thm =
  |- !n x y. ODD n ==> (x pow n = y pow n <=> x = y)
val REAL_POW_EQ_ODD : thm = |- !n x y. ODD n /\ x pow n = y pow n ==> x = y
val REAL_POW_EQ_EQ : thm =
  |- !n x y.
         x pow n = y pow n <=>
         (if EVEN n then n = 0 \/ abs x = abs y else x = y)
val REAL_ARCH_SIMPLE : thm = |- !x. ?n. x <= &n
val REAL_ARCH_LT : thm = |- !x. ?n. x < &n
val REAL_ARCH : thm = |- !x. &0 < x ==> (!y. ?n. y < &n * x)
val real_sgn : thm =
  |- !x. real_sgn x = (if &0 < x then &1 else if x < &0 then -- &1 else &0)
val REAL_SGN_0 : thm = |- real_sgn (&0) = &0
val REAL_SGN_NEG : thm = |- !x. real_sgn (--x) = --real_sgn x
val REAL_SGN_ABS : thm = |- !x. real_sgn x * abs x = x
val REAL_EQ_SGN_ABS : thm =
  |- !x y. x = y <=> real_sgn x = real_sgn y /\ abs x = abs y
val REAL_ABS_SGN : thm = |- !x. abs (real_sgn x) = real_sgn (abs x)
val REAL_SGN : thm = |- !x. real_sgn x = x / abs x
val REAL_SGN_MUL : thm = |- !x y. real_sgn (x * y) = real_sgn x * real_sgn y
val REAL_SGN_INV : thm = |- !x. real_sgn (inv x) = real_sgn x
val REAL_SGN_DIV : thm = |- !x y. real_sgn (x / y) = real_sgn x / real_sgn y
val REAL_SGN_EQ : thm =
  |- (!x. real_sgn x = &0 <=> x = &0) /\
     (!x. real_sgn x = &1 <=> x > &0) /\
     (!x. real_sgn x = -- &1 <=> x < &0)
val REAL_SGN_CASES : thm =
  |- !x. real_sgn x = &0 \/ real_sgn x = &1 \/ real_sgn x = -- &1
val REAL_SGN_INEQS : thm =
  |- (!x. &0 <= real_sgn x <=> &0 <= x) /\
     (!x. &0 < real_sgn x <=> &0 < x) /\
     (!x. &0 >= real_sgn x <=> &0 >= x) /\
     (!x. &0 > real_sgn x <=> &0 > x) /\
     (!x. &0 = real_sgn x <=> &0 = x) /\
     (!x. real_sgn x <= &0 <=> x <= &0) /\
     (!x. real_sgn x < &0 <=> x < &0) /\
     (!x. real_sgn x >= &0 <=> x >= &0) /\
     (!x. real_sgn x > &0 <=> x > &0) /\
     (!x. real_sgn x = &0 <=> x = &0)
val REAL_SGN_POW : thm = |- !x n. real_sgn (x pow n) = real_sgn x pow n
val REAL_SGN_POW_2 : thm = |- !x. real_sgn (x pow 2) = real_sgn (abs x)
val REAL_SGN_REAL_SGN : thm = |- !x. real_sgn (real_sgn x) = real_sgn x
val REAL_INV_SGN : thm = |- !x. inv (real_sgn x) = real_sgn x
val REAL_WLOG_LE : thm =
  |- (!x y. P x y <=> P y x) /\ (!x y. x <= y ==> P x y) ==> (!x y. P x y)
val REAL_WLOG_LT : thm =
  |- (!x. P x x) /\ (!x y. P x y <=> P y x) /\ (!x y. x < y ==> P x y)
     ==> (!x y. P x y)
val DECIMAL : thm = |- !x y. DECIMAL x y = &x / &y
val RAT_LEMMA1 : thm =
  |- ~(y1 = &0) /\ ~(y2 = &0)
     ==> x1 / y1 + x2 / y2 = (x1 * y2 + x2 * y1) * inv y1 * inv y2
val RAT_LEMMA2 : thm =
  |- &0 < y1 /\ &0 < y2
     ==> x1 / y1 + x2 / y2 = (x1 * y2 + x2 * y1) * inv y1 * inv y2
val RAT_LEMMA3 : thm =
  |- &0 < y1 /\ &0 < y2
     ==> x1 / y1 - x2 / y2 = (x1 * y2 - x2 * y1) * inv y1 * inv y2
val RAT_LEMMA4 : thm =
  |- &0 < y1 /\ &0 < y2 ==> (x1 / y1 <= x2 / y2 <=> x1 * y2 <= x2 * y1)
val RAT_LEMMA5 : thm =
  |- &0 < y1 /\ &0 < y2 ==> (x1 / y1 = x2 / y2 <=> x1 * y2 = x2 * y1)
  ((thm list * thm list * thm list -> positivstellensatz -> thm) ->
   thm list * thm list * thm list -> thm) ->
  term -> thm = <fun>
val integer : thm = |- !x. integer x <=> (?n. abs x = &n)
val is_int : thm = |- integer x <=> (?n. x = &n \/ x = -- &n)
val int_tybij : thm =
  |- (!a. int_of_real (real_of_int a) = a) /\
     (!r. integer r <=> real_of_int (int_of_real r) = r)
val int_abstr : thm = |- int_of_real (real_of_int a) = a
val int_rep : thm = |- integer r <=> real_of_int (int_of_real r) = r
val dest_int_rep : thm =
  |- !i. ?n. real_of_int i = &n \/ real_of_int i = -- &n
val int_eq : thm = |- !x y. x = y <=> real_of_int x = real_of_int y
val int_le : thm = |- !x y. x <= y <=> real_of_int x <= real_of_int y
val int_lt : thm = |- !x y. x < y <=> real_of_int x < real_of_int y
val int_ge : thm = |- !x y. x >= y <=> real_of_int x >= real_of_int y
val int_gt : thm = |- !x y. x > y <=> real_of_int x > real_of_int y
val int_of_num : thm = |- !n. &n = int_of_real (&n)
val int_of_num_th : thm = |- !n. real_of_int (&n) = &n
val int_neg : thm = |- !i. --i = int_of_real (--real_of_int i)
val int_neg_th : thm = |- !x. real_of_int (--x) = --real_of_int x
val int_add : thm =
  |- !x y. x + y = int_of_real (real_of_int x + real_of_int y)
val int_add_th : thm =
  |- !x y. real_of_int (x + y) = real_of_int x + real_of_int y
val int_sub : thm =
  |- !x y. x - y = int_of_real (real_of_int x - real_of_int y)
val int_sub_th : thm =
  |- !x y. real_of_int (x - y) = real_of_int x - real_of_int y
val int_mul : thm =
  |- !x y. x * y = int_of_real (real_of_int x * real_of_int y)
val int_mul_th : thm =
  |- !x y. real_of_int (x * y) = real_of_int x * real_of_int y
val int_abs : thm = |- !x. abs x = int_of_real (abs (real_of_int x))
val int_abs_th : thm = |- !x. real_of_int (abs x) = abs (real_of_int x)
val int_sgn : thm = |- !x. int_sgn x = int_of_real (real_sgn (real_of_int x))
val int_sgn_th : thm =
  |- !x. real_of_int (int_sgn x) = real_sgn (real_of_int x)
val int_max : thm =
  |- !x y. max x y = int_of_real (max (real_of_int x) (real_of_int y))
val int_max_th : thm =
  |- !x y. real_of_int (max x y) = max (real_of_int x) (real_of_int y)
val int_min : thm =
  |- !x y. min x y = int_of_real (min (real_of_int x) (real_of_int y))
val int_min_th : thm =
  |- !x y. real_of_int (min x y) = min (real_of_int x) (real_of_int y)
val int_pow : thm = |- !x n. x pow n = int_of_real (real_of_int x pow n)
val int_pow_th : thm = |- !x n. real_of_int (x pow n) = real_of_int x pow n
val INT_IMAGE : thm = |- !x. (?n. x = &n) \/ (?n. x = -- &n)
val INT_LT_DISCRETE : thm = |- !x y. x < y <=> x + &1 <= y
val INT_GT_DISCRETE : thm = |- !x y. x > y <=> x >= y + &1
val INT_ABS_0 : thm = |- abs (&0) = &0
val INT_ABS_1 : thm = |- abs (&1) = &1
val INT_ABS_ABS : thm = |- !x. abs (abs x) = abs x
val INT_ABS_BETWEEN : thm =
  |- !x y d. &0 < d /\ x - d < y /\ y < x + d <=> abs (y - x) < d
val INT_ABS_BETWEEN1 : thm =
  |- !x y z. x < z /\ abs (y - x) < z - x ==> y < z
val INT_ABS_BETWEEN2 : thm =
  |- !x0 x y0 y.
         x0 < y0 /\
         &2 * abs (x - x0) < y0 - x0 /\
         &2 * abs (y - y0) < y0 - x0
         ==> x < y
val INT_ABS_BOUND : thm = |- !x y d. abs (x - y) < d ==> y < x + d
val INT_ABS_CASES : thm = |- !x. x = &0 \/ &0 < abs x
val INT_ABS_CIRCLE : thm =
  |- !x y h. abs h < abs y - abs x ==> abs (x + h) < abs y
val INT_ABS_LE : thm = |- !x. x <= abs x
val INT_ABS_MUL : thm = |- !x y. abs (x * y) = abs x * abs y
val INT_ABS_NEG : thm = |- !x. abs (--x) = abs x
val INT_ABS_NUM : thm = |- !n. abs (&n) = &n
val INT_ABS_NZ : thm = |- !x. ~(x = &0) <=> &0 < abs x
val INT_ABS_POS : thm = |- !x. &0 <= abs x
val INT_ABS_POW : thm = |- !x n. abs (x pow n) = abs x pow n
val INT_ABS_REFL : thm = |- !x. abs x = x <=> &0 <= x
val INT_ABS_SGN : thm = |- !x. abs (int_sgn x) = int_sgn (abs x)
val INT_ABS_SIGN : thm = |- !x y. abs (x - y) < y ==> &0 < x
val INT_ABS_SIGN2 : thm = |- !x y. abs (x - y) < --y ==> x < &0
val INT_ABS_STILLNZ : thm = |- !x y. abs (x - y) < abs y ==> ~(x = &0)
val INT_ABS_SUB : thm = |- !x y. abs (x - y) = abs (y - x)
val INT_ABS_SUB_ABS : thm = |- !x y. abs (abs x - abs y) <= abs (x - y)
val INT_ABS_TRIANGLE : thm = |- !x y. abs (x + y) <= abs x + abs y
val INT_ABS_ZERO : thm = |- !x. abs x = &0 <=> x = &0
val INT_ADD2_SUB2 : thm = |- !a b c d. (a + b) - (c + d) = a - c + b - d
val INT_ADD_AC : thm =
  |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
val INT_ADD_ASSOC : thm = |- !x y z. x + y + z = (x + y) + z
val INT_ADD_LDISTRIB : thm = |- !x y z. x * (y + z) = x * y + x * z
val INT_ADD_LID : thm = |- !x. &0 + x = x
val INT_ADD_LINV : thm = |- !x. --x + x = &0
val INT_ADD_RDISTRIB : thm = |- !x y z. (x + y) * z = x * z + y * z
val INT_ADD_RID : thm = |- !x. x + &0 = x
val INT_ADD_RINV : thm = |- !x. x + --x = &0
val INT_ADD_SUB : thm = |- !x y. (x + y) - x = y
val INT_ADD_SUB2 : thm = |- !x y. x - (x + y) = --y
val INT_ADD_SYM : thm = |- !x y. x + y = y + x
val INT_BOUNDS_LE : thm = |- !x k. --k <= x /\ x <= k <=> abs x <= k
val INT_BOUNDS_LT : thm = |- !x k. --k < x /\ x < k <=> abs x < k
val INT_DIFFSQ : thm = |- !x y. (x + y) * (x - y) = x * x - y * y
val INT_ENTIRE : thm = |- !x y. x * y = &0 <=> x = &0 \/ y = &0
val INT_EQ_ADD_LCANCEL : thm = |- !x y z. x + y = x + z <=> y = z
val INT_EQ_ADD_LCANCEL_0 : thm = |- !x y. x + y = x <=> y = &0
val INT_EQ_ADD_RCANCEL : thm = |- !x y z. x + z = y + z <=> x = y
val INT_EQ_ADD_RCANCEL_0 : thm = |- !x y. x + y = y <=> x = &0
val INT_EQ_IMP_LE : thm = |- !x y. x = y ==> x <= y
val INT_EQ_MUL_LCANCEL : thm = |- !x y z. x * y = x * z <=> x = &0 \/ y = z
val INT_EQ_MUL_RCANCEL : thm = |- !x y z. x * z = y * z <=> x = y \/ z = &0
val INT_EQ_NEG2 : thm = |- !x y. --x = --y <=> x = y
val INT_EQ_SGN_ABS : thm =
  |- !x y. x = y <=> int_sgn x = int_sgn y /\ abs x = abs y
val INT_EQ_SQUARE_ABS : thm = |- !x y. abs x = abs y <=> x pow 2 = y pow 2
val INT_EQ_SUB_LADD : thm = |- !x y z. x = y - z <=> x + z = y
val INT_EQ_SUB_RADD : thm = |- !x y z. x - y = z <=> x = z + y
val INT_LET_ADD : thm = |- !x y. &0 <= x /\ &0 < y ==> &0 < x + y
val INT_LET_ADD2 : thm = |- !w x y z. w <= x /\ y < z ==> w + y < x + z
val INT_LET_ANTISYM : thm = |- !x y. ~(x <= y /\ y < x)
val INT_LET_TOTAL : thm = |- !x y. x <= y \/ y < x
val INT_LET_TRANS : thm = |- !x y z. x <= y /\ y < z ==> x < z
val INT_LE_01 : thm = |- &0 <= &1
val INT_LE_ADD : thm = |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x + y
val INT_LE_ADD2 : thm = |- !w x y z. w <= x /\ y <= z ==> w + y <= x + z
val INT_LE_ADDL : thm = |- !x y. y <= x + y <=> &0 <= x
val INT_LE_ADDR : thm = |- !x y. x <= x + y <=> &0 <= y
val INT_LE_ANTISYM : thm = |- !x y. x <= y /\ y <= x <=> x = y
val INT_LE_DOUBLE : thm = |- !x. &0 <= x + x <=> &0 <= x
val INT_LE_LADD : thm = |- !x y z. x + y <= x + z <=> y <= z
val INT_LE_LADD_IMP : thm = |- !x y z. y <= z ==> x + y <= x + z
val INT_LE_LMUL : thm = |- !x y z. &0 <= x /\ y <= z ==> x * y <= x * z
val INT_LE_LNEG : thm = |- !x y. --x <= y <=> &0 <= x + y
val INT_LE_LT : thm = |- !x y. x <= y <=> x < y \/ x = y
val INT_LE_MAX : thm = |- !x y z. z <= max x y <=> z <= x \/ z <= y
val INT_LE_MIN : thm = |- !x y z. z <= min x y <=> z <= x /\ z <= y
val INT_LE_MUL : thm = |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x * y
val INT_LE_MUL_EQ : thm =
  |- (!x y. &0 < x ==> (&0 <= x * y <=> &0 <= y)) /\
     (!x y. &0 < y ==> (&0 <= x * y <=> &0 <= x))
val INT_LE_NEG : thm = |- !x y. --x <= --y <=> y <= x
val INT_LE_NEG2 : thm = |- !x y. --x <= --y <=> y <= x
val INT_LE_NEGL : thm = |- !x. --x <= x <=> &0 <= x
val INT_LE_NEGR : thm = |- !x. x <= --x <=> x <= &0
val INT_LE_NEGTOTAL : thm = |- !x. &0 <= x \/ &0 <= --x
val INT_LE_POW2 : thm = |- !n. &1 <= &2 pow n
val INT_LE_RADD : thm = |- !x y z. x + z <= y + z <=> x <= y
val INT_LE_REFL : thm = |- !x. x <= x
val INT_LE_RMUL : thm = |- !x y z. x <= y /\ &0 <= z ==> x * z <= y * z
val INT_LE_RNEG : thm = |- !x y. x <= --y <=> x + y <= &0
val INT_LE_SQUARE : thm = |- !x. &0 <= x * x
val INT_LE_SQUARE_ABS : thm = |- !x y. abs x <= abs y <=> x pow 2 <= y pow 2
val INT_LE_SUB_LADD : thm = |- !x y z. x <= y - z <=> x + z <= y
val INT_LE_SUB_RADD : thm = |- !x y z. x - y <= z <=> x <= z + y
val INT_LE_TOTAL : thm = |- !x y. x <= y \/ y <= x
val INT_LE_TRANS : thm = |- !x y z. x <= y /\ y <= z ==> x <= z
val INT_LNEG_UNIQ : thm = |- !x y. x + y = &0 <=> x = --y
val INT_LTE_ADD : thm = |- !x y. &0 < x /\ &0 <= y ==> &0 < x + y
val INT_LTE_ADD2 : thm = |- !w x y z. w < x /\ y <= z ==> w + y < x + z
val INT_LTE_ANTISYM : thm = |- !x y. ~(x < y /\ y <= x)
val INT_LTE_TOTAL : thm = |- !x y. x < y \/ y <= x
val INT_LTE_TRANS : thm = |- !x y z. x < y /\ y <= z ==> x < z
val INT_LT_01 : thm = |- &0 < &1
val INT_LT_ADD : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x + y
val INT_LT_ADD1 : thm = |- !x y. x <= y ==> x < y + &1
val INT_LT_ADD2 : thm = |- !w x y z. w < x /\ y < z ==> w + y < x + z
val INT_LT_ADDL : thm = |- !x y. y < x + y <=> &0 < x
val INT_LT_ADDNEG : thm = |- !x y z. y < x + --z <=> y + z < x
val INT_LT_ADDNEG2 : thm = |- !x y z. x + --y < z <=> x < z + y
val INT_LT_ADDR : thm = |- !x y. x < x + y <=> &0 < y
val INT_LT_ADD_SUB : thm = |- !x y z. x + y < z <=> x < z - y
val INT_LT_ANTISYM : thm = |- !x y. ~(x < y /\ y < x)
val INT_LT_GT : thm = |- !x y. x < y ==> ~(y < x)
val INT_LT_IMP_LE : thm = |- !x y. x < y ==> x <= y
val INT_LT_IMP_NE : thm = |- !x y. x < y ==> ~(x = y)
val INT_LT_LADD : thm = |- !x y z. x + y < x + z <=> y < z
val INT_LT_LE : thm = |- !x y. x < y <=> x <= y /\ ~(x = y)
val INT_LT_LMUL_EQ : thm = |- !x y z. &0 < z ==> (z * x < z * y <=> x < y)
val INT_LT_MAX : thm = |- !x y z. z < max x y <=> z < x \/ z < y
val INT_LT_MIN : thm = |- !x y z. z < min x y <=> z < x /\ z < y
val INT_LT_MUL : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x * y
val INT_LT_MUL_EQ : thm =
  |- (!x y. &0 < x ==> (&0 < x * y <=> &0 < y)) /\
     (!x y. &0 < y ==> (&0 < x * y <=> &0 < x))
val INT_LT_NEG : thm = |- !x y. --x < --y <=> y < x
val INT_LT_NEG2 : thm = |- !x y. --x < --y <=> y < x
val INT_LT_NEGTOTAL : thm = |- !x. x = &0 \/ &0 < x \/ &0 < --x
val INT_LT_POW2 : thm = |- !n. &0 < &2 pow n
val INT_LT_RADD : thm = |- !x y z. x + z < y + z <=> x < y
val INT_LT_REFL : thm = |- !x. ~(x < x)
val INT_LT_RMUL_EQ : thm = |- !x y z. &0 < z ==> (x * z < y * z <=> x < y)
val INT_LT_SQUARE_ABS : thm = |- !x y. abs x < abs y <=> x pow 2 < y pow 2
val INT_LT_SUB_LADD : thm = |- !x y z. x < y - z <=> x + z < y
val INT_LT_SUB_RADD : thm = |- !x y z. x - y < z <=> x < z + y
val INT_LT_TOTAL : thm = |- !x y. x = y \/ x < y \/ y < x
val INT_LT_TRANS : thm = |- !x y z. x < y /\ y < z ==> x < z
val INT_MAX_ACI : thm =
  |- max x y = max y x /\
     max (max x y) z = max x (max y z) /\
     max x (max y z) = max y (max x z) /\
     max x x = x /\
     max x (max x y) = max x y
val INT_MAX_ASSOC : thm = |- !x y z. max x (max y z) = max (max x y) z
val INT_MAX_LE : thm = |- !x y z. max x y <= z <=> x <= z /\ y <= z
val INT_MAX_LT : thm = |- !x y z. max x y < z <=> x < z /\ y < z
val INT_MAX_MAX : thm = |- !x y. x <= max x y /\ y <= max x y
val INT_MAX_MIN : thm = |- !x y. max x y = --min (--x) (--y)
val INT_MAX_SYM : thm = |- !x y. max x y = max y x
val INT_MIN_ACI : thm =
  |- min x y = min y x /\
     min (min x y) z = min x (min y z) /\
     min x (min y z) = min y (min x z) /\
     min x x = x /\
     min x (min x y) = min x y
val INT_MIN_ASSOC : thm = |- !x y z. min x (min y z) = min (min x y) z
val INT_MIN_LE : thm = |- !x y z. min x y <= z <=> x <= z \/ y <= z
val INT_MIN_LT : thm = |- !x y z. min x y < z <=> x < z \/ y < z
val INT_MIN_MAX : thm = |- !x y. min x y = --max (--x) (--y)
val INT_MIN_MIN : thm = |- !x y. min x y <= x /\ min x y <= y
val INT_MIN_SYM : thm = |- !x y. min x y = min y x
val INT_MUL_AC : thm =
  |- m * n = n * m /\ (m * n) * p = m * n * p /\ m * n * p = n * m * p
val INT_MUL_ASSOC : thm = |- !x y z. x * y * z = (x * y) * z
val INT_MUL_LID : thm = |- !x. &1 * x = x
val INT_MUL_LNEG : thm = |- !x y. --x * y = --(x * y)
val INT_MUL_LZERO : thm = |- !x. &0 * x = &0
val INT_MUL_POS_LE : thm =
  |- !x y.
         &0 <= x * y <=>
         x = &0 \/ y = &0 \/ &0 < x /\ &0 < y \/ x < &0 /\ y < &0
val INT_MUL_POS_LT : thm =
  |- !x y. &0 < x * y <=> &0 < x /\ &0 < y \/ x < &0 /\ y < &0
val INT_MUL_RID : thm = |- !x. x * &1 = x
val INT_MUL_RNEG : thm = |- !x y. x * --y = --(x * y)
val INT_MUL_RZERO : thm = |- !x. x * &0 = &0
val INT_MUL_SYM : thm = |- !x y. x * y = y * x
val INT_NEGNEG : thm = |- !x. -- --x = x
val INT_NEG_0 : thm = |- -- &0 = &0
val INT_NEG_ADD : thm = |- !x y. --(x + y) = --x + --y
val INT_NEG_EQ : thm = |- !x y. --x = y <=> x = --y
val INT_NEG_EQ_0 : thm = |- !x. --x = &0 <=> x = &0
val INT_NEG_GE0 : thm = |- !x. &0 <= --x <=> x <= &0
val INT_NEG_GT0 : thm = |- !x. &0 < --x <=> x < &0
val INT_NEG_LE0 : thm = |- !x. --x <= &0 <=> &0 <= x
val INT_NEG_LMUL : thm = |- !x y. --(x * y) = --x * y
val INT_NEG_LT0 : thm = |- !x. --x < &0 <=> &0 < x
val INT_NEG_MINUS1 : thm = |- !x. --x = -- &1 * x
val INT_NEG_MUL2 : thm = |- !x y. --x * --y = x * y
val INT_NEG_NEG : thm = |- !x. -- --x = x
val INT_NEG_RMUL : thm = |- !x y. --(x * y) = x * --y
val INT_NEG_SUB : thm = |- !x y. --(x - y) = y - x
val INT_NOT_EQ : thm = |- !x y. ~(x = y) <=> x < y \/ y < x
val INT_NOT_LE : thm = |- !x y. ~(x <= y) <=> y < x
val INT_NOT_LT : thm = |- !x y. ~(x < y) <=> y <= x
val INT_OF_NUM_ADD : thm = |- !m n. &m + &n = &(m + n)
val INT_OF_NUM_EQ : thm = |- !m n. &m = &n <=> m = n
val INT_OF_NUM_GE : thm = |- !m n. &m >= &n <=> m >= n
val INT_OF_NUM_GT : thm = |- !m n. &m > &n <=> m > n
val INT_OF_NUM_LE : thm = |- !m n. &m <= &n <=> m <= n
val INT_OF_NUM_LT : thm = |- !m n. &m < &n <=> m < n
val INT_OF_NUM_MAX : thm = |- !m n. max (&m) (&n) = &(MAX m n)
val INT_OF_NUM_MIN : thm = |- !m n. min (&m) (&n) = &(MIN m n)
val INT_OF_NUM_MUL : thm = |- !m n. &m * &n = &(m * n)
val INT_OF_NUM_POW : thm = |- !x n. &x pow n = &(x EXP n)
val INT_OF_NUM_SUB : thm = |- !m n. m <= n ==> &n - &m = &(n - m)
val INT_OF_NUM_SUC : thm = |- !n. &n + &1 = &(SUC n)
val INT_POS : thm = |- !n. &0 <= &n
val INT_POS_NZ : thm = |- !x. &0 < x ==> ~(x = &0)
val INT_POW2_ABS : thm = |- !x. abs x pow 2 = x pow 2
val INT_POW_1 : thm = |- !x. x pow 1 = x
val INT_POW_1_LE : thm = |- !n x. &0 <= x /\ x <= &1 ==> x pow n <= &1
val INT_POW_1_LT : thm =
  |- !n x. ~(n = 0) /\ &0 <= x /\ x < &1 ==> x pow n < &1
val INT_POW_2 : thm = |- !x. x pow 2 = x * x
val INT_POW_ADD : thm = |- !x m n. x pow (m + n) = x pow m * x pow n
val INT_POW_EQ : thm =
  |- !n x y. ~(n = 0) /\ &0 <= x /\ &0 <= y /\ x pow n = y pow n ==> x = y
val INT_POW_EQ_0 : thm = |- !x n. x pow n = &0 <=> x = &0 /\ ~(n = 0)
val INT_POW_EQ_ABS : thm =
  |- !n x y. ~(n = 0) /\ x pow n = y pow n ==> abs x = abs y
val INT_POW_LE : thm = |- !x n. &0 <= x ==> &0 <= x pow n
val INT_POW_LE2 : thm = |- !n x y. &0 <= x /\ x <= y ==> x pow n <= y pow n
val INT_POW_LE2_ODD : thm = |- !n x y. x <= y /\ ODD n ==> x pow n <= y pow n
val INT_POW_LE2_REV : thm =
  |- !n x y. ~(n = 0) /\ &0 <= y /\ x pow n <= y pow n ==> x <= y
val INT_POW_LE_1 : thm = |- !n x. &1 <= x ==> &1 <= x pow n
val INT_POW_LT : thm = |- !x n. &0 < x ==> &0 < x pow n
val INT_POW_LT2 : thm =
  |- !n x y. ~(n = 0) /\ &0 <= x /\ x < y ==> x pow n < y pow n
val INT_POW_LT2_REV : thm = |- !n x y. &0 <= y /\ x pow n < y pow n ==> x < y
val INT_POW_LT_1 : thm = |- !n x. ~(n = 0) /\ &1 < x ==> &1 < x pow n
val INT_POW_MONO : thm = |- !m n x. &1 <= x /\ m <= n ==> x pow m <= x pow n
val INT_POW_MONO_LT : thm = |- !m n x. &1 < x /\ m < n ==> x pow m < x pow n
val INT_POW_MUL : thm = |- !x y n. (x * y) pow n = x pow n * y pow n
val INT_POW_NEG : thm =
  |- !x n. --x pow n = (if EVEN n then x pow n else --(x pow n))
val INT_POW_NZ : thm = |- !x n. ~(x = &0) ==> ~(x pow n = &0)
val INT_POW_ONE : thm = |- !n. &1 pow n = &1
val INT_POW_POW : thm = |- !x m n. x pow m pow n = x pow (m * n)
val INT_POW_ZERO : thm = |- !n. &0 pow n = (if n = 0 then &1 else &0)
val INT_RNEG_UNIQ : thm = |- !x y. x + y = &0 <=> y = --x
val INT_SGN : thm =
  |- !x. int_sgn x = (if &0 < x then &1 else if x < &0 then -- &1 else &0)
val INT_SGN_0 : thm = |- int_sgn (&0) = &0
val INT_SGN_ABS : thm = |- !x. int_sgn x * abs x = x
val INT_SGN_CASES : thm =
  |- !x. int_sgn x = &0 \/ int_sgn x = &1 \/ int_sgn x = -- &1
val INT_SGN_EQ : thm =
  |- (!x. int_sgn x = &0 <=> x = &0) /\
     (!x. int_sgn x = &1 <=> x > &0) /\
     (!x. int_sgn x = -- &1 <=> x < &0)
val INT_SGN_INEQS : thm =
  |- (!x. &0 <= int_sgn x <=> &0 <= x) /\
     (!x. &0 < int_sgn x <=> &0 < x) /\
     (!x. &0 >= int_sgn x <=> &0 >= x) /\
     (!x. &0 > int_sgn x <=> &0 > x) /\
     (!x. &0 = int_sgn x <=> &0 = x) /\
     (!x. int_sgn x <= &0 <=> x <= &0) /\
     (!x. int_sgn x < &0 <=> x < &0) /\
     (!x. int_sgn x >= &0 <=> x >= &0) /\
     (!x. int_sgn x > &0 <=> x > &0) /\
     (!x. int_sgn x = &0 <=> x = &0)
val INT_SGN_MUL : thm = |- !x y. int_sgn (x * y) = int_sgn x * int_sgn y
val INT_SGN_NEG : thm = |- !x. int_sgn (--x) = --int_sgn x
val INT_SGN_POW : thm = |- !x n. int_sgn (x pow n) = int_sgn x pow n
val INT_SGN_POW_2 : thm = |- !x. int_sgn (x pow 2) = int_sgn (abs x)
val INT_SGN_INT_SGN : thm = |- !x. int_sgn (int_sgn x) = int_sgn x
val INT_SOS_EQ_0 : thm = |- !x y. x pow 2 + y pow 2 = &0 <=> x = &0 /\ y = &0
val INT_SUB_0 : thm = |- !x y. x - y = &0 <=> x = y
val INT_SUB_ABS : thm = |- !x y. abs x - abs y <= abs (x - y)
val INT_SUB_ADD : thm = |- !x y. x - y + y = x
val INT_SUB_ADD2 : thm = |- !x y. y + x - y = x
val INT_SUB_LDISTRIB : thm = |- !x y z. x * (y - z) = x * y - x * z
val INT_SUB_LE : thm = |- !x y. &0 <= x - y <=> y <= x
val INT_SUB_LNEG : thm = |- !x y. --x - y = --(x + y)
val INT_SUB_LT : thm = |- !x y. &0 < x - y <=> y < x
val INT_SUB_LZERO : thm = |- !x. &0 - x = --x
val INT_SUB_NEG2 : thm = |- !x y. --x - --y = y - x
val INT_SUB_RDISTRIB : thm = |- !x y z. (x - y) * z = x * z - y * z
val INT_SUB_REFL : thm = |- !x. x - x = &0
val INT_SUB_RNEG : thm = |- !x y. x - --y = x + y
val INT_SUB_RZERO : thm = |- !x. x - &0 = x
val INT_SUB_SUB : thm = |- !x y. x - y - x = --y
val INT_SUB_SUB2 : thm = |- !x y. x - (x - y) = y
val INT_SUB_TRIANGLE : thm = |- !a b c. a - b + b - c = a - c
val INT_FORALL_POS : thm = |- !P. (!n. P (&n)) <=> (!i. &0 <= i ==> P i)
val INT_EXISTS_POS : thm = |- !P. (?n. P (&n)) <=> (?i. &0 <= i /\ P i)
val INT_FORALL_ABS : thm = |- !P. (!n. P (&n)) <=> (!x. P (abs x))
val INT_EXISTS_ABS : thm = |- !P. (?n. P (&n)) <=> (?x. P (abs x))
val INT_ABS_MUL_1 : thm =
  |- !x y. abs (x * y) = &1 <=> abs x = &1 /\ abs y = &1
val INT_WOP : thm =
  |- (?x. &0 <= x /\ P x) <=>
     (?x. &0 <= x /\ P x /\ (!y. &0 <= y /\ P y ==> x <= y))
val INT_POW : thm = |- x pow 0 = &1 /\ (!n. x pow SUC n = x * x pow n)
val INT_ABS : thm = |- !x. abs x = (if &0 <= x then x else --x)
val INT_GE : thm = |- !x y. x >= y <=> y <= x
val INT_GT : thm = |- !x y. x > y <=> y < x
val INT_LT : thm = |- !x y. x < y <=> ~(y <= x)
val INT_SUB : thm = |- !x y. x - y = x + --y
val INT_MAX : thm = |- !x y. max x y = (if x <= y then y else x)
val INT_MIN : thm = |- !x y. min x y = (if x <= y then x else y)
val INT_OF_NUM_EXISTS : thm = |- !x. (?n. x = &n) <=> &0 <= x
val INT_LE_DISCRETE : thm = |- !x y. x <= y <=> x < y + &1
val INT_ARCH : thm = |- !x d. ~(d = &0) ==> (?c. x < c * d)
val INT_DIVMOD_EXIST_0 : thm =
  |- !m n.
         ?q r.
             if n = &0
             then q = &0 /\ r = m
             else &0 <= r /\ r < abs n /\ m = q * n + r
val INT_DIVISION_0 : thm =
  |- !m n.
         if n = &0
         then m div n = &0 /\ m rem n = m
         else &0 <= m rem n /\ m rem n < abs n /\ m = m div n * n + m rem n
val INT_DIVISION : thm =
  |- !m n.
         ~(n = &0)
         ==> m = m div n * n + m rem n /\ &0 <= m rem n /\ m rem n < abs n
val INT_DIVMOD_UNIQ : thm =
  |- !m n q r.
         m = q * n + r /\ &0 <= r /\ r < abs n ==> m div n = q /\ m rem n = r
val cong : thm = |- !rel x y. (x == y) rel <=> rel x y
val real_mod : thm =
  |- !x y n. real_mod n x y <=> (?q. integer q /\ x - y = q * n)
val int_divides : thm = |- !b a. a divides b <=> (?x. b = a * x)
val int_mod : thm = |- !n x y. mod n x y <=> n divides x - y
val int_congruent : thm = |- !x y n. (x == y) (mod n) <=> (?d. x - y = n * d)
val int_coprime : thm = |- !a b. coprime (a,b) <=> (?x y. a * x + b * y = &1)
val WF_INT_MEASURE : thm =
  |- !P m.
         (!x. &0 <= m x) /\ (!x. (!y. m y < m x ==> P y) ==> P x)
         ==> (!x. P x)
val WF_INT_MEASURE_2 : thm =
  |- !P m.
         (!x y. &0 <= m x y) /\
         (!x y. (!x' y'. m x' y' < m x y ==> P x' y') ==> P x y)
         ==> (!x y. P x y)
val INT_GCD_EXISTS : thm =
  |- !a b. ?d. d divides a /\ d divides b /\ (?x y. d = a * x + b * y)
val INT_GCD_EXISTS_POS : thm =
  |- !a b.
         ?d. &0 <= d /\
             d divides a /\
             d divides b /\
             (?x y. d = a * x + b * y)
val int_gcd : thm =
  |- !a b.
         &0 <= gcd (a,b) /\
         gcd (a,b) divides a /\
         gcd (a,b) divides b /\
         (?x y. gcd (a,b) = a * x + b * y)
val num_of_int : thm = |- !x. num_of_int x = (@n. &n = x)
val NUM_OF_INT_OF_NUM : thm = |- !n. num_of_int (&n) = n
val INT_OF_NUM_OF_INT : thm = |- !x. &0 <= x ==> &(num_of_int x) = x
val NUM_OF_INT : thm = |- !x. &0 <= x <=> &(num_of_int x) = x
val num_divides : thm = |- !a b. a divides b <=> &a divides &b
val num_mod : thm = |- !n x y. mod n x y <=> mod &n (&x) (&y)
val num_congruent : thm = |- !x y n. (x == y) (mod n) <=> (&x == &y) (mod &n)
val num_coprime : thm = |- !a b. coprime (a,b) <=> coprime (&a,&b)
val num_gcd : thm = |- !a b. gcd (a,b) = num_of_int (gcd (&a,&b))
val NUM_GCD : thm = |- !a b. &(gcd (a,b)) = gcd (&a,&b)
val divides : thm = |- a divides b <=> (?x. b = a * x)
val DIVIDES_LE : thm = |- !m n. m divides n ==> m <= n \/ n = 0
val IN : thm = |- !P x. x IN P <=> P x
val EXTENSION : thm = |- !s t. s = t <=> (!x. x IN s <=> x IN t)
val GSPEC : thm = |- !p. GSPEC p = p
val SETSPEC : thm = |- !P v t. SETSPEC v P t <=> P /\ v = t
val IN_ELIM_THM : thm =
  |- (!P x. x IN GSPEC (\v. P (SETSPEC v)) <=> P (\p t. p /\ x = t)) /\
     (!p x. x IN {y | p y} <=> p x) /\
     (!P x. GSPEC (\v. P (SETSPEC v)) x <=> P (\p t. p /\ x = t)) /\
     (!p x. {y | p y} x <=> p x) /\
     (!p x. x IN (\y. p y) <=> p x)
val EMPTY : thm = |- {} = (\x. F)
val INSERT_DEF : thm = |- !s x. x INSERT s = (\y. y IN s \/ y = x)
val UNIV : thm = |- (:A) = (\x. T)
val UNION : thm = |- !s t. s UNION t = {x | x IN s \/ x IN t}
val UNIONS : thm = |- !s. UNIONS s = {x | ?u. u IN s /\ x IN u}
val INTER : thm = |- !s t. s INTER t = {x | x IN s /\ x IN t}
val INTERS : thm = |- !s. INTERS s = {x | !u. u IN s ==> x IN u}
val DIFF : thm = |- !s t. s DIFF t = {x | x IN s /\ ~(x IN t)}
val INSERT : thm = |- x INSERT s = {y | y IN s \/ y = x}
val DELETE : thm = |- !s x. s DELETE x = {y | y IN s /\ ~(y = x)}
val SUBSET : thm = |- !s t. s SUBSET t <=> (!x. x IN s ==> x IN t)
val PSUBSET : thm = |- !s t. s PSUBSET t <=> s SUBSET t /\ ~(s = t)
val DISJOINT : thm = |- !s t. DISJOINT s t <=> s INTER t = {}
val SING : thm = |- !s. SING s <=> (?x. s = {x})
val FINITE_RULES : thm =
  |- FINITE {} /\ (!x s. FINITE s ==> FINITE (x INSERT s))
val FINITE_INDUCT : thm =
  |- !FINITE'. FINITE' {} /\ (!x s. FINITE' s ==> FINITE' (x INSERT s))
               ==> (!a. FINITE a ==> FINITE' a)
val FINITE_CASES : thm =
  |- !a. FINITE a <=> a = {} \/ (?x s. a = x INSERT s /\ FINITE s)
val INFINITE : thm = |- !s. INFINITE s <=> ~FINITE s
val IMAGE : thm = |- !s f. IMAGE f s = {y | ?x. x IN s /\ y = f x}
val INJ : thm =
  |- !t s f.
         INJ f s t <=>
         (!x. x IN s ==> f x IN t) /\
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
val SURJ : thm =
  |- !t s f.
         SURJ f s t <=>
         (!x. x IN s ==> f x IN t) /\
         (!x. x IN t ==> (?y. y IN s /\ f y = x))
val BIJ : thm = |- !f s t. BIJ f s t <=> INJ f s t /\ SURJ f s t
val CHOICE : thm = |- !s. CHOICE s = (@x. x IN s)
val REST : thm = |- !s. REST s = s DELETE CHOICE s
val NOT_IN_EMPTY : thm = |- !x. ~(x IN {})
val IN_UNIV : thm = |- !x. x IN (:A)
val IN_UNION : thm = |- !s t x. x IN s UNION t <=> x IN s \/ x IN t
val IN_UNIONS : thm = |- !s x. x IN UNIONS s <=> (?t. t IN s /\ x IN t)
val IN_INTER : thm = |- !s t x. x IN s INTER t <=> x IN s /\ x IN t
val IN_INTERS : thm = |- !s x. x IN INTERS s <=> (!t. t IN s ==> x IN t)
val IN_DIFF : thm = |- !s t x. x IN s DIFF t <=> x IN s /\ ~(x IN t)
val IN_INSERT : thm = |- !x y s. x IN y INSERT s <=> x = y \/ x IN s
val IN_DELETE : thm = |- !s x y. x IN s DELETE y <=> x IN s /\ ~(x = y)
val IN_SING : thm = |- !x y. x IN {y} <=> x = y
val IN_IMAGE : thm = |- !y s f. y IN IMAGE f s <=> (?x. y = f x /\ x IN s)
val IN_REST : thm = |- !x s. x IN REST s <=> x IN s /\ ~(x = CHOICE s)
val FORALL_IN_INSERT : thm =
  |- !P a s. (!x. x IN a INSERT s ==> P x) <=> P a /\ (!x. x IN s ==> P x)
val EXISTS_IN_INSERT : thm =
  |- !P a s. (?x. x IN a INSERT s /\ P x) <=> P a \/ (?x. x IN s /\ P x)
val FORALL_IN_UNION : thm =
  |- !P s t.
         (!x. x IN s UNION t ==> P x) <=>
         (!x. x IN s ==> P x) /\ (!x. x IN t ==> P x)
val EXISTS_IN_UNION : thm =
  |- !P s t.
         (?x. x IN s UNION t /\ P x) <=>
         (?x. x IN s /\ P x) \/ (?x. x IN t /\ P x)
val CHOICE_DEF : thm = |- !s. ~(s = {}) ==> CHOICE s IN s
val NOT_EQUAL_SETS : thm = |- !s t. ~(s = t) <=> (?x. x IN t <=> ~(x IN s))
val MEMBER_NOT_EMPTY : thm = |- !s. (?x. x IN s) <=> ~(s = {})
val UNIV_NOT_EMPTY : thm = |- ~((:A) = {})
val EMPTY_NOT_UNIV : thm = |- ~({} = (:A))
val EQ_UNIV : thm = |- (!x. x IN s) <=> s = (:A)
val SUBSET_TRANS : thm = |- !s t u. s SUBSET t /\ t SUBSET u ==> s SUBSET u
val SUBSET_REFL : thm = |- !s. s SUBSET s
val SUBSET_ANTISYM : thm = |- !s t. s SUBSET t /\ t SUBSET s ==> s = t
val SUBSET_ANTISYM_EQ : thm = |- !s t. s SUBSET t /\ t SUBSET s <=> s = t
val EMPTY_SUBSET : thm = |- !s. {} SUBSET s
val SUBSET_EMPTY : thm = |- !s. s SUBSET {} <=> s = {}
val SUBSET_UNIV : thm = |- !s. s SUBSET (:A)
val UNIV_SUBSET : thm = |- !s. (:A) SUBSET s <=> s = (:A)
val SING_SUBSET : thm = |- !s x. {x} SUBSET s <=> x IN s
val SUBSET_RESTRICT : thm = |- !s P. {x | x IN s /\ P x} SUBSET s
val PSUBSET_TRANS : thm =
  |- !s t u. s PSUBSET t /\ t PSUBSET u ==> s PSUBSET u
val PSUBSET_SUBSET_TRANS : thm =
  |- !s t u. s PSUBSET t /\ t SUBSET u ==> s PSUBSET u
val SUBSET_PSUBSET_TRANS : thm =
  |- !s t u. s SUBSET t /\ t PSUBSET u ==> s PSUBSET u
val PSUBSET_IRREFL : thm = |- !s. ~(s PSUBSET s)
val NOT_PSUBSET_EMPTY : thm = |- !s. ~(s PSUBSET {})
val NOT_UNIV_PSUBSET : thm = |- !s. ~((:A) PSUBSET s)
val PSUBSET_UNIV : thm = |- !s. s PSUBSET (:A) <=> (?x. ~(x IN s))
val PSUBSET_ALT : thm =
  |- !s t. s PSUBSET t <=> s SUBSET t /\ (?a. a IN t /\ ~(a IN s))
val UNION_ASSOC : thm = |- !s t u. (s UNION t) UNION u = s UNION t UNION u
val UNION_IDEMPOT : thm = |- !s. s UNION s = s
val UNION_COMM : thm = |- !s t. s UNION t = t UNION s
val SUBSET_UNION : thm =
  |- (!s t. s SUBSET s UNION t) /\ (!s t. s SUBSET t UNION s)
val SUBSET_UNION_ABSORPTION : thm = |- !s t. s SUBSET t <=> s UNION t = t
val UNION_EMPTY : thm = |- (!s. {} UNION s = s) /\ (!s. s UNION {} = s)
val UNION_UNIV : thm =
  |- (!s. (:A) UNION s = (:A)) /\ (!s. s UNION (:A) = (:A))
val EMPTY_UNION : thm = |- !s t. s UNION t = {} <=> s = {} /\ t = {}
val UNION_SUBSET : thm =
  |- !s t u. s UNION t SUBSET u <=> s SUBSET u /\ t SUBSET u
val FORALL_SUBSET_UNION : thm =
  |- !t u.
         (!s. s SUBSET t UNION u ==> P s) <=>
         (!t' u'. t' SUBSET t /\ u' SUBSET u ==> P (t' UNION u'))
val EXISTS_SUBSET_UNION : thm =
  |- !t u.
         (?s. s SUBSET t UNION u /\ P s) <=>
         (?t' u'. t' SUBSET t /\ u' SUBSET u /\ P (t' UNION u'))
val FORALL_SUBSET_INSERT : thm =
  |- !a t.
         (!s. s SUBSET a INSERT t ==> P s) <=>
         (!s. s SUBSET t ==> P s /\ P (a INSERT s))
val EXISTS_SUBSET_INSERT : thm =
  |- !a t.
         (?s. s SUBSET a INSERT t /\ P s) <=>
         (?s. s SUBSET t /\ (P s \/ P (a INSERT s)))
val INTER_ASSOC : thm = |- !s t u. (s INTER t) INTER u = s INTER t INTER u
val INTER_IDEMPOT : thm = |- !s. s INTER s = s
val INTER_COMM : thm = |- !s t. s INTER t = t INTER s
val INTER_SUBSET : thm =
  |- (!s t. s INTER t SUBSET s) /\ (!s t. t INTER s SUBSET s)
val SUBSET_INTER_ABSORPTION : thm = |- !s t. s SUBSET t <=> s INTER t = s
val INTER_EMPTY : thm = |- (!s. {} INTER s = {}) /\ (!s. s INTER {} = {})
val INTER_UNIV : thm = |- (!s. (:A) INTER s = s) /\ (!s. s INTER (:A) = s)
val SUBSET_INTER : thm =
  |- !s t u. s SUBSET t INTER u <=> s SUBSET t /\ s SUBSET u
val UNION_OVER_INTER : thm =
  |- !s t u. s INTER (t UNION u) = s INTER t UNION s INTER u
val INTER_OVER_UNION : thm =
  |- !s t u. s UNION t INTER u = (s UNION t) INTER (s UNION u)
val IN_DISJOINT : thm = |- !s t. DISJOINT s t <=> ~(?x. x IN s /\ x IN t)
val DISJOINT_SYM : thm = |- !s t. DISJOINT s t <=> DISJOINT t s
val DISJOINT_EMPTY : thm = |- !s. DISJOINT {} s /\ DISJOINT s {}
val DISJOINT_EMPTY_REFL : thm = |- !s. s = {} <=> DISJOINT s s
val DISJOINT_UNION : thm =
  |- !s t u. DISJOINT (s UNION t) u <=> DISJOINT s u /\ DISJOINT t u
val DIFF_EMPTY : thm = |- !s. s DIFF {} = s
val EMPTY_DIFF : thm = |- !s. {} DIFF s = {}
val DIFF_UNIV : thm = |- !s. s DIFF (:A) = {}
val DIFF_DIFF : thm = |- !s t. s DIFF t DIFF t = s DIFF t
val DIFF_EQ_EMPTY : thm = |- !s. s DIFF s = {}
val SUBSET_DIFF : thm = |- !s t. s DIFF t SUBSET s
val COMPONENT : thm = |- !x s. x IN x INSERT s
val DECOMPOSITION : thm =
  |- !s x. x IN s <=> (?t. s = x INSERT t /\ ~(x IN t))
val SET_CASES : thm = |- !s. s = {} \/ (?x t. s = x INSERT t /\ ~(x IN t))
val ABSORPTION : thm = |- !x s. x IN s <=> x INSERT s = s
val INSERT_INSERT : thm = |- !x s. x INSERT x INSERT s = x INSERT s
val INSERT_COMM : thm = |- !x y s. x INSERT y INSERT s = y INSERT x INSERT s
val INSERT_UNIV : thm = |- !x. x INSERT (:A) = (:A)
val NOT_INSERT_EMPTY : thm = |- !x s. ~(x INSERT s = {})
val NOT_EMPTY_INSERT : thm = |- !x s. ~({} = x INSERT s)
val INSERT_UNION : thm =
  |- !x s t.
         x INSERT s UNION t =
         (if x IN t then s UNION t else x INSERT (s UNION t))
val INSERT_UNION_EQ : thm =
  |- !x s t. x INSERT s UNION t = x INSERT (s UNION t)
val INSERT_INTER : thm =
  |- !x s t.
         x INSERT s INTER t =
         (if x IN t then x INSERT (s INTER t) else s INTER t)
val DISJOINT_INSERT : thm =
  |- !x s t. DISJOINT (x INSERT s) t <=> DISJOINT s t /\ ~(x IN t)
val INSERT_SUBSET : thm =
  |- !x s t. x INSERT s SUBSET t <=> x IN t /\ s SUBSET t
val SUBSET_INSERT : thm =
  |- !x s. ~(x IN s) ==> (!t. s SUBSET x INSERT t <=> s SUBSET t)
val INSERT_DIFF : thm =
  |- !s t x.
         x INSERT s DIFF t =
         (if x IN t then s DIFF t else x INSERT (s DIFF t))
val INSERT_AC : thm =
  |- x INSERT y INSERT s = y INSERT x INSERT s /\
     x INSERT x INSERT s = x INSERT s
val INTER_ACI : thm =
  |- p INTER q = q INTER p /\
     (p INTER q) INTER r = p INTER q INTER r /\
     p INTER q INTER r = q INTER p INTER r /\
     p INTER p = p /\
     p INTER p INTER q = p INTER q
val UNION_ACI : thm =
  |- p UNION q = q UNION p /\
     (p UNION q) UNION r = p UNION q UNION r /\
     p UNION q UNION r = q UNION p UNION r /\
     p UNION p = p /\
     p UNION p UNION q = p UNION q
val DELETE_NON_ELEMENT : thm = |- !x s. ~(x IN s) <=> s DELETE x = s
val IN_DELETE_EQ : thm =
  |- !s x x'. (x IN s <=> x' IN s) <=> x IN s DELETE x' <=> x' IN s DELETE x
val EMPTY_DELETE : thm = |- !x. {} DELETE x = {}
val DELETE_DELETE : thm = |- !x s. s DELETE x DELETE x = s DELETE x
val DELETE_COMM : thm = |- !x y s. s DELETE x DELETE y = s DELETE y DELETE x
val DELETE_SUBSET : thm = |- !x s. s DELETE x SUBSET s
val SUBSET_DELETE : thm =
  |- !x s t. s SUBSET t DELETE x <=> ~(x IN s) /\ s SUBSET t
val SUBSET_INSERT_DELETE : thm =
  |- !x s t. s SUBSET x INSERT t <=> s DELETE x SUBSET t
val DIFF_INSERT : thm = |- !s t x. s DIFF x INSERT t = s DELETE x DIFF t
val PSUBSET_INSERT_SUBSET : thm =
  |- !s t. s PSUBSET t <=> (?x. ~(x IN s) /\ x INSERT s SUBSET t)
val PSUBSET_MEMBER : thm =
  |- !s t. s PSUBSET t <=> s SUBSET t /\ (?y. y IN t /\ ~(y IN s))
val DELETE_INSERT : thm =
  |- !x y s.
         (x INSERT s) DELETE y =
         (if x = y then s DELETE y else x INSERT (s DELETE y))
val INSERT_DELETE : thm = |- !x s. x IN s ==> x INSERT (s DELETE x) = s
val DELETE_INTER : thm = |- !s t x. s DELETE x INTER t = (s INTER t) DELETE x
val DISJOINT_DELETE_SYM : thm =
  |- !s t x. DISJOINT (s DELETE x) t <=> DISJOINT (t DELETE x) s
val UNIONS_0 : thm = |- UNIONS {} = {}
val UNIONS_1 : thm = |- UNIONS {s} = s
val UNIONS_2 : thm = |- UNIONS {s, t} = s UNION t
val UNIONS_INSERT : thm = |- UNIONS (s INSERT u) = s UNION UNIONS u
val FORALL_IN_UNIONS : thm =
  |- !P s. (!x. x IN UNIONS s ==> P x) <=> (!t x. t IN s /\ x IN t ==> P x)
val EXISTS_IN_UNIONS : thm =
  |- !P s. (?x. x IN UNIONS s /\ P x) <=> (?t x. t IN s /\ x IN t /\ P x)
val EMPTY_UNIONS : thm = |- !s. UNIONS s = {} <=> (!t. t IN s ==> t = {})
val INTER_UNIONS : thm =
  |- (!s t. UNIONS s INTER t = UNIONS {x INTER t | x IN s}) /\
     (!s t. t INTER UNIONS s = UNIONS {t INTER x | x IN s})
val UNIONS_SUBSET : thm =
  |- !f t. UNIONS f SUBSET t <=> (!s. s IN f ==> s SUBSET t)
val SUBSET_UNIONS : thm = |- !f g. f SUBSET g ==> UNIONS f SUBSET UNIONS g
val UNIONS_UNION : thm =
  |- !s t. UNIONS (s UNION t) = UNIONS s UNION UNIONS t
val INTERS_UNION : thm =
  |- !s t. INTERS (s UNION t) = INTERS s INTER INTERS t
val UNIONS_MONO : thm =
  |- (!x. x IN s ==> (?y. y IN t /\ x SUBSET y)) ==> UNIONS s SUBSET UNIONS t
val UNIONS_MONO_IMAGE : thm =
  |- (!x. x IN s ==> f x SUBSET g x)
     ==> UNIONS (IMAGE f s) SUBSET UNIONS (IMAGE g s)
val INTERS_0 : thm = |- INTERS {} = (:A)
val INTERS_1 : thm = |- INTERS {s} = s
val INTERS_2 : thm = |- INTERS {s, t} = s INTER t
val INTERS_INSERT : thm = |- INTERS (s INSERT u) = s INTER INTERS u
val SUBSET_INTERS : thm =
  |- !s f. s SUBSET INTERS f <=> (!t. t IN f ==> s SUBSET t)
val IMAGE_CLAUSES : thm =
  |- IMAGE f {} = {} /\ IMAGE f (x INSERT s) = f x INSERT IMAGE f s
val IMAGE_UNION : thm =
  |- !f s t. IMAGE f (s UNION t) = IMAGE f s UNION IMAGE f t
val IMAGE_ID : thm = |- !s. IMAGE (\x. x) s = s
val IMAGE_I : thm = |- !s. IMAGE I s = s
val IMAGE_o : thm = |- !f g s. IMAGE (f o g) s = IMAGE f (IMAGE g s)
val IMAGE_SUBSET : thm = |- !f s t. s SUBSET t ==> IMAGE f s SUBSET IMAGE f t
val IMAGE_INTER_INJ : thm =
  |- !f s t.
         (!x y. f x = f y ==> x = y)
         ==> IMAGE f (s INTER t) = IMAGE f s INTER IMAGE f t
val IMAGE_DIFF_INJ : thm =
  |- !f s t.
         (!x y. f x = f y ==> x = y)
         ==> IMAGE f (s DIFF t) = IMAGE f s DIFF IMAGE f t
val IMAGE_DELETE_INJ : thm =
  |- !f s a.
         (!x. f x = f a ==> x = a)
         ==> IMAGE f (s DELETE a) = IMAGE f s DELETE f a
val IMAGE_EQ_EMPTY : thm = |- !f s. IMAGE f s = {} <=> s = {}
val FORALL_IN_IMAGE : thm =
  |- !f s. (!y. y IN IMAGE f s ==> P y) <=> (!x. x IN s ==> P (f x))
val EXISTS_IN_IMAGE : thm =
  |- !f s. (?y. y IN IMAGE f s /\ P y) <=> (?x. x IN s /\ P (f x))
val SUBSET_IMAGE : thm =
  |- !f s t. s SUBSET IMAGE f t <=> (?u. u SUBSET t /\ s = IMAGE f u)
val FORALL_SUBSET_IMAGE : thm =
  |- !P f s.
         (!t. t SUBSET IMAGE f s ==> P t) <=>
         (!t. t SUBSET s ==> P (IMAGE f t))
val EXISTS_SUBSET_IMAGE : thm =
  |- !P f s.
         (?t. t SUBSET IMAGE f s /\ P t) <=>
         (?t. t SUBSET s /\ P (IMAGE f t))
val IMAGE_CONST : thm =
  |- !s c. IMAGE (\x. c) s = (if s = {} then {} else {c})
val SIMPLE_IMAGE : thm = |- !f s. {f x | x IN s} = IMAGE f s
val SIMPLE_IMAGE_GEN : thm = |- !f P. {f x | P x} = IMAGE f {x | P x}
val IMAGE_UNIONS : thm =
  |- !f s. IMAGE f (UNIONS s) = UNIONS (IMAGE (IMAGE f) s)
val FUN_IN_IMAGE : thm = |- !f s x. x IN s ==> f x IN IMAGE f s
val SURJECTIVE_IMAGE_EQ : thm =
  |- !s t.
         (!y. y IN t ==> (?x. f x = y)) /\ (!x. f x IN t <=> x IN s)
         ==> IMAGE f s = t
val EMPTY_GSPEC : thm = |- {x | F} = {}
val UNIV_GSPEC : thm = |- {x | T} = (:?52305)
val SING_GSPEC : thm = |- (!a. {x | x = a} = {a}) /\ (!a. {x | a = x} = {a})
val IN_ELIM_PAIR_THM : thm = |- !P a b. a,b IN {x,y | P x y} <=> P a b
val SET_PAIR_THM : thm = |- !P. {p | P p} = {a,b | P (a,b)}
val FORALL_IN_GSPEC : thm =
  |- (!P f. (!z. z IN {f x | P x} ==> Q z) <=> (!x. P x ==> Q (f x))) /\
     (!P f.
          (!z. z IN {f x y | P x y} ==> Q z) <=> (!x y. P x y ==> Q (f x y))) /\
     (!P f.
          (!z. z IN {f w x y | P w x y} ==> Q z) <=>
          (!w x y. P w x y ==> Q (f w x y))) /\
     (!P f.
          (!z. z IN {f v w x y | P v w x y} ==> Q z) <=>
          (!v w x y. P v w x y ==> Q (f v w x y)))
val EXISTS_IN_GSPEC : thm =
  |- (!P f. (?z. z IN {f x | P x} /\ Q z) <=> (?x. P x /\ Q (f x))) /\
     (!P f. (?z. z IN {f x y | P x y} /\ Q z) <=> (?x y. P x y /\ Q (f x y))) /\
     (!P f.
          (?z. z IN {f w x y | P w x y} /\ Q z) <=>
          (?w x y. P w x y /\ Q (f w x y))) /\
     (!P f.
          (?z. z IN {f v w x y | P v w x y} /\ Q z) <=>
          (?v w x y. P v w x y /\ Q (f v w x y)))
val SET_PROVE_CASES : thm =
  |- !P. P {} /\ (!a s. ~(a IN s) ==> P (a INSERT s)) ==> (!s. P s)
val UNIONS_IMAGE : thm =
  |- !f s. UNIONS (IMAGE f s) = {y | ?x. x IN s /\ y IN f x}
val INTERS_IMAGE : thm =
  |- !f s. INTERS (IMAGE f s) = {y | !x. x IN s ==> y IN f x}
val UNIONS_GSPEC : thm =
  |- (!P f. UNIONS {f x | P x} = {a | ?x. P x /\ a IN f x}) /\
     (!P f. UNIONS {f x y | P x y} = {a | ?x y. P x y /\ a IN f x y}) /\
     (!P f.
          UNIONS {f x y z | P x y z} = {a | ?x y z. P x y z /\ a IN f x y z})
val INTERS_GSPEC : thm =
  |- (!P f. INTERS {f x | P x} = {a | !x. P x ==> a IN f x}) /\
     (!P f. INTERS {f x y | P x y} = {a | !x y. P x y ==> a IN f x y}) /\
     (!P f.
          INTERS {f x y z | P x y z} = {a | !x y z. P x y z ==> a IN f x y z})
val DIFF_INTERS : thm = |- !u s. u DIFF INTERS s = UNIONS {u DIFF t | t IN s}
val INTERS_UNIONS : thm =
  |- !s. INTERS s = (:?53528) DIFF UNIONS {(:?53528) DIFF t | t IN s}
val UNIONS_INTERS : thm =
  |- !s. UNIONS s = (:?53563) DIFF INTERS {(:?53563) DIFF t | t IN s}
val UNIONS_DIFF : thm = |- !s t. UNIONS s DIFF t = UNIONS {x DIFF t | x IN s}
val DIFF_UNIONS : thm =
  |- !u s. u DIFF UNIONS s = u INTER INTERS {u DIFF t | t IN s}
val DIFF_UNIONS_NONEMPTY : thm =
  |- !u s. ~(s = {}) ==> u DIFF UNIONS s = INTERS {u DIFF t | t IN s}
val INTERS_OVER_UNIONS : thm =
  |- !f s.
         INTERS {UNIONS (f x) | x IN s} =
         UNIONS {INTERS {g x | x IN s} | g | !x. x IN s ==> g x IN f x}
val FINITE_INDUCT_STRONG : thm =
  |- !P. P {} /\ (!x s. P s /\ ~(x IN s) /\ FINITE s ==> P (x INSERT s))
         ==> (!s. FINITE s ==> P s)
val INJECTIVE_ON_ALT : thm =
  |- !P f.
         (!x y. P x /\ P y /\ f x = f y ==> x = y) <=>
         (!x y. P x /\ P y ==> (f x = f y <=> x = y))
val INJECTIVE_ALT : thm =
  |- !f. (!x y. f x = f y ==> x = y) <=> (!x y. f x = f y <=> x = y)
val SURJECTIVE_ON_RIGHT_INVERSE : thm =
  |- !f t.
         (!y. y IN t ==> (?x. x IN s /\ f x = y)) <=>
         (?g. !y. y IN t ==> g y IN s /\ f (g y) = y)
val INJECTIVE_ON_LEFT_INVERSE : thm =
  |- !f s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) <=>
         (?g. !x. x IN s ==> g (f x) = x)
val BIJECTIVE_ON_LEFT_RIGHT_INVERSE : thm =
  |- !f s t.
         (!x. x IN s ==> f x IN t)
         ==> ((!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) /\
              (!y. y IN t ==> (?x. x IN s /\ f x = y)) <=>
              (?g. (!y. y IN t ==> g y IN s) /\
                   (!y. y IN t ==> f (g y) = y) /\
                   (!x. x IN s ==> g (f x) = x)))
val SURJECTIVE_RIGHT_INVERSE : thm =
  |- (!y. ?x. f x = y) <=> (?g. !y. f (g y) = y)
val INJECTIVE_LEFT_INVERSE : thm =
  |- (!x y. f x = f y ==> x = y) <=> (?g. !x. g (f x) = x)
val BIJECTIVE_LEFT_RIGHT_INVERSE : thm =
  |- !f. (!x y. f x = f y ==> x = y) /\ (!y. ?x. f x = y) <=>
         (?g. (!y. f (g y) = y) /\ (!x. g (f x) = x))
val FUNCTION_FACTORS_LEFT_GEN : thm =
  |- !P f g.
         (!x y. P x /\ P y /\ g x = g y ==> f x = f y) <=>
         (?h. !x. P x ==> f x = h (g x))
val FUNCTION_FACTORS_LEFT : thm =
  |- !f g. (!x y. g x = g y ==> f x = f y) <=> (?h. f = h o g)
val FUNCTION_FACTORS_RIGHT_GEN : thm =
  |- !P f g.
         (!x. P x ==> (?y. g y = f x)) <=> (?h. !x. P x ==> f x = g (h x))
val FUNCTION_FACTORS_RIGHT : thm =
  |- !f g. (!x. ?y. g y = f x) <=> (?h. f = g o h)
val SURJECTIVE_FORALL_THM : thm =
  |- !f. (!y. ?x. f x = y) <=> (!P. (!x. P (f x)) <=> (!y. P y))
val SURJECTIVE_EXISTS_THM : thm =
  |- !f. (!y. ?x. f x = y) <=> (!P. (?x. P (f x)) <=> (?y. P y))
val SURJECTIVE_IMAGE_THM : thm =
  |- !f. (!y. ?x. f x = y) <=> (!P. IMAGE f {x | P (f x)} = {x | P x})
val IMAGE_INJECTIVE_IMAGE_OF_SUBSET : thm =
  |- !f s.
         ?t. t SUBSET s /\
             IMAGE f s = IMAGE f t /\
             (!x y. x IN t /\ y IN t /\ f x = f y ==> x = y)
val FINITE_EMPTY : thm = |- FINITE {}
val FINITE_SUBSET : thm = |- !s t. FINITE t /\ s SUBSET t ==> FINITE s
val FINITE_RESTRICT : thm = |- !s P. FINITE s ==> FINITE {x | x IN s /\ P x}
val FINITE_UNION_IMP : thm =
  |- !s t. FINITE s /\ FINITE t ==> FINITE (s UNION t)
val FINITE_UNION : thm = |- !s t. FINITE (s UNION t) <=> FINITE s /\ FINITE t
val FINITE_INTER : thm = |- !s t. FINITE s \/ FINITE t ==> FINITE (s INTER t)
val FINITE_INSERT : thm = |- !s x. FINITE (x INSERT s) <=> FINITE s
val FINITE_SING : thm = |- !a. FINITE {a}
val FINITE_DELETE_IMP : thm = |- !s x. FINITE s ==> FINITE (s DELETE x)
val FINITE_DELETE : thm = |- !s x. FINITE (s DELETE x) <=> FINITE s
val FINITE_FINITE_UNIONS : thm =
  |- !s. FINITE s ==> (FINITE (UNIONS s) <=> (!t. t IN s ==> FINITE t))
val FINITE_IMAGE_EXPAND : thm =
  |- !f s. FINITE s ==> FINITE {y | ?x. x IN s /\ y = f x}
val FINITE_IMAGE : thm = |- !f s. FINITE s ==> FINITE (IMAGE f s)
val FINITE_IMAGE_INJ_GENERAL : thm =
  |- !f A s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) /\ FINITE A
         ==> FINITE {x | x IN s /\ f x IN A}
val FINITE_FINITE_PREIMAGE_GENERAL : thm =
  |- !f s t.
         FINITE t /\ (!y. y IN t ==> FINITE {x | x IN s /\ f x = y})
         ==> FINITE {x | x IN s /\ f x IN t}
val FINITE_FINITE_PREIMAGE : thm =
  |- !f t.
         FINITE t /\ (!y. y IN t ==> FINITE {x | f x = y})
         ==> FINITE {x | f x IN t}
val FINITE_IMAGE_INJ_EQ : thm =
  |- !f s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
         ==> (FINITE (IMAGE f s) <=> FINITE s)
val FINITE_IMAGE_INJ : thm =
  |- !f A. (!x y. f x = f y ==> x = y) /\ FINITE A ==> FINITE {x | f x IN A}
val INFINITE_IMAGE_INJ : thm =
  |- !f. (!x y. f x = f y ==> x = y)
         ==> (!s. INFINITE s ==> INFINITE (IMAGE f s))
val INFINITE_NONEMPTY : thm = |- !s. INFINITE s ==> ~(s = {})
val INFINITE_DIFF_FINITE : thm =
  |- !s t. INFINITE s /\ FINITE t ==> INFINITE (s DIFF t)
val FINITE_SUBSET_IMAGE : thm =
  |- !f s t.
         FINITE t /\ t SUBSET IMAGE f s <=>
         (?s'. FINITE s' /\ s' SUBSET s /\ t = IMAGE f s')
val EXISTS_FINITE_SUBSET_IMAGE : thm =
  |- !P f s.
         (?t. FINITE t /\ t SUBSET IMAGE f s /\ P t) <=>
         (?t. FINITE t /\ t SUBSET s /\ P (IMAGE f t))
val FORALL_FINITE_SUBSET_IMAGE : thm =
  |- !P f s.
         (!t. FINITE t /\ t SUBSET IMAGE f s ==> P t) <=>
         (!t. FINITE t /\ t SUBSET s ==> P (IMAGE f t))
val FINITE_SUBSET_IMAGE_IMP : thm =
  |- !f s t.
         FINITE t /\ t SUBSET IMAGE f s
         ==> (?s'. FINITE s' /\ s' SUBSET s /\ t SUBSET IMAGE f s')
val FINITE_DIFF : thm = |- !s t. FINITE s ==> FINITE (s DIFF t)
val INFINITE_SUPERSET : thm =
  |- !s t. INFINITE s /\ s SUBSET t ==> INFINITE t
val FINITE_TRANSITIVITY_CHAIN : thm =
  |- !R s.
         FINITE s /\
         (!x. ~R x x) /\
         (!x y z. R x y /\ R y z ==> R x z) /\
         (!x. x IN s ==> (?y. y IN s /\ R x y))
         ==> s = {}
val UNIONS_MAXIMAL_SETS : thm =
  |- !f. FINITE f
         ==> UNIONS {t | t IN f /\ (!u. u IN f ==> ~(t PSUBSET u))} =
             UNIONS f
val FINREC : thm =
  |- (FINREC f b s a 0 <=> s = {} /\ a = b) /\
     (FINREC f b s a (SUC n) <=>
      (?x c. x IN s /\ FINREC f b (s DELETE x) c n /\ a = f x c))
val FINREC_1_LEMMA : thm =
  |- !f b s a. FINREC f b s a (SUC 0) <=> (?x. s = {x} /\ a = f x b)
val FINREC_SUC_LEMMA : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> (!n s z.
                  FINREC f b s z (SUC n)
                  ==> (!x. x IN s
                           ==> (?w. FINREC f b (s DELETE x) w n /\ z = f x w)))
val FINREC_UNIQUE_LEMMA : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> (!n1 n2 s a1 a2.
                  FINREC f b s a1 n1 /\ FINREC f b s a2 n2
                  ==> a1 = a2 /\ n1 = n2)
val FINREC_EXISTS_LEMMA : thm =
  |- !f b s. FINITE s ==> (?a n. FINREC f b s a n)
val FINREC_FUN_LEMMA : thm =
  |- !P R.
         (!s. P s ==> (?a n. R s a n)) /\
         (!n1 n2 s a1 a2. R s a1 n1 /\ R s a2 n2 ==> a1 = a2 /\ n1 = n2)
         ==> (?f. !s a. P s ==> ((?n. R s a n) <=> f s = a))
val FINREC_FUN : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> (?g. g {} = b /\
                  (!s x. FINITE s /\ x IN s ==> g s = f x (g (s DELETE x))))
val SET_RECURSION_LEMMA : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> (?g. g {} = b /\
                  (!x s.
                       FINITE s
                       ==> g (x INSERT s) =
                           (if x IN s then g s else f x (g s))))
val ITSET : thm =
  |- !b f s.
         ITSET f s b =
         (@g. g {} = b /\
              (!x s.
                   FINITE s
                   ==> g (x INSERT s) = (if x IN s then g s else f x (g s))))
         s
val FINITE_RECURSION : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> ITSET f {} b = b /\
             (!x s.
                  FINITE s
                  ==> ITSET f (x INSERT s) b =
                      (if x IN s then ITSET f s b else f x (ITSET f s b)))
val FINITE_RECURSION_DELETE : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> ITSET f {} b = b /\
             (!x s.
                  FINITE s
                  ==> ITSET f s b =
                      (if x IN s
                       then f x (ITSET f (s DELETE x) b)
                       else ITSET f (s DELETE x) b))
val ITSET_EQ : thm =
  |- !s f g b.
         FINITE s /\
         (!x. x IN s ==> f x = g x) /\
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s)) /\
         (!x y s. ~(x = y) ==> g x (g y s) = g y (g x s))
         ==> ITSET f s b = ITSET g s b
val CARD : thm = |- !s. CARD s = ITSET (\x n. SUC n) s 0
val CARD_CLAUSES : thm =
  |- CARD {} = 0 /\
     (!x s.
          FINITE s
          ==> CARD (x INSERT s) = (if x IN s then CARD s else SUC (CARD s)))
val CARD_UNION : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ s INTER t = {}
         ==> CARD (s UNION t) = CARD s + CARD t
val CARD_DELETE : thm =
  |- !x s.
         FINITE s
         ==> CARD (s DELETE x) = (if x IN s then CARD s - 1 else CARD s)
val CARD_UNION_EQ : thm =
  |- !s t u.
         FINITE u /\ s INTER t = {} /\ s UNION t = u
         ==> CARD s + CARD t = CARD u
val CARD_DIFF : thm =
  |- !s t. FINITE s /\ t SUBSET s ==> CARD (s DIFF t) = CARD s - CARD t
val CARD_EQ_0 : thm = |- !s. FINITE s ==> (CARD s = 0 <=> s = {})
val CARD_SING : thm = |- !a. CARD {a} = 1
val FINITE_INDUCT_DELETE : thm =
  |- !P. P {} /\
         (!s. FINITE s /\ ~(s = {})
              ==> (?x. x IN s /\ (P (s DELETE x) ==> P s)))
         ==> (!s. FINITE s ==> P s)
val HAS_SIZE : thm = |- !s n. s HAS_SIZE n <=> FINITE s /\ CARD s = n
val HAS_SIZE_CARD : thm = |- !s n. s HAS_SIZE n ==> CARD s = n
val HAS_SIZE_0 : thm = |- !s. s HAS_SIZE 0 <=> s = {}
val HAS_SIZE_SUC : thm =
  |- !s n.
         s HAS_SIZE SUC n <=>
         ~(s = {}) /\ (!a. a IN s ==> s DELETE a HAS_SIZE n)
val HAS_SIZE_UNION : thm =
  |- !s t m n.
         s HAS_SIZE m /\ t HAS_SIZE n /\ DISJOINT s t
         ==> s UNION t HAS_SIZE m + n
val HAS_SIZE_DIFF : thm =
  |- !s t m n.
         s HAS_SIZE m /\ t HAS_SIZE n /\ t SUBSET s
         ==> s DIFF t HAS_SIZE m - n
val HAS_SIZE_UNIONS : thm =
  |- !s t m n.
         s HAS_SIZE m /\
         (!x. x IN s ==> t x HAS_SIZE n) /\
         (!x y. x IN s /\ y IN s /\ ~(x = y) ==> DISJOINT (t x) (t y))
         ==> UNIONS {t x | x IN s} HAS_SIZE m * n
val FINITE_HAS_SIZE : thm = |- !s. FINITE s <=> s HAS_SIZE CARD s
val HAS_SIZE_CLAUSES : thm =
  |- (s HAS_SIZE 0 <=> s = {}) /\
     (s HAS_SIZE SUC n <=>
      (?a t. t HAS_SIZE n /\ ~(a IN t) /\ s = a INSERT t))
val CARD_SUBSET_EQ : thm =
  |- !a b. FINITE b /\ a SUBSET b /\ CARD a = CARD b ==> a = b
val CARD_SUBSET : thm = |- !a b. a SUBSET b /\ FINITE b ==> CARD a <= CARD b
val CARD_SUBSET_LE : thm =
  |- !a b. FINITE b /\ a SUBSET b /\ CARD b <= CARD a ==> a = b
val SUBSET_CARD_EQ : thm =
  |- !s t. FINITE t /\ s SUBSET t ==> (CARD s = CARD t <=> s = t)
val CARD_PSUBSET : thm = |- !a b. a PSUBSET b /\ FINITE b ==> CARD a < CARD b
val CARD_UNION_LE : thm =
  |- !s t. FINITE s /\ FINITE t ==> CARD (s UNION t) <= CARD s + CARD t
val CARD_UNIONS_LE : thm =
  |- !s t m n.
         s HAS_SIZE m /\ (!x. x IN s ==> FINITE (t x) /\ CARD (t x) <= n)
         ==> CARD (UNIONS {t x | x IN s}) <= m * n
val CARD_UNION_GEN : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> CARD (s UNION t) = (CARD s + CARD t) - CARD (s INTER t)
val CARD_UNION_OVERLAP_EQ : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> (CARD (s UNION t) = CARD s + CARD t <=> s INTER t = {})
val CARD_UNION_OVERLAP : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ CARD (s UNION t) < CARD s + CARD t
         ==> ~(s INTER t = {})
val CARD_IMAGE_INJ : thm =
  |- !f s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) /\ FINITE s
         ==> CARD (IMAGE f s) = CARD s
val HAS_SIZE_IMAGE_INJ : thm =
  |- !f s n.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) /\ s HAS_SIZE n
         ==> IMAGE f s HAS_SIZE n
val CARD_IMAGE_LE : thm = |- !f s. FINITE s ==> CARD (IMAGE f s) <= CARD s
val CARD_IMAGE_INJ_EQ : thm =
  |- !f s t.
         FINITE s /\
         (!x. x IN s ==> f x IN t) /\
         (!y. y IN t ==> (?!x. x IN s /\ f x = y))
         ==> CARD t = CARD s
val CARD_SUBSET_IMAGE : thm =
  |- !f s t. FINITE t /\ s SUBSET IMAGE f t ==> CARD s <= CARD t
val HAS_SIZE_IMAGE_INJ_EQ : thm =
  |- !f s n.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
         ==> (IMAGE f s HAS_SIZE n <=> s HAS_SIZE n)
val CARD_IMAGE_EQ_INJ : thm =
  |- !f s.
         FINITE s
         ==> (CARD (IMAGE f s) = CARD s <=>
              (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
val CHOOSE_SUBSET_STRONG : thm =
  |- !n s. (FINITE s ==> n <= CARD s) ==> (?t. t SUBSET s /\ t HAS_SIZE n)
val CHOOSE_SUBSET : thm =
  |- !s. FINITE s ==> (!n. n <= CARD s ==> (?t. t SUBSET s /\ t HAS_SIZE n))
val CHOOSE_SUBSET_BETWEEN : thm =
  |- !n s u.
         s SUBSET u /\ FINITE s /\ CARD s <= n /\ (FINITE u ==> n <= CARD u)
         ==> (?t. s SUBSET t /\ t SUBSET u /\ t HAS_SIZE n)
val HAS_SIZE_PRODUCT_DEPENDENT : thm =
  |- !s m t n.
         s HAS_SIZE m /\ (!x. x IN s ==> t x HAS_SIZE n)
         ==> {x,y | x IN s /\ y IN t x} HAS_SIZE m * n
val FINITE_PRODUCT_DEPENDENT : thm =
  |- !f s t.
         FINITE s /\ (!x. x IN s ==> FINITE (t x))
         ==> FINITE {f x y | x IN s /\ y IN t x}
val FINITE_PRODUCT : thm =
  |- !s t. FINITE s /\ FINITE t ==> FINITE {x,y | x IN s /\ y IN t}
val CARD_PRODUCT : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> CARD {x,y | x IN s /\ y IN t} = CARD s * CARD t
val HAS_SIZE_PRODUCT : thm =
  |- !s m t n.
         s HAS_SIZE m /\ t HAS_SIZE n
         ==> {x,y | x IN s /\ y IN t} HAS_SIZE m * n
val CROSS : thm = |- !s t. s CROSS t = {x,y | x IN s /\ y IN t}
val IN_CROSS : thm = |- !x y s t. x,y IN s CROSS t <=> x IN s /\ y IN t
val HAS_SIZE_CROSS : thm =
  |- !s t m n. s HAS_SIZE m /\ t HAS_SIZE n ==> s CROSS t HAS_SIZE m * n
val FINITE_CROSS : thm = |- !s t. FINITE s /\ FINITE t ==> FINITE (s CROSS t)
val CARD_CROSS : thm =
  |- !s t. FINITE s /\ FINITE t ==> CARD (s CROSS t) = CARD s * CARD t
val CROSS_EQ_EMPTY : thm = |- !s t. s CROSS t = {} <=> s = {} \/ t = {}
val CROSS_UNIV : thm = |- (:A) CROSS (:B) = (:A#B)
val HAS_SIZE_FUNSPACE : thm =
  |- !d n t m s.
         s HAS_SIZE m /\ t HAS_SIZE n
         ==> {f | (!x. x IN s ==> f x IN t) /\ (!x. ~(x IN s) ==> f x = d)} HAS_SIZE
             n EXP m
val CARD_FUNSPACE : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> CARD
             {f | (!x. x IN s ==> f x IN t) /\ (!x. ~(x IN s) ==> f x = d)} =
             CARD t EXP CARD s
val FINITE_FUNSPACE : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> FINITE
             {f | (!x. x IN s ==> f x IN t) /\ (!x. ~(x IN s) ==> f x = d)}
val HAS_SIZE_FUNSPACE_UNIV : thm =
  |- !m n. (:A) HAS_SIZE m /\ (:B) HAS_SIZE n ==> (:A->B) HAS_SIZE n EXP m
val CARD_FUNSPACE_UNIV : thm =
  |- FINITE (:A) /\ FINITE (:B) ==> CARD (:A->B) = CARD (:B) EXP CARD (:A)
val FINITE_FUNSPACE_UNIV : thm =
  |- FINITE (:A) /\ FINITE (:B) ==> FINITE (:A->B)
val HAS_SIZE_BOOL : thm = |- (:bool) HAS_SIZE 2
val CARD_BOOL : thm = |- CARD (:bool) = 2
val FINITE_BOOL : thm = |- FINITE (:bool)
val HAS_SIZE_POWERSET : thm =
  |- !s n. s HAS_SIZE n ==> {t | t SUBSET s} HAS_SIZE 2 EXP n
val CARD_POWERSET : thm =
  |- !s. FINITE s ==> CARD {t | t SUBSET s} = 2 EXP CARD s
val FINITE_POWERSET : thm = |- !s. FINITE s ==> FINITE {t | t SUBSET s}
val FINITE_UNIONS : thm =
  |- !s. FINITE (UNIONS s) <=> FINITE s /\ (!t. t IN s ==> FINITE t)
val POWERSET_CLAUSES : thm =
  |- {s | s SUBSET {}} = {{}} /\
     (!a t.
          {s | s SUBSET a INSERT t} =
          {s | s SUBSET t} UNION IMAGE (\s. a INSERT s) {s | s SUBSET t})
val HAS_SIZE_NUMSEG_LT : thm = |- !n. {m | m < n} HAS_SIZE n
val CARD_NUMSEG_LT : thm = |- !n. CARD {m | m < n} = n
val FINITE_NUMSEG_LT : thm = |- !n. FINITE {m | m < n}
val HAS_SIZE_NUMSEG_LE : thm = |- !n. {m | m <= n} HAS_SIZE n + 1
val FINITE_NUMSEG_LE : thm = |- !n. FINITE {m | m <= n}
val CARD_NUMSEG_LE : thm = |- !n. CARD {m | m <= n} = n + 1
val num_FINITE : thm = |- !s. FINITE s <=> (?a. !x. x IN s ==> x <= a)
val num_FINITE_AVOID : thm = |- !s. FINITE s ==> (?a. ~(a IN s))
val num_INFINITE : thm = |- INFINITE (:num)
val string_INFINITE : thm = |- INFINITE (:(char)list)
val FINITE_REAL_INTERVAL : thm =
  |- (!a. ~FINITE {x | a < x}) /\
     (!a. ~FINITE {x | a <= x}) /\
     (!b. ~FINITE {x | x < b}) /\
     (!b. ~FINITE {x | x <= b}) /\
     (!a b. FINITE {x | a < x /\ x < b} <=> b <= a) /\
     (!a b. FINITE {x | a <= x /\ x < b} <=> b <= a) /\
     (!a b. FINITE {x | a < x /\ x <= b} <=> b <= a) /\
     (!a b. FINITE {x | a <= x /\ x <= b} <=> b <= a)
val real_INFINITE : thm = |- INFINITE (:real)
val HAS_SIZE_INDEX : thm =
  |- !s n.
         s HAS_SIZE n
         ==> (?f. (!m. m < n ==> f m IN s) /\
                  (!x. x IN s ==> (?!m. m < n /\ f m = x)))
val INFINITE_ENUMERATE : thm =
  |- !s. INFINITE s
         ==> (?r. (!m n. m < n ==> r m < r n) /\ IMAGE r (:num) = s)
val set_of_list : thm =
  |- set_of_list [] = {} /\ set_of_list (CONS h t) = h INSERT set_of_list t
val list_of_set : thm =
  |- !s. list_of_set s = (@l. set_of_list l = s /\ LENGTH l = CARD s)
val LIST_OF_SET_PROPERTIES : thm =
  |- !s. FINITE s
         ==> set_of_list (list_of_set s) = s /\
             LENGTH (list_of_set s) = CARD s
val SET_OF_LIST_OF_SET : thm =
  |- !s. FINITE s ==> set_of_list (list_of_set s) = s
val LENGTH_LIST_OF_SET : thm =
  |- !s. FINITE s ==> LENGTH (list_of_set s) = CARD s
val MEM_LIST_OF_SET : thm =
  |- !s. FINITE s ==> (!x. MEM x (list_of_set s) <=> x IN s)
val FINITE_SET_OF_LIST : thm = |- !l. FINITE (set_of_list l)
val IN_SET_OF_LIST : thm = |- !x l. x IN set_of_list l <=> MEM x l
val SET_OF_LIST_APPEND : thm =
  |- !l1 l2. set_of_list (APPEND l1 l2) = set_of_list l1 UNION set_of_list l2
val SET_OF_LIST_MAP : thm =
  |- !f l. set_of_list (MAP f l) = IMAGE f (set_of_list l)
val SET_OF_LIST_EQ_EMPTY : thm = |- !l. set_of_list l = {} <=> l = []
val LIST_OF_SET_EMPTY : thm = |- list_of_set {} = []
val LIST_OF_SET_SING : thm = |- !x. list_of_set {a} = [a]
val pairwise : thm =
  |- !s r. pairwise r s <=> (!x y. x IN s /\ y IN s /\ ~(x = y) ==> r x y)
val PAIRWISE : thm =
  |- (PAIRWISE r [] <=> T) /\
     (PAIRWISE r (CONS h t) <=> ALL (r h) t /\ PAIRWISE r t)
val PAIRWISE_EMPTY : thm = |- !r. pairwise r {} <=> T
val PAIRWISE_SING : thm = |- !r x. pairwise r {x} <=> T
val PAIRWISE_MONO : thm =
  |- !r s t. pairwise r s /\ t SUBSET s ==> pairwise r t
val PAIRWISE_INSERT : thm =
  |- !r x s.
         pairwise r (x INSERT s) <=>
         (!y. y IN s /\ ~(y = x) ==> r x y /\ r y x) /\ pairwise r s
val PAIRWISE_IMAGE : thm =
  |- !r f.
         pairwise r (IMAGE f s) <=>
         pairwise (\x y. ~(f x = f y) ==> r (f x) (f y)) s
val CARD_SET_OF_LIST_LE : thm = |- !l. CARD (set_of_list l) <= LENGTH l
val HAS_SIZE_SET_OF_LIST : thm =
  |- !l. set_of_list l HAS_SIZE LENGTH l <=> PAIRWISE (\x y. ~(x = y)) l
val SURJECTIVE_IFF_INJECTIVE_GEN : thm =
  |- !s t f.
         FINITE s /\ FINITE t /\ CARD s = CARD t /\ IMAGE f s SUBSET t
         ==> ((!y. y IN t ==> (?x. x IN s /\ f x = y)) <=>
              (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
val SURJECTIVE_IFF_INJECTIVE : thm =
  |- !s f.
         FINITE s /\ IMAGE f s SUBSET s
         ==> ((!y. y IN s ==> (?x. x IN s /\ f x = y)) <=>
              (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
val IMAGE_IMP_INJECTIVE_GEN : thm =
  |- !s t f.
         FINITE s /\ CARD s = CARD t /\ IMAGE f s = t
         ==> (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
val IMAGE_IMP_INJECTIVE : thm =
  |- !s f.
         FINITE s /\ IMAGE f s = s
         ==> (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
val CARD_LE_INJ : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ CARD s <= CARD t
         ==> (?f. IMAGE f s SUBSET t /\
                  (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
val FORALL_IN_CLAUSES : thm =
  |- (!P. (!x. x IN {} ==> P x) <=> T) /\
     (!P a s. (!x. x IN a INSERT s ==> P x) <=> P a /\ (!x. x IN s ==> P x))
val EXISTS_IN_CLAUSES : thm =
  |- (!P. (?x. x IN {} /\ P x) <=> F) /\
     (!P a s. (?x. x IN a INSERT s /\ P x) <=> P a \/ (?x. x IN s /\ P x))
val INJECTIVE_ON_IMAGE : thm =
  |- !f u.
         (!s t. s SUBSET u /\ t SUBSET u /\ IMAGE f s = IMAGE f t ==> s = t) <=>
         (!x y. x IN u /\ y IN u /\ f x = f y ==> x = y)
val INJECTIVE_IMAGE : thm =
  |- !f. (!s t. IMAGE f s = IMAGE f t ==> s = t) <=>
         (!x y. f x = f y ==> x = y)
val SURJECTIVE_ON_IMAGE : thm =
  |- !f u v.
         (!t. t SUBSET v ==> (?s. s SUBSET u /\ IMAGE f s = t)) <=>
         (!y. y IN v ==> (?x. x IN u /\ f x = y))
val SURJECTIVE_IMAGE : thm =
  |- !f. (!t. ?s. IMAGE f s = t) <=> (!y. ?x. f x = y)
val CARD_EQ_BIJECTION : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ CARD s = CARD t
         ==> (?f. (!x. x IN s ==> f x IN t) /\
                  (!y. y IN t ==> (?x. x IN s /\ f x = y)) /\
                  (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
val CARD_EQ_BIJECTIONS : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ CARD s = CARD t
         ==> (?f g.
                  (!x. x IN s ==> f x IN t /\ g (f x) = x) /\
                  (!y. y IN t ==> g y IN s /\ f (g y) = y))
val BIJECTIONS_HAS_SIZE : thm =
  |- !s t f g.
         (!x. x IN s ==> f x IN t /\ g (f x) = x) /\
         (!y. y IN t ==> g y IN s /\ f (g y) = y) /\
         s HAS_SIZE n
         ==> t HAS_SIZE n
val BIJECTIONS_HAS_SIZE_EQ : thm =
  |- !s t f g.
         (!x. x IN s ==> f x IN t /\ g (f x) = x) /\
         (!y. y IN t ==> g y IN s /\ f (g y) = y)
         ==> (!n. s HAS_SIZE n <=> t HAS_SIZE n)
val BIJECTIONS_CARD_EQ : thm =
  |- !s t f g.
         (FINITE s \/ FINITE t) /\
         (!x. x IN s ==> f x IN t /\ g (f x) = x) /\
         (!y. y IN t ==> g y IN s /\ f (g y) = y)
         ==> CARD s = CARD t
val WF_FINITE : thm =
  |- !(<<). (!x. ~(x << x)) /\
            (!x y z. x << y /\ y << z ==> x << z) /\
            (!x. FINITE {y | y << x})
            ==> WF (<<)
val le_c : thm =
  |- !t s.
         s <=_c t <=>
         (?f. (!x. x IN s ==> f x IN t) /\
              (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
val lt_c : thm = |- !t s. s <_c t <=> s <=_c t /\ ~(t <=_c s)
val eq_c : thm =
  |- !t s.
         s =_c t <=>
         (?f. (!x. x IN s ==> f x IN t) /\
              (!y. y IN t ==> (?!x. x IN s /\ f x = y)))
val ge_c : thm = |- !t s. s >=_c t <=> t <=_c s
val gt_c : thm = |- !t s. s >_c t <=> t <_c s
val LE_C : thm =
  |- !s t. s <=_c t <=> (?g. !x. x IN s ==> (?y. y IN t /\ g y = x))
val GE_C : thm =
  |- !s t. s >=_c t <=> (?f. !y. y IN t ==> (?x. x IN s /\ y = f x))
val COUNTABLE : thm = |- !t. COUNTABLE t <=> (:num) >=_c t
val sup : thm =
  |- !s. sup s =
         (@a. (!x. x IN s ==> x <= a) /\
              (!b. (!x. x IN s ==> x <= b) ==> a <= b))
val SUP_EQ : thm =
  |- !s t.
         (!b. (!x. x IN s ==> x <= b) <=> (!x. x IN t ==> x <= b))
         ==> sup s = sup t
val SUP : thm =
  |- !s. ~(s = {}) /\ (?b. !x. x IN s ==> x <= b)
         ==> (!x. x IN s ==> x <= sup s) /\
             (!b. (!x. x IN s ==> x <= b) ==> sup s <= b)
val SUP_FINITE_LEMMA : thm =
  |- !s. FINITE s /\ ~(s = {}) ==> (?b. b IN s /\ (!x. x IN s ==> x <= b))
val SUP_FINITE : thm =
  |- !s. FINITE s /\ ~(s = {}) ==> sup s IN s /\ (!x. x IN s ==> x <= sup s)
val REAL_LE_SUP_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (a <= sup s <=> (?x. x IN s /\ a <= x))
val REAL_SUP_LE_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (sup s <= a <=> (!x. x IN s ==> x <= a))
val REAL_LT_SUP_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (a < sup s <=> (?x. x IN s /\ a < x))
val REAL_SUP_LT_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (sup s < a <=> (!x. x IN s ==> x < a))
val REAL_SUP_UNIQUE : thm =
  |- !s b.
         (!x. x IN s ==> x <= b) /\ (!b'. b' < b ==> (?x. x IN s /\ b' < x))
         ==> sup s = b
val REAL_SUP_LE : thm =
  |- !b. ~(s = {}) /\ (!x. x IN s ==> x <= b) ==> sup s <= b
val REAL_SUP_LE_SUBSET : thm =
  |- !s t.
         ~(s = {}) /\ s SUBSET t /\ (?b. !x. x IN t ==> x <= b)
         ==> sup s <= sup t
val REAL_SUP_BOUNDS : thm =
  |- !s a b.
         ~(s = {}) /\ (!x. x IN s ==> a <= x /\ x <= b)
         ==> a <= sup s /\ sup s <= b
val REAL_ABS_SUP_LE : thm =
  |- !s a. ~(s = {}) /\ (!x. x IN s ==> abs x <= a) ==> abs (sup s) <= a
val REAL_SUP_ASCLOSE : thm =
  |- !s l e.
         ~(s = {}) /\ (!x. x IN s ==> abs (x - l) <= e)
         ==> abs (sup s - l) <= e
val inf : thm =
  |- !s. inf s =
         (@a. (!x. x IN s ==> a <= x) /\
              (!b. (!x. x IN s ==> b <= x) ==> b <= a))
val INF_EQ : thm =
  |- !s t.
         (!a. (!x. x IN s ==> a <= x) <=> (!x. x IN t ==> a <= x))
         ==> inf s = inf t
val INF : thm =
  |- !s. ~(s = {}) /\ (?b. !x. x IN s ==> b <= x)
         ==> (!x. x IN s ==> inf s <= x) /\
             (!b. (!x. x IN s ==> b <= x) ==> b <= inf s)
val INF_FINITE_LEMMA : thm =
  |- !s. FINITE s /\ ~(s = {}) ==> (?b. b IN s /\ (!x. x IN s ==> b <= x))
val INF_FINITE : thm =
  |- !s. FINITE s /\ ~(s = {}) ==> inf s IN s /\ (!x. x IN s ==> inf s <= x)
val REAL_LE_INF_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (a <= inf s <=> (!x. x IN s ==> a <= x))
val REAL_INF_LE_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (inf s <= a <=> (?x. x IN s /\ x <= a))
val REAL_LT_INF_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (a < inf s <=> (!x. x IN s ==> a < x))
val REAL_INF_LT_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (inf s < a <=> (?x. x IN s /\ x < a))
val REAL_INF_UNIQUE : thm =
  |- !s b.
         (!x. x IN s ==> b <= x) /\ (!b'. b < b' ==> (?x. x IN s /\ x < b'))
         ==> inf s = b
val REAL_LE_INF : thm =
  |- !b. ~(s = {}) /\ (!x. x IN s ==> b <= x) ==> b <= inf s
val REAL_LE_INF_SUBSET : thm =
  |- !s t.
         ~(t = {}) /\ t SUBSET s /\ (?b. !x. x IN s ==> b <= x)
         ==> inf s <= inf t
val REAL_INF_BOUNDS : thm =
  |- !s a b.
         ~(s = {}) /\ (!x. x IN s ==> a <= x /\ x <= b)
         ==> a <= inf s /\ inf s <= b
val REAL_ABS_INF_LE : thm =
  |- !s a. ~(s = {}) /\ (!x. x IN s ==> abs x <= a) ==> abs (inf s) <= a
val REAL_INF_ASCLOSE : thm =
  |- !s l e.
         ~(s = {}) /\ (!x. x IN s ==> abs (x - l) <= e)
         ==> abs (inf s - l) <= e
val SUP_UNIQUE_FINITE : thm =
  |- !s. FINITE s /\ ~(s = {})
         ==> (sup s = a <=> a IN s /\ (!y. y IN s ==> y <= a))
val INF_UNIQUE_FINITE : thm =
  |- !s. FINITE s /\ ~(s = {})
         ==> (inf s = a <=> a IN s /\ (!y. y IN s ==> a <= y))
val SUP_INSERT_FINITE : thm =
  |- !x s.
         FINITE s
         ==> sup (x INSERT s) = (if s = {} then x else max x (sup s))
val SUP_SING : thm = |- !a. sup {a} = a
val INF_INSERT_FINITE : thm =
  |- !x s.
         FINITE s
         ==> inf (x INSERT s) = (if s = {} then x else min x (inf s))
val INF_SING : thm = |- !a. inf {a} = a
val REAL_SUP_EQ_INF : thm =
  |- !s. ~(s = {}) /\ (?B. !x. x IN s ==> abs x <= B)
         ==> (sup s = inf s <=> (?a. s = {a}))
val REAL_LE_SUP : thm =
  |- !s a b y. y IN s /\ a <= y /\ (!x. x IN s ==> x <= b) ==> a <= sup s
val REAL_INF_LE : thm =
  |- !s a b y. y IN s /\ y <= b /\ (!x. x IN s ==> a <= x) ==> inf s <= b
val REAL_SUP_LE_EQ : thm =
  |- !s y.
         ~(s = {}) /\ (?b. !x. x IN s ==> x <= b)
         ==> (sup s <= y <=> (!x. x IN s ==> x <= y))
val REAL_LE_INF_EQ : thm =
  |- !s t.
         ~(s = {}) /\ (?b. !x. x IN s ==> b <= x)
         ==> (y <= inf s <=> (!x. x IN s ==> y <= x))
val SUP_UNIQUE : thm =
  |- !s b. (!c. (!x. x IN s ==> x <= c) <=> b <= c) ==> sup s = b
val INF_UNIQUE : thm =
  |- !s b. (!c. (!x. x IN s ==> c <= x) <=> c <= b) ==> inf s = b
val SUP_UNION : thm =
  |- !s t.
         ~(s = {}) /\
         ~(t = {}) /\
         (?b. !x. x IN s ==> x <= b) /\
         (?c. !x. x IN t ==> x <= c)
         ==> sup (s UNION t) = max (sup s) (sup t)
val INF_UNION : thm =
  |- !s t.
         ~(s = {}) /\
         ~(t = {}) /\
         (?b. !x. x IN s ==> b <= x) /\
         (?c. !x. x IN t ==> c <= x)
         ==> inf (s UNION t) = min (inf s) (inf t)
val numseg : thm = |- !m n. m..n = {x | m <= x /\ x <= n}
val FINITE_NUMSEG : thm = |- !m n. FINITE (m..n)
val NUMSEG_COMBINE_R : thm =
  |- !m p n. m <= p + 1 /\ p <= n ==> (m..p) UNION (p + 1..n) = m..n
val NUMSEG_COMBINE_L : thm =
  |- !m p n. m <= p /\ p <= n + 1 ==> (m..p - 1) UNION (p..n) = m..n
val NUMSEG_LREC : thm = |- !m n. m <= n ==> m INSERT (m + 1..n) = m..n
val NUMSEG_RREC : thm = |- !m n. m <= n ==> n INSERT (m..n - 1) = m..n
val NUMSEG_REC : thm = |- !m n. m <= SUC n ==> m..SUC n = SUC n INSERT (m..n)
val IN_NUMSEG : thm = |- !m n p. p IN m..n <=> m <= p /\ p <= n
val IN_NUMSEG_0 : thm = |- !m n. m IN 0..n <=> m <= n
val NUMSEG_SING : thm = |- !n. n..n = {n}
val NUMSEG_EMPTY : thm = |- !m n. m..n = {} <=> n < m
val CARD_NUMSEG_LEMMA : thm = |- !m d. CARD (m..m + d) = d + 1
val CARD_NUMSEG : thm = |- !m n. CARD (m..n) = (n + 1) - m
val HAS_SIZE_NUMSEG : thm = |- !m n. m..n HAS_SIZE (n + 1) - m
val CARD_NUMSEG_1 : thm = |- !n. CARD (1..n) = n
val HAS_SIZE_NUMSEG_1 : thm = |- !n. 1..n HAS_SIZE n
val NUMSEG_CLAUSES : thm =
  |- (!m. m..0 = (if m = 0 then {0} else {})) /\
     (!m n. m..SUC n = (if m <= SUC n then SUC n INSERT (m..n) else m..n))
val FINITE_INDEX_NUMSEG : thm =
  |- !s. FINITE s <=>
         (?f. (!i j. i IN 1..CARD s /\ j IN 1..CARD s /\ f i = f j ==> i = j) /\
              s = IMAGE f (1..CARD s))
val FINITE_INDEX_NUMBERS : thm =
  |- !s. FINITE s <=>
         (?k f.
              (!i j. i IN k /\ j IN k /\ f i = f j ==> i = j) /\
              FINITE k /\
              s = IMAGE f k)
val DISJOINT_NUMSEG : thm =
  |- !m n p q. DISJOINT (m..n) (p..q) <=> n < p \/ q < m \/ n < m \/ q < p
val NUMSEG_ADD_SPLIT : thm =
  |- !m n p. m <= n + 1 ==> m..n + p = (m..n) UNION (n + 1..n + p)
val NUMSEG_OFFSET_IMAGE : thm =
  |- !m n p. m + p..n + p = IMAGE (\i. i + p) (m..n)
val SUBSET_NUMSEG : thm =
  |- !m n p q. m..n SUBSET p..q <=> n < m \/ p <= m /\ n <= q
val NUMSEG_LE : thm = |- !n. {x | x <= n} = 0..n
val NUMSEG_LT : thm = |- !n. {x | x < n} = (if n = 0 then {} else 0..n - 1)
val TOPOLOGICAL_SORT : thm =
  |- !(<<). (!x y. x << y /\ y << x ==> x = y) /\
            (!x y z. x << y /\ y << z ==> x << z)
            ==> (!n s.
                     s HAS_SIZE n
                     ==> (?f. s = IMAGE f (1..n) /\
                              (!j k.
                                   j IN 1..n /\ k IN 1..n /\ j < k
                                   ==> ~(f k << f j))))
val FINITE_INTSEG : thm =
  |- (!l r. FINITE {x | l <= x /\ x <= r}) /\
     (!l r. FINITE {x | l <= x /\ x < r}) /\
     (!l r. FINITE {x | l < x /\ x <= r}) /\
     (!l r. FINITE {x | l < x /\ x < r})
val neutral : thm = |- !op. neutral op = (@x. !y. op x y = y /\ op y x = y)
val monoidal : thm =
  |- !op. monoidal op <=>
          (!x y. op x y = op y x) /\
          (!x y z. op x (op y z) = op (op x y) z) /\
          (!x. op (neutral op) x = x)
val MONOIDAL_AC : thm =
  |- !op. monoidal op
          ==> (!a. op (neutral op) a = a) /\
              (!a. op a (neutral op) = a) /\
              (!a b. op a b = op b a) /\
              (!a b c. op (op a b) c = op a (op b c)) /\
              (!a b c. op a (op b c) = op b (op a c))
val support : thm =
  |- !s f op. support op f s = {x | x IN s /\ ~(f x = neutral op)}
val iterate : thm =
  |- !f s op.
         iterate op s f =
         (if FINITE (support op f s)
          then ITSET (\x a. op (f x) a) (support op f s) (neutral op)
          else neutral op)
val IN_SUPPORT : thm =
  |- !op f x s. x IN support op f s <=> x IN s /\ ~(f x = neutral op)
val SUPPORT_SUPPORT : thm =
  |- !op f s. support op f (support op f s) = support op f s
val SUPPORT_EMPTY : thm =
  |- !op f s. (!x. x IN s ==> f x = neutral op) <=> support op f s = {}
val SUPPORT_SUBSET : thm = |- !op f s. support op f s SUBSET s
val FINITE_SUPPORT : thm = |- !op f s. FINITE s ==> FINITE (support op f s)
val SUPPORT_CLAUSES : thm =
  |- (!f. support op f {} = {}) /\
     (!f x s.
          support op f (x INSERT s) =
          (if f x = neutral op
           then support op f s
           else x INSERT support op f s)) /\
     (!f x s. support op f (s DELETE x) = support op f s DELETE x) /\
     (!f s t. support op f (s UNION t) = support op f s UNION support op f t) /\
     (!f s t. support op f (s INTER t) = support op f s INTER support op f t) /\
     (!f s t. support op f (s DIFF t) = support op f s DIFF support op f t) /\
     (!f g s. support op g (IMAGE f s) = IMAGE f (support op (g o f) s))
val SUPPORT_DELTA : thm =
  |- !op s f a.
         support op (\x. if x = a then f x else neutral op) s =
         (if a IN s then support op f {a} else {})
val FINITE_SUPPORT_DELTA : thm =
  |- !op f a. FINITE (support op (\x. if x = a then f x else neutral op) s)
val ITERATE_SUPPORT : thm =
  |- !op f s. iterate op (support op f s) f = iterate op s f
val ITERATE_EXPAND_CASES : thm =
  |- !op f s.
         iterate op s f =
         (if FINITE (support op f s)
          then iterate op (support op f s) f
          else neutral op)
val ITERATE_CLAUSES_GEN : thm =
  |- !op. monoidal op
          ==> (!f. iterate op {} f = neutral op) /\
              (!f x s.
                   monoidal op /\ FINITE (support op f s)
                   ==> iterate op (x INSERT s) f =
                       (if x IN s
                        then iterate op s f
                        else op (f x) (iterate op s f)))
val ITERATE_CLAUSES : thm =
  |- !op. monoidal op
          ==> (!f. iterate op {} f = neutral op) /\
              (!f x s.
                   FINITE s
                   ==> iterate op (x INSERT s) f =
                       (if x IN s
                        then iterate op s f
                        else op (f x) (iterate op s f)))
val ITERATE_UNION : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE s /\ FINITE t /\ DISJOINT s t
                   ==> iterate op (s UNION t) f =
                       op (iterate op s f) (iterate op t f))
val ITERATE_UNION_GEN : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE (support op f s) /\
                   FINITE (support op f t) /\
                   DISJOINT (support op f s) (support op f t)
                   ==> iterate op (s UNION t) f =
                       op (iterate op s f) (iterate op t f))
val ITERATE_DIFF : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE s /\ t SUBSET s
                   ==> op (iterate op (s DIFF t) f) (iterate op t f) =
                       iterate op s f)
val ITERATE_DIFF_GEN : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE (support op f s) /\
                   support op f t SUBSET support op f s
                   ==> op (iterate op (s DIFF t) f) (iterate op t f) =
                       iterate op s f)
val ITERATE_INCL_EXCL : thm =
  |- !op. monoidal op
          ==> (!s t f.
                   FINITE s /\ FINITE t
                   ==> op (iterate op s f) (iterate op t f) =
                       op (iterate op (s UNION t) f)
                       (iterate op (s INTER t) f))
val ITERATE_CLOSED : thm =
  |- !op. monoidal op
          ==> (!P. P (neutral op) /\ (!x y. P x /\ P y ==> P (op x y))
                   ==> (!f s.
                            (!x. x IN s /\ ~(f x = neutral op) ==> P (f x))
                            ==> P (iterate op s f)))
val ITERATE_RELATED : thm =
  |- !op. monoidal op
          ==> (!R. R (neutral op) (neutral op) /\
                   (!x1 y1 x2 y2.
                        R x1 x2 /\ R y1 y2 ==> R (op x1 y1) (op x2 y2))
                   ==> (!f g s.
                            FINITE s /\ (!x. x IN s ==> R (f x) (g x))
                            ==> R (iterate op s f) (iterate op s g)))
val ITERATE_EQ_NEUTRAL : thm =
  |- !op. monoidal op
          ==> (!f s.
                   (!x. x IN s ==> f x = neutral op)
                   ==> iterate op s f = neutral op)
val ITERATE_SING : thm =
  |- !op. monoidal op ==> (!f x. iterate op {x} f = f x)
val ITERATE_DELETE : thm =
  |- !op. monoidal op
          ==> (!f s a.
                   FINITE s /\ a IN s
                   ==> op (f a) (iterate op (s DELETE a) f) = iterate op s f)
val ITERATE_DELTA : thm =
  |- !op. monoidal op
          ==> (!f a s.
                   iterate op s (\x. if x = a then f x else neutral op) =
                   (if a IN s then f a else neutral op))
val ITERATE_IMAGE : thm =
  |- !op. monoidal op
          ==> (!f g s.
                   (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
                   ==> iterate op (IMAGE f s) g = iterate op s (g o f))
val ITERATE_BIJECTION : thm =
  |- !op. monoidal op
          ==> (!f p s.
                   (!x. x IN s ==> p x IN s) /\
                   (!y. y IN s ==> (?!x. x IN s /\ p x = y))
                   ==> iterate op s f = iterate op s (f o p))
val ITERATE_ITERATE_PRODUCT : thm =
  |- !op. monoidal op
          ==> (!s t x.
                   FINITE s /\ (!i. i IN s ==> FINITE (t i))
                   ==> iterate op s (\i. iterate op (t i) (x i)) =
                       iterate op {i,j | i IN s /\ j IN t i} (\(i,j). x i j))
val ITERATE_EQ : thm =
  |- !op. monoidal op
          ==> (!f g s.
                   (!x. x IN s ==> f x = g x)
                   ==> iterate op s f = iterate op s g)
val ITERATE_EQ_GENERAL : thm =
  |- !op. monoidal op
          ==> (!s t f g h.
                   (!y. y IN t ==> (?!x. x IN s /\ h x = y)) /\
                   (!x. x IN s ==> h x IN t /\ g (h x) = f x)
                   ==> iterate op s f = iterate op t g)
val ITERATE_EQ_GENERAL_INVERSES : thm =
  |- !op. monoidal op
          ==> (!s t f g h k.
                   (!y. y IN t ==> k y IN s /\ h (k y) = y) /\
                   (!x. x IN s ==> h x IN t /\ k (h x) = x /\ g (h x) = f x)
                   ==> iterate op s f = iterate op t g)
val ITERATE_INJECTION : thm =
  |- !op. monoidal op
          ==> (!f p s.
                   FINITE s /\
                   (!x. x IN s ==> p x IN s) /\
                   (!x y. x IN s /\ y IN s /\ p x = p y ==> x = y)
                   ==> iterate op s (f o p) = iterate op s f)
val ITERATE_UNION_NONZERO : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE s /\
                   FINITE t /\
                   (!x. x IN s INTER t ==> f x = neutral op)
                   ==> iterate op (s UNION t) f =
                       op (iterate op s f) (iterate op t f))
val ITERATE_OP : thm =
  |- !op. monoidal op
          ==> (!f g s.
                   FINITE s
                   ==> iterate op s (\x. op (f x) (g x)) =
                       op (iterate op s f) (iterate op s g))
val ITERATE_SUPERSET : thm =
  |- !op. monoidal op
          ==> (!f u v.
                   u SUBSET v /\
                   (!x. x IN v /\ ~(x IN u) ==> f x = neutral op)
                   ==> iterate op v f = iterate op u f)
val ITERATE_IMAGE_NONZERO : thm =
  |- !op. monoidal op
          ==> (!g f s.
                   FINITE s /\
                   (!x y.
                        x IN s /\ y IN s /\ ~(x = y) /\ f x = f y
                        ==> g (f x) = neutral op)
                   ==> iterate op (IMAGE f s) g = iterate op s (g o f))
val ITERATE_CASES : thm =
  |- !op. monoidal op
          ==> (!s P f g.
                   FINITE s
                   ==> iterate op s (\x. if P x then f x else g x) =
                       op (iterate op {x | x IN s /\ P x} f)
                       (iterate op {x | x IN s /\ ~P x} g))
val ITERATE_OP_GEN : thm =
  |- !op. monoidal op
          ==> (!f g s.
                   FINITE (support op f s) /\ FINITE (support op g s)
                   ==> iterate op s (\x. op (f x) (g x)) =
                       op (iterate op s f) (iterate op s g))
val ITERATE_CLAUSES_NUMSEG : thm =
  |- !op. monoidal op
          ==> (!m. iterate op (m..0) f = (if m = 0 then f 0 else neutral op)) /\
              (!m n.
                   iterate op (m..SUC n) f =
                   (if m <= SUC n
                    then op (iterate op (m..n) f) (f (SUC n))
                    else iterate op (m..n) f))
val ITERATE_PAIR : thm =
  |- !op. monoidal op
          ==> (!f m n.
                   iterate op (2 * m..2 * n + 1) f =
                   iterate op (m..n) (\i. op (f (2 * i)) (f (2 * i + 1))))
val nsum : thm = |- nsum = iterate (+)
val NEUTRAL_ADD : thm = |- neutral (+) = 0
val NEUTRAL_MUL : thm = |- neutral (*) = 1
val MONOIDAL_ADD : thm = |- monoidal (+)
val MONOIDAL_MUL : thm = |- monoidal (*)
val NSUM_DEGENERATE : thm =
  |- !f s. ~FINITE {x | x IN s /\ ~(f x = 0)} ==> nsum s f = 0
val NSUM_CLAUSES : thm =
  |- (!f. nsum {} f = 0) /\
     (!x f s.
          FINITE s
          ==> nsum (x INSERT s) f =
              (if x IN s then nsum s f else f x + nsum s f))
val NSUM_UNION : thm =
  |- !f s t.
         FINITE s /\ FINITE t /\ DISJOINT s t
         ==> nsum (s UNION t) f = nsum s f + nsum t f
val NSUM_DIFF : thm =
  |- !f s t.
         FINITE s /\ t SUBSET s ==> nsum (s DIFF t) f = nsum s f - nsum t f
val NSUM_INCL_EXCL : thm =
  |- !s t f.
         FINITE s /\ FINITE t
         ==> nsum s f + nsum t f = nsum (s UNION t) f + nsum (s INTER t) f
val NSUM_SUPPORT : thm = |- !f s. nsum (support (+) f s) f = nsum s f
val NSUM_ADD : thm =
  |- !f g s. FINITE s ==> nsum s (\x. f x + g x) = nsum s f + nsum s g
val NSUM_ADD_GEN : thm =
  |- !f g s.
         FINITE {x | x IN s /\ ~(f x = 0)} /\
         FINITE {x | x IN s /\ ~(g x = 0)}
         ==> nsum s (\x. f x + g x) = nsum s f + nsum s g
val NSUM_EQ_0 : thm = |- !f s. (!x. x IN s ==> f x = 0) ==> nsum s f = 0
val NSUM_0 : thm = |- !s. nsum s (\n. 0) = 0
val NSUM_LMUL : thm = |- !f c s. nsum s (\x. c * f x) = c * nsum s f
val NSUM_RMUL : thm = |- !f c s. nsum s (\x. f x * c) = nsum s f * c
val NSUM_LE : thm =
  |- !f g s. FINITE s /\ (!x. x IN s ==> f x <= g x) ==> nsum s f <= nsum s g
val NSUM_LT : thm =
  |- !f g s.
         FINITE s /\ (!x. x IN s ==> f x <= g x) /\ (?x. x IN s /\ f x < g x)
         ==> nsum s f < nsum s g
val NSUM_LT_ALL : thm =
  |- !f g s.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < g x)
         ==> nsum s f < nsum s g
val NSUM_EQ : thm =
  |- !f g s. (!x. x IN s ==> f x = g x) ==> nsum s f = nsum s g
val NSUM_CONST : thm = |- !c s. FINITE s ==> nsum s (\n. c) = CARD s * c
val NSUM_POS_BOUND : thm =
  |- !f b s. FINITE s /\ nsum s f <= b ==> (!x. x IN s ==> f x <= b)
val NSUM_EQ_0_IFF : thm =
  |- !s. FINITE s ==> (nsum s f = 0 <=> (!x. x IN s ==> f x = 0))
val NSUM_POS_LT : thm =
  |- !f s. FINITE s /\ (?x. x IN s /\ 0 < f x) ==> 0 < nsum s f
val NSUM_POS_LT_ALL : thm =
  |- !s f. FINITE s /\ ~(s = {}) /\ (!i. i IN s ==> 0 < f i) ==> 0 < nsum s f
val NSUM_DELETE : thm =
  |- !f s a. FINITE s /\ a IN s ==> f a + nsum (s DELETE a) f = nsum s f
val NSUM_SING : thm = |- !f x. nsum {x} f = f x
val NSUM_DELTA : thm =
  |- !s a. nsum s (\x. if x = a then b else 0) = (if a IN s then b else 0)
val NSUM_SWAP : thm =
  |- !f s t.
         FINITE s /\ FINITE t
         ==> nsum s (\i. nsum t (f i)) = nsum t (\j. nsum s (\i. f i j))
val NSUM_IMAGE : thm =
  |- !f g s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
         ==> nsum (IMAGE f s) g = nsum s (g o f)
val NSUM_SUPERSET : thm =
  |- !f u v.
         u SUBSET v /\ (!x. x IN v /\ ~(x IN u) ==> f x = 0)
         ==> nsum v f = nsum u f
val NSUM_UNION_RZERO : thm =
  |- !f u v.
         FINITE u /\ (!x. x IN v /\ ~(x IN u) ==> f x = 0)
         ==> nsum (u UNION v) f = nsum u f
val NSUM_UNION_LZERO : thm =
  |- !f u v.
         FINITE v /\ (!x. x IN u /\ ~(x IN v) ==> f x = 0)
         ==> nsum (u UNION v) f = nsum v f
val NSUM_RESTRICT : thm =
  |- !f s. FINITE s ==> nsum s (\x. if x IN s then f x else 0) = nsum s f
val NSUM_BOUND : thm =
  |- !s f b. FINITE s /\ (!x. x IN s ==> f x <= b) ==> nsum s f <= CARD s * b
val NSUM_BOUND_GEN : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x <= b DIV CARD s)
         ==> nsum s f <= b
val NSUM_BOUND_LT : thm =
  |- !s f b.
         FINITE s /\ (!x. x IN s ==> f x <= b) /\ (?x. x IN s /\ f x < b)
         ==> nsum s f < CARD s * b
val NSUM_BOUND_LT_ALL : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < b)
         ==> nsum s f < CARD s * b
val NSUM_BOUND_LT_GEN : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < b DIV CARD s)
         ==> nsum s f < b
val NSUM_UNION_EQ : thm =
  |- !s t u.
         FINITE u /\ s INTER t = {} /\ s UNION t = u
         ==> nsum s f + nsum t f = nsum u f
val NSUM_EQ_SUPERSET : thm =
  |- !f s t.
         FINITE t /\
         t SUBSET s /\
         (!x. x IN t ==> f x = g x) /\
         (!x. x IN s /\ ~(x IN t) ==> f x = 0)
         ==> nsum s f = nsum t g
val NSUM_RESTRICT_SET : thm =
  |- !P s f. nsum {x | x IN s /\ P x} f = nsum s (\x. if P x then f x else 0)
val NSUM_NSUM_RESTRICT : thm =
  |- !R f s t.
         FINITE s /\ FINITE t
         ==> nsum s (\x. nsum {y | y IN t /\ R x y} (\y. f x y)) =
             nsum t (\y. nsum {x | x IN s /\ R x y} (\x. f x y))
val CARD_EQ_NSUM : thm = |- !s. FINITE s ==> CARD s = nsum s (\x. 1)
val NSUM_MULTICOUNT_GEN : thm =
  |- !R s t k.
         FINITE s /\
         FINITE t /\
         (!j. j IN t ==> CARD {i | i IN s /\ R i j} = k j)
         ==> nsum s (\i. CARD {j | j IN t /\ R i j}) = nsum t (\i. k i)
val NSUM_MULTICOUNT : thm =
  |- !R s t k.
         FINITE s /\
         FINITE t /\
         (!j. j IN t ==> CARD {i | i IN s /\ R i j} = k)
         ==> nsum s (\i. CARD {j | j IN t /\ R i j}) = k * CARD t
val NSUM_IMAGE_GEN : thm =
  |- !f g s.
         FINITE s
         ==> nsum s g = nsum (IMAGE f s) (\y. nsum {x | x IN s /\ f x = y} g)
val NSUM_GROUP : thm =
  |- !f g s t.
         FINITE s /\ IMAGE f s SUBSET t
         ==> nsum t (\y. nsum {x | x IN s /\ f x = y} g) = nsum s g
val NSUM_SUBSET : thm =
  |- !u v f.
         FINITE u /\ FINITE v /\ (!x. x IN u DIFF v ==> f x = 0)
         ==> nsum u f <= nsum v f
val NSUM_SUBSET_SIMPLE : thm =
  |- !u v f. FINITE v /\ u SUBSET v ==> nsum u f <= nsum v f
val NSUM_LE_GEN : thm =
  |- !f g s.
         (!x. x IN s ==> f x <= g x) /\ FINITE {x | x IN s /\ ~(g x = 0)}
         ==> nsum s f <= nsum s g
val NSUM_IMAGE_NONZERO : thm =
  |- !d i s.
         FINITE s /\
         (!x y. x IN s /\ y IN s /\ ~(x = y) /\ i x = i y ==> d (i x) = 0)
         ==> nsum (IMAGE i s) d = nsum s (d o i)
val NSUM_BIJECTION : thm =
  |- !f p s.
         (!x. x IN s ==> p x IN s) /\
         (!y. y IN s ==> (?!x. x IN s /\ p x = y))
         ==> nsum s f = nsum s (f o p)
val NSUM_NSUM_PRODUCT : thm =
  |- !s t x.
         FINITE s /\ (!i. i IN s ==> FINITE (t i))
         ==> nsum s (\i. nsum (t i) (x i)) =
             nsum {i,j | i IN s /\ j IN t i} (\(i,j). x i j)
val NSUM_EQ_GENERAL : thm =
  |- !s t f g h.
         (!y. y IN t ==> (?!x. x IN s /\ h x = y)) /\
         (!x. x IN s ==> h x IN t /\ g (h x) = f x)
         ==> nsum s f = nsum t g
val NSUM_EQ_GENERAL_INVERSES : thm =
  |- !s t f g h k.
         (!y. y IN t ==> k y IN s /\ h (k y) = y) /\
         (!x. x IN s ==> h x IN t /\ k (h x) = x /\ g (h x) = f x)
         ==> nsum s f = nsum t g
val NSUM_INJECTION : thm =
  |- !f p s.
         FINITE s /\
         (!x. x IN s ==> p x IN s) /\
         (!x y. x IN s /\ y IN s /\ p x = p y ==> x = y)
         ==> nsum s (f o p) = nsum s f
val NSUM_UNION_NONZERO : thm =
  |- !f s t.
         FINITE s /\ FINITE t /\ (!x. x IN s INTER t ==> f x = 0)
         ==> nsum (s UNION t) f = nsum s f + nsum t f
val NSUM_UNIONS_NONZERO : thm =
  |- !f s.
         FINITE s /\
         (!t. t IN s ==> FINITE t) /\
         (!t1 t2 x.
              t1 IN s /\ t2 IN s /\ ~(t1 = t2) /\ x IN t1 /\ x IN t2
              ==> f x = 0)
         ==> nsum (UNIONS s) f = nsum s (\t. nsum t f)
val NSUM_CASES : thm =
  |- !s P f g.
         FINITE s
         ==> nsum s (\x. if P x then f x else g x) =
             nsum {x | x IN s /\ P x} f + nsum {x | x IN s /\ ~P x} g
val NSUM_CLOSED : thm =
  |- !P f s.
         P 0 /\ (!x y. P x /\ P y ==> P (x + y)) /\ (!a. a IN s ==> P (f a))
         ==> P (nsum s f)
val NSUM_ADD_NUMSEG : thm =
  |- !f g m n. nsum (m..n) (\i. f i + g i) = nsum (m..n) f + nsum (m..n) g
val NSUM_LE_NUMSEG : thm =
  |- !f g m n.
         (!i. m <= i /\ i <= n ==> f i <= g i)
         ==> nsum (m..n) f <= nsum (m..n) g
val NSUM_EQ_NUMSEG : thm =
  |- !f g m n.
         (!i. m <= i /\ i <= n ==> f i = g i)
         ==> nsum (m..n) f = nsum (m..n) g
val NSUM_CONST_NUMSEG : thm =
  |- !c m n. nsum (m..n) (\n. c) = ((n + 1) - m) * c
val NSUM_EQ_0_NUMSEG : thm =
  |- !f m n. (!i. m <= i /\ i <= n ==> f i = 0) ==> nsum (m..n) f = 0
val NSUM_EQ_0_IFF_NUMSEG : thm =
  |- !f m n. nsum (m..n) f = 0 <=> (!i. m <= i /\ i <= n ==> f i = 0)
val NSUM_TRIV_NUMSEG : thm = |- !f m n. n < m ==> nsum (m..n) f = 0
val NSUM_SING_NUMSEG : thm = |- !f n. nsum (n..n) f = f n
val NSUM_CLAUSES_NUMSEG : thm =
  |- (!m. nsum (m..0) f = (if m = 0 then f 0 else 0)) /\
     (!m n.
          nsum (m..SUC n) f =
          (if m <= SUC n then nsum (m..n) f + f (SUC n) else nsum (m..n) f))
val NSUM_SWAP_NUMSEG : thm =
  |- !a b c d f.
         nsum (a..b) (\i. nsum (c..d) (f i)) =
         nsum (c..d) (\j. nsum (a..b) (\i. f i j))
val NSUM_ADD_SPLIT : thm =
  |- !f m n p.
         m <= n + 1
         ==> nsum (m..n + p) f = nsum (m..n) f + nsum (n + 1..n + p) f
val NSUM_OFFSET : thm =
  |- !p f m n. nsum (m + p..n + p) f = nsum (m..n) (\i. f (i + p))
val NSUM_OFFSET_0 : thm =
  |- !f m n. m <= n ==> nsum (m..n) f = nsum (0..n - m) (\i. f (i + m))
val NSUM_CLAUSES_LEFT : thm =
  |- !f m n. m <= n ==> nsum (m..n) f = f m + nsum (m + 1..n) f
val NSUM_CLAUSES_RIGHT : thm =
  |- !f m n. 0 < n /\ m <= n ==> nsum (m..n) f = nsum (m..n - 1) f + f n
val NSUM_PAIR : thm =
  |- !f m n.
         nsum (2 * m..2 * n + 1) f =
         nsum (m..n) (\i. f (2 * i) + f (2 * i + 1))
val MOD_NSUM_MOD : thm =
  |- !f n s.
         FINITE s /\ ~(n = 0)
         ==> nsum s f MOD n = nsum s (\i. f i MOD n) MOD n
val MOD_NSUM_MOD_NUMSEG : thm =
  |- !f a b n.
         ~(n = 0) ==> nsum (a..b) f MOD n = nsum (a..b) (\i. f i MOD n) MOD n
val CARD_UNIONS : thm =
  |- !s. FINITE s /\
         (!t. t IN s ==> FINITE t) /\
         (!t u. t IN s /\ u IN s /\ ~(t = u) ==> t INTER u = {})
         ==> CARD (UNIONS s) = nsum s CARD
val sum : thm = |- sum = iterate (+)
val NEUTRAL_REAL_ADD : thm = |- neutral (+) = &0
val NEUTRAL_REAL_MUL : thm = |- neutral (*) = &1
val MONOIDAL_REAL_ADD : thm = |- monoidal (+)
val MONOIDAL_REAL_MUL : thm = |- monoidal (*)
val SUM_DEGENERATE : thm =
  |- !f s. ~FINITE {x | x IN s /\ ~(f x = &0)} ==> sum s f = &0
val SUM_CLAUSES : thm =
  |- (!f. sum {} f = &0) /\
     (!x f s.
          FINITE s
          ==> sum (x INSERT s) f =
              (if x IN s then sum s f else f x + sum s f))
val SUM_UNION : thm =
  |- !f s t.
         FINITE s /\ FINITE t /\ DISJOINT s t
         ==> sum (s UNION t) f = sum s f + sum t f
val SUM_DIFF : thm =
  |- !f s t. FINITE s /\ t SUBSET s ==> sum (s DIFF t) f = sum s f - sum t f
val SUM_INCL_EXCL : thm =
  |- !s t f.
         FINITE s /\ FINITE t
         ==> sum s f + sum t f = sum (s UNION t) f + sum (s INTER t) f
val SUM_SUPPORT : thm = |- !f s. sum (support (+) f s) f = sum s f
val SUM_ADD : thm =
  |- !f g s. FINITE s ==> sum s (\x. f x + g x) = sum s f + sum s g
val SUM_ADD_GEN : thm =
  |- !f g s.
         FINITE {x | x IN s /\ ~(f x = &0)} /\
         FINITE {x | x IN s /\ ~(g x = &0)}
         ==> sum s (\x. f x + g x) = sum s f + sum s g
val SUM_EQ_0 : thm = |- !f s. (!x. x IN s ==> f x = &0) ==> sum s f = &0
val SUM_0 : thm = |- !s. sum s (\n. &0) = &0
val SUM_LMUL : thm = |- !f c s. sum s (\x. c * f x) = c * sum s f
val SUM_RMUL : thm = |- !f c s. sum s (\x. f x * c) = sum s f * c
val SUM_NEG : thm = |- !f s. sum s (\x. --f x) = --sum s f
val SUM_SUB : thm =
  |- !f g s. FINITE s ==> sum s (\x. f x - g x) = sum s f - sum s g
val SUM_LE : thm =
  |- !f g s. FINITE s /\ (!x. x IN s ==> f x <= g x) ==> sum s f <= sum s g
val SUM_LT : thm =
  |- !f g s.
         FINITE s /\ (!x. x IN s ==> f x <= g x) /\ (?x. x IN s /\ f x < g x)
         ==> sum s f < sum s g
val SUM_LT_ALL : thm =
  |- !f g s.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < g x)
         ==> sum s f < sum s g
val SUM_POS_LT : thm =
  |- !f s.
         FINITE s /\ (!x. x IN s ==> &0 <= f x) /\ (?x. x IN s /\ &0 < f x)
         ==> &0 < sum s f
val SUM_POS_LT_ALL : thm =
  |- !s f.
         FINITE s /\ ~(s = {}) /\ (!i. i IN s ==> &0 < f i) ==> &0 < sum s f
val SUM_EQ : thm =
  |- !f g s. (!x. x IN s ==> f x = g x) ==> sum s f = sum s g
val SUM_ABS : thm =
  |- !f s. FINITE s ==> abs (sum s f) <= sum s (\x. abs (f x))
val SUM_ABS_LE : thm =
  |- !f g s.
         FINITE s /\ (!x. x IN s ==> abs (f x) <= g x)
         ==> abs (sum s f) <= sum s g
val SUM_CONST : thm = |- !c s. FINITE s ==> sum s (\n. c) = &(CARD s) * c
val SUM_POS_LE : thm = |- !s. (!x. x IN s ==> &0 <= f x) ==> &0 <= sum s f
val SUM_POS_BOUND : thm =
  |- !f b s.
         FINITE s /\ (!x. x IN s ==> &0 <= f x) /\ sum s f <= b
         ==> (!x. x IN s ==> f x <= b)
val SUM_POS_EQ_0 : thm =
  |- !f s.
         FINITE s /\ (!x. x IN s ==> &0 <= f x) /\ sum s f = &0
         ==> (!x. x IN s ==> f x = &0)
val SUM_ZERO_EXISTS : thm =
  |- !u s.
         FINITE s /\ sum s u = &0
         ==> (!i. i IN s ==> u i = &0) \/
             (?j k. j IN s /\ u j < &0 /\ k IN s /\ u k > &0)
val SUM_DELETE : thm =
  |- !f s a. FINITE s /\ a IN s ==> sum (s DELETE a) f = sum s f - f a
val SUM_DELETE_CASES : thm =
  |- !f s a.
         FINITE s
         ==> sum (s DELETE a) f = (if a IN s then sum s f - f a else sum s f)
val SUM_SING : thm = |- !f x. sum {x} f = f x
val SUM_DELTA : thm =
  |- !s a. sum s (\x. if x = a then b else &0) = (if a IN s then b else &0)
val SUM_SWAP : thm =
  |- !f s t.
         FINITE s /\ FINITE t
         ==> sum s (\i. sum t (f i)) = sum t (\j. sum s (\i. f i j))
val SUM_IMAGE : thm =
  |- !f g s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
         ==> sum (IMAGE f s) g = sum s (g o f)
val SUM_SUPERSET : thm =
  |- !f u v.
         u SUBSET v /\ (!x. x IN v /\ ~(x IN u) ==> f x = &0)
         ==> sum v f = sum u f
val SUM_UNION_RZERO : thm =
  |- !f u v.
         FINITE u /\ (!x. x IN v /\ ~(x IN u) ==> f x = &0)
         ==> sum (u UNION v) f = sum u f
val SUM_UNION_LZERO : thm =
  |- !f u v.
         FINITE v /\ (!x. x IN u /\ ~(x IN v) ==> f x = &0)
         ==> sum (u UNION v) f = sum v f
val SUM_RESTRICT : thm =
  |- !f s. FINITE s ==> sum s (\x. if x IN s then f x else &0) = sum s f
val SUM_BOUND : thm =
  |- !s f b.
         FINITE s /\ (!x. x IN s ==> f x <= b) ==> sum s f <= &(CARD s) * b
val SUM_BOUND_GEN : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x <= b / &(CARD s))
         ==> sum s f <= b
val SUM_ABS_BOUND : thm =
  |- !s f b.
         FINITE s /\ (!x. x IN s ==> abs (f x) <= b)
         ==> abs (sum s f) <= &(CARD s) * b
val SUM_BOUND_LT : thm =
  |- !s f b.
         FINITE s /\ (!x. x IN s ==> f x <= b) /\ (?x. x IN s /\ f x < b)
         ==> sum s f < &(CARD s) * b
val SUM_BOUND_LT_ALL : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < b)
         ==> sum s f < &(CARD s) * b
val SUM_BOUND_LT_GEN : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < b / &(CARD s))
         ==> sum s f < b
val SUM_UNION_EQ : thm =
  |- !s t u.
         FINITE u /\ s INTER t = {} /\ s UNION t = u
         ==> sum s f + sum t f = sum u f
val SUM_EQ_SUPERSET : thm =
  |- !f s t.
         FINITE t /\
         t SUBSET s /\
         (!x. x IN t ==> f x = g x) /\
         (!x. x IN s /\ ~(x IN t) ==> f x = &0)
         ==> sum s f = sum t g
val SUM_RESTRICT_SET : thm =
  |- !P s f. sum {x | x IN s /\ P x} f = sum s (\x. if P x then f x else &0)
val SUM_SUM_RESTRICT : thm =
  |- !R f s t.
         FINITE s /\ FINITE t
         ==> sum s (\x. sum {y | y IN t /\ R x y} (\y. f x y)) =
             sum t (\y. sum {x | x IN s /\ R x y} (\x. f x y))
val CARD_EQ_SUM : thm = |- !s. FINITE s ==> &(CARD s) = sum s (\x. &1)
val SUM_MULTICOUNT_GEN : thm =
  |- !R s t k.
         FINITE s /\
         FINITE t /\
         (!j. j IN t ==> CARD {i | i IN s /\ R i j} = k j)
         ==> sum s (\i. &(CARD {j | j IN t /\ R i j})) = sum t (\i. &(k i))
val SUM_MULTICOUNT : thm =
  |- !R s t k.
         FINITE s /\
         FINITE t /\
         (!j. j IN t ==> CARD {i | i IN s /\ R i j} = k)
         ==> sum s (\i. &(CARD {j | j IN t /\ R i j})) = &(k * CARD t)
val SUM_IMAGE_GEN : thm =
  |- !f g s.
         FINITE s
         ==> sum s g = sum (IMAGE f s) (\y. sum {x | x IN s /\ f x = y} g)
val SUM_GROUP : thm =
  |- !f g s t.
         FINITE s /\ IMAGE f s SUBSET t
         ==> sum t (\y. sum {x | x IN s /\ f x = y} g) = sum s g
val REAL_OF_NUM_SUM : thm =
  |- !f s. FINITE s ==> &(nsum s f) = sum s (\x. &(f x))
val SUM_SUBSET : thm =
  |- !u v f.
         FINITE u /\
         FINITE v /\
         (!x. x IN u DIFF v ==> f x <= &0) /\
         (!x. x IN v DIFF u ==> &0 <= f x)
         ==> sum u f <= sum v f
val SUM_SUBSET_SIMPLE : thm =
  |- !u v f.
         FINITE v /\ u SUBSET v /\ (!x. x IN v DIFF u ==> &0 <= f x)
         ==> sum u f <= sum v f
val SUM_IMAGE_NONZERO : thm =
  |- !d i s.
         FINITE s /\
         (!x y. x IN s /\ y IN s /\ ~(x = y) /\ i x = i y ==> d (i x) = &0)
         ==> sum (IMAGE i s) d = sum s (d o i)
val SUM_BIJECTION : thm =
  |- !f p s.
         (!x. x IN s ==> p x IN s) /\
         (!y. y IN s ==> (?!x. x IN s /\ p x = y))
         ==> sum s f = sum s (f o p)
val SUM_SUM_PRODUCT : thm =
  |- !s t x.
         FINITE s /\ (!i. i IN s ==> FINITE (t i))
         ==> sum s (\i. sum (t i) (x i)) =
             sum {i,j | i IN s /\ j IN t i} (\(i,j). x i j)
val SUM_EQ_GENERAL : thm =
  |- !s t f g h.
         (!y. y IN t ==> (?!x. x IN s /\ h x = y)) /\
         (!x. x IN s ==> h x IN t /\ g (h x) = f x)
         ==> sum s f = sum t g
val SUM_EQ_GENERAL_INVERSES : thm =
  |- !s t f g h k.
         (!y. y IN t ==> k y IN s /\ h (k y) = y) /\
         (!x. x IN s ==> h x IN t /\ k (h x) = x /\ g (h x) = f x)
         ==> sum s f = sum t g
val SUM_INJECTION : thm =
  |- !f p s.
         FINITE s /\
         (!x. x IN s ==> p x IN s) /\
         (!x y. x IN s /\ y IN s /\ p x = p y ==> x = y)
         ==> sum s (f o p) = sum s f
val SUM_UNION_NONZERO : thm =
  |- !f s t.
         FINITE s /\ FINITE t /\ (!x. x IN s INTER t ==> f x = &0)
         ==> sum (s UNION t) f = sum s f + sum t f
val SUM_UNIONS_NONZERO : thm =
  |- !f s.
         FINITE s /\
         (!t. t IN s ==> FINITE t) /\
         (!t1 t2 x.
              t1 IN s /\ t2 IN s /\ ~(t1 = t2) /\ x IN t1 /\ x IN t2
              ==> f x = &0)
         ==> sum (UNIONS s) f = sum s (\t. sum t f)
val SUM_CASES : thm =
  |- !s P f g.
         FINITE s
         ==> sum s (\x. if P x then f x else g x) =
             sum {x | x IN s /\ P x} f + sum {x | x IN s /\ ~P x} g
val SUM_CASES_1 : thm =
  |- !s a.
         FINITE s /\ a IN s
         ==> sum s (\x. if x = a then y else f x) = sum s f + y - f a
val SUM_LE_INCLUDED : thm =
  |- !f g s t i.
         FINITE s /\
         FINITE t /\
         (!y. y IN t ==> &0 <= g y) /\
         (!x. x IN s ==> (?y. y IN t /\ i y = x /\ f x <= g y))
         ==> sum s f <= sum t g
val SUM_IMAGE_LE : thm =
  |- !f g s.
         FINITE s /\ (!x. x IN s ==> &0 <= g (f x))
         ==> sum (IMAGE f s) g <= sum s (g o f)
val SUM_CLOSED : thm =
  |- !P f s.
         P (&0) /\
         (!x y. P x /\ P y ==> P (x + y)) /\
         (!a. a IN s ==> P (f a))
         ==> P (sum s f)
val REAL_OF_NUM_SUM_GEN : thm =
  |- !f s.
         FINITE {i | i IN s /\ ~(f i = 0)}
         ==> &(nsum s f) = sum s (\x. &(f x))
val SUM_ADD_NUMSEG : thm =
  |- !f g m n. sum (m..n) (\i. f i + g i) = sum (m..n) f + sum (m..n) g
val SUM_SUB_NUMSEG : thm =
  |- !f g m n. sum (m..n) (\i. f i - g i) = sum (m..n) f - sum (m..n) g
val SUM_LE_NUMSEG : thm =
  |- !f g m n.
         (!i. m <= i /\ i <= n ==> f i <= g i)
         ==> sum (m..n) f <= sum (m..n) g
val SUM_EQ_NUMSEG : thm =
  |- !f g m n.
         (!i. m <= i /\ i <= n ==> f i = g i) ==> sum (m..n) f = sum (m..n) g
val SUM_ABS_NUMSEG : thm =
  |- !f m n. abs (sum (m..n) f) <= sum (m..n) (\i. abs (f i))
val SUM_CONST_NUMSEG : thm =
  |- !c m n. sum (m..n) (\n. c) = &((n + 1) - m) * c
val SUM_EQ_0_NUMSEG : thm =
  |- !f m n. (!i. m <= i /\ i <= n ==> f i = &0) ==> sum (m..n) f = &0
val SUM_TRIV_NUMSEG : thm = |- !f m n. n < m ==> sum (m..n) f = &0
val SUM_POS_LE_NUMSEG : thm =
  |- !m n f. (!p. m <= p /\ p <= n ==> &0 <= f p) ==> &0 <= sum (m..n) f
val SUM_POS_EQ_0_NUMSEG : thm =
  |- !f m n.
         (!p. m <= p /\ p <= n ==> &0 <= f p) /\ sum (m..n) f = &0
         ==> (!p. m <= p /\ p <= n ==> f p = &0)
val SUM_SING_NUMSEG : thm = |- !f n. sum (n..n) f = f n
val SUM_CLAUSES_NUMSEG : thm =
  |- (!m. sum (m..0) f = (if m = 0 then f 0 else &0)) /\
     (!m n.
          sum (m..SUC n) f =
          (if m <= SUC n then sum (m..n) f + f (SUC n) else sum (m..n) f))
val SUM_SWAP_NUMSEG : thm =
  |- !a b c d f.
         sum (a..b) (\i. sum (c..d) (f i)) =
         sum (c..d) (\j. sum (a..b) (\i. f i j))
val SUM_ADD_SPLIT : thm =
  |- !f m n p.
         m <= n + 1
         ==> sum (m..n + p) f = sum (m..n) f + sum (n + 1..n + p) f
val SUM_OFFSET : thm =
  |- !p f m n. sum (m + p..n + p) f = sum (m..n) (\i. f (i + p))
val SUM_OFFSET_0 : thm =
  |- !f m n. m <= n ==> sum (m..n) f = sum (0..n - m) (\i. f (i + m))
val SUM_CLAUSES_LEFT : thm =
  |- !f m n. m <= n ==> sum (m..n) f = f m + sum (m + 1..n) f
val SUM_CLAUSES_RIGHT : thm =
  |- !f m n. 0 < n /\ m <= n ==> sum (m..n) f = sum (m..n - 1) f + f n
val SUM_PAIR : thm =
  |- !f m n.
         sum (2 * m..2 * n + 1) f =
         sum (m..n) (\i. f (2 * i) + f (2 * i + 1))
val REAL_OF_NUM_SUM_NUMSEG : thm =
  |- !f m n. &(nsum (m..n) f) = sum (m..n) (\i. &(f i))
val SUM_PARTIAL_SUC : thm =
  |- !f g m n.
         sum (m..n) (\k. f k * (g (k + 1) - g k)) =
         (if m <= n
          then f (n + 1) * g (n + 1) -
               f m * g m -
               sum (m..n) (\k. g (k + 1) * (f (k + 1) - f k))
          else &0)
val SUM_PARTIAL_PRE : thm =
  |- !f g m n.
         sum (m..n) (\k. f k * (g k - g (k - 1))) =
         (if m <= n
          then f (n + 1) * g n -
               f m * g (m - 1) -
               sum (m..n) (\k. g k * (f (k + 1) - f k))
          else &0)
val SUM_DIFFS : thm =
  |- !m n.
         sum (m..n) (\k. f k - f (k + 1)) =
         (if m <= n then f m - f (n + 1) else &0)
val SUM_DIFFS_ALT : thm =
  |- !m n.
         sum (m..n) (\k. f (k + 1) - f k) =
         (if m <= n then f (n + 1) - f m else &0)
val SUM_COMBINE_R : thm =
  |- !f m n p.
         m <= n + 1 /\ n <= p
         ==> sum (m..n) f + sum (n + 1..p) f = sum (m..p) f
val SUM_COMBINE_L : thm =
  |- !f m n p.
         0 < n /\ m <= n /\ n <= p + 1
         ==> sum (m..n - 1) f + sum (n..p) f = sum (m..p) f
val REAL_SUB_POW : thm =
  |- !x y n.
         1 <= n
         ==> x pow n - y pow n =
             (x - y) * sum (0..n - 1) (\i. x pow i * y pow (n - 1 - i))
val REAL_SUB_POW_R1 : thm =
  |- !x n. 1 <= n ==> x pow n - &1 = (x - &1) * sum (0..n - 1) (\i. x pow i)
val REAL_SUB_POW_L1 : thm =
  |- !x n. 1 <= n ==> &1 - x pow n = (&1 - x) * sum (0..n - 1) (\i. x pow i)
val REAL_SUB_POLYFUN : thm =
  |- !a x y n.
         1 <= n
         ==> sum (0..n) (\i. a i * x pow i) - sum (0..n) (\i. a i * y pow i) =
             (x - y) *
             sum (0..n - 1)
             (\j. sum (j + 1..n) (\i. a i * y pow (i - j - 1)) * x pow j)
val REAL_SUB_POLYFUN_ALT : thm =
  |- !a x y n.
         1 <= n
         ==> sum (0..n) (\i. a i * x pow i) - sum (0..n) (\i. a i * y pow i) =
             (x - y) *
             sum (0..n - 1)
             (\j. sum (0..n - j - 1) (\k. a (j + k + 1) * y pow k) * x pow j)
val REAL_POLYFUN_ROOTBOUND : thm =
  |- !n c.
         ~(!i. i IN 0..n ==> c i = &0)
         ==> FINITE {x | sum (0..n) (\i. c i * x pow i) = &0} /\
             CARD {x | sum (0..n) (\i. c i * x pow i) = &0} <= n
val REAL_POLYFUN_FINITE_ROOTS : thm =
  |- !n c.
         FINITE {x | sum (0..n) (\i. c i * x pow i) = &0} <=>
         (?i. i IN 0..n /\ ~(c i = &0))
val REAL_POLYFUN_EQ_0 : thm =
  |- !n c.
         (!x. sum (0..n) (\i. c i * x pow i) = &0) <=>
         (!i. i IN 0..n ==> c i = &0)
val REAL_POLYFUN_EQ_CONST : thm =
  |- !n c k.
         (!x. sum (0..n) (\i. c i * x pow i) = k) <=>
         c 0 = k /\ (!i. i IN 1..n ==> c i = &0)
val polynomial_function : thm =
  |- !p. polynomial_function p <=>
         (?m c. !x. p x = sum (0..m) (\i. c i * x pow i))
val POLYNOMIAL_FUNCTION_CONST : thm = |- !c. polynomial_function (\x. c)
val POLYNOMIAL_FUNCTION_ID : thm = |- polynomial_function (\x. x)
val POLYNOMIAL_FUNCTION_I : thm = |- polynomial_function I
val POLYNOMIAL_FUNCTION_ADD : thm =
  |- !p q.
         polynomial_function p /\ polynomial_function q
         ==> polynomial_function (\x. p x + q x)
val POLYNOMIAL_FUNCTION_LMUL : thm =
  |- !p c. polynomial_function p ==> polynomial_function (\x. c * p x)
val POLYNOMIAL_FUNCTION_RMUL : thm =
  |- !p c. polynomial_function p ==> polynomial_function (\x. p x * c)
val POLYNOMIAL_FUNCTION_NEG : thm =
  |- !p. polynomial_function (\x. --p x) <=> polynomial_function p
val POLYNOMIAL_FUNCTION_SUB : thm =
  |- !p q.
         polynomial_function p /\ polynomial_function q
         ==> polynomial_function (\x. p x - q x)
val POLYNOMIAL_FUNCTION_MUL : thm =
  |- !p q.
         polynomial_function p /\ polynomial_function q
         ==> polynomial_function (\x. p x * q x)
val POLYNOMIAL_FUNCTION_SUM : thm =
  |- !s p.
         FINITE s /\ (!i. i IN s ==> polynomial_function (\x. p x i))
         ==> polynomial_function (\x. sum s (p x))
val POLYNOMIAL_FUNCTION_POW : thm =
  |- !p n. polynomial_function p ==> polynomial_function (\x. p x pow n)
val POLYNOMIAL_FUNCTION_INDUCT : thm =
  |- !P. P (\x. x) /\
         (!c. P (\x. c)) /\
         (!p q. P p /\ P q ==> P (\x. p x + q x)) /\
         (!p q. P p /\ P q ==> P (\x. p x * q x))
         ==> (!p. polynomial_function p ==> P p)
val POLYNOMIAL_FUNCTION_o : thm =
  |- !p q.
         polynomial_function p /\ polynomial_function q
         ==> polynomial_function (p o q)
val POLYNOMIAL_FUNCTION_FINITE_ROOTS : thm =
  |- !p a.
         polynomial_function p ==> (FINITE {x | p x = a} <=> ~(!x. p x = a))
val dimindex : thm =
  |- !s. dimindex s = (if FINITE (:A) then CARD (:A) else 1)
val DIMINDEX_NONZERO : thm = |- !s. ~(dimindex s = 0)
val DIMINDEX_GE_1 : thm = |- !s. 1 <= dimindex s
val DIMINDEX_UNIV : thm = |- !s. dimindex s = dimindex (:A)
val DIMINDEX_UNIQUE : thm = |- (:A) HAS_SIZE n ==> dimindex (:A) = n
val finite_image_tybij : thm =
  |- (!a. finite_index (dest_finite_image a) = a) /\
     (!r. r IN 1..dimindex (:A) <=> dest_finite_image (finite_index r) = r)
val FINITE_IMAGE_IMAGE : thm =
  |- (:(A)finite_image) = IMAGE finite_index (1..dimindex (:A))
val HAS_SIZE_FINITE_IMAGE : thm =
  |- !s. (:(A)finite_image) HAS_SIZE dimindex s
val CARD_FINITE_IMAGE : thm = |- !s. CARD (:(A)finite_image) = dimindex s
val FINITE_FINITE_IMAGE : thm = |- FINITE (:(A)finite_image)
val DIMINDEX_FINITE_IMAGE : thm = |- !s t. dimindex s = dimindex t
val FINITE_INDEX_WORKS : thm =
  |- !i. ?!n. 1 <= n /\ n <= dimindex (:A) /\ finite_index n = i
val FINITE_INDEX_INJ : thm =
  |- !i j.
         1 <= i /\ i <= dimindex (:A) /\ 1 <= j /\ j <= dimindex (:A)
         ==> (finite_index i = finite_index j <=> i = j)
val FORALL_FINITE_INDEX : thm =
  |- (!k. P k) <=> (!i. 1 <= i /\ i <= dimindex (:N) ==> P (finite_index i))
val cart_tybij : thm =
  |- (!a. mk_cart (dest_cart a) = a) /\ (!r. T <=> dest_cart (mk_cart r) = r)
val finite_index : thm = |- !x i. x$i = dest_cart x (finite_index i)
val CART_EQ : thm =
  |- !x y. x = y <=> (!i. 1 <= i /\ i <= dimindex (:B) ==> x$i = y$i)
val lambda : thm =
  |- !g. (lambda) g = (@f. !i. 1 <= i /\ i <= dimindex (:B) ==> f$i = g i)
val LAMBDA_BETA : thm =
  |- !i. 1 <= i /\ i <= dimindex (:B) ==> (lambda) g$i = g i
val LAMBDA_UNIQUE : thm =
  |- !f g.
         (!i. 1 <= i /\ i <= dimindex (:B) ==> f$i = g i) <=> (lambda) g = f
val LAMBDA_ETA : thm = |- !g. (lambda i. g$i) = g
val FINITE_INDEX_INRANGE : thm =
  |- !i. ?k. 1 <= k /\ k <= dimindex (:N) /\ (!x. x$i = x$k)
val FINITE_INDEX_INRANGE_2 : thm =
  |- !i. ?k. 1 <= k /\
             k <= dimindex (:N) /\
             (!x. x$i = x$k) /\
             (!y. y$i = y$k)
val CART_EQ_FULL : thm = |- !x y. x = y <=> (!i. x$i = y$i)
val finite_sum_tybij : thm =
  |- (!a. mk_finite_sum (dest_finite_sum a) = a) /\
     (!r. r IN 1..dimindex (:A) + dimindex (:B) <=>
          dest_finite_sum (mk_finite_sum r) = r)
val pastecart : thm =
  |- !f g.
         pastecart f g =
         (lambda i. if i <= dimindex (:M) then f$i else g$(i - dimindex (:M)))
val fstcart : thm = |- !f. fstcart f = (lambda i. f$i)
val sndcart : thm = |- !f. sndcart f = (lambda i. f$(i + dimindex (:M)))
val FINITE_SUM_IMAGE : thm =
  |- (:(A,B)finite_sum) =
     IMAGE mk_finite_sum (1..dimindex (:A) + dimindex (:B))
val DIMINDEX_HAS_SIZE_FINITE_SUM : thm =
  |- (:(M,N)finite_sum) HAS_SIZE dimindex (:M) + dimindex (:N)
val DIMINDEX_FINITE_SUM : thm =
  |- dimindex (:(M,N)finite_sum) = dimindex (:M) + dimindex (:N)
val FSTCART_PASTECART : thm = |- !x y. fstcart (pastecart x y) = x
val SNDCART_PASTECART : thm = |- !x y. sndcart (pastecart x y) = y
val PASTECART_FST_SND : thm = |- !z. pastecart (fstcart z) (sndcart z) = z
val PASTECART_EQ : thm =
  |- !x y. x = y <=> fstcart x = fstcart y /\ sndcart x = sndcart y
val FORALL_PASTECART : thm = |- (!p. P p) <=> (!x y. P (pastecart x y))
val EXISTS_PASTECART : thm = |- (?p. P p) <=> (?x y. P (pastecart x y))
val PASTECART_INJ : thm =
  |- !x y w z. pastecart x y = pastecart w z <=> x = w /\ y = z
val HAS_SIZE_1 : thm = |- (:1) HAS_SIZE 1
val HAS_SIZE_2 : thm = |- (:2) HAS_SIZE 2
val HAS_SIZE_3 : thm = |- (:3) HAS_SIZE 3
val HAS_SIZE_4 : thm = |- (:4) HAS_SIZE 4
val DIMINDEX_1 : thm = |- dimindex (:1) = 1
val DIMINDEX_2 : thm = |- dimindex (:2) = 2
val DIMINDEX_3 : thm = |- dimindex (:3) = 3
val DIMINDEX_4 : thm = |- dimindex (:4) = 4
val FINITE_CART : thm =
  |- !P. (!i. 1 <= i /\ i <= dimindex (:N) ==> FINITE {x | P i x})
         ==> FINITE {v | !i. 1 <= i /\ i <= dimindex (:N) ==> P i (v$i)}
val HAS_SIZE_CART_UNIV : thm =
  |- !m. (:A) HAS_SIZE m ==> (:A^N) HAS_SIZE m EXP dimindex (:N)
val CARD_CART_UNIV : thm =
  |- FINITE (:A) ==> CARD (:A^N) = CARD (:A) EXP dimindex (:N)
val FINITE_CART_UNIV : thm = |- FINITE (:A) ==> FINITE (:A^N)
val vector : thm = |- !l. vector l = (lambda i. EL (i - 1) l)
val IN_ELIM_PASTECART_THM : thm =
  |- !P a b. pastecart a b IN {pastecart x y | P x y} <=> P a b
val PCROSS : thm = |- !s t. s PCROSS t = {pastecart x y | x IN s /\ y IN t}
val FORALL_IN_PCROSS : thm =
  |- (!z. z IN s PCROSS t ==> P z) <=>
     (!x y. x IN s /\ y IN t ==> P (pastecart x y))
val EXISTS_IN_PCROSS : thm =
  |- (?z. z IN s PCROSS t /\ P z) <=>
     (?x y. x IN s /\ y IN t /\ P (pastecart x y))
val PASTECART_IN_PCROSS : thm =
  |- !s t x y. pastecart x y IN s PCROSS t <=> x IN s /\ y IN t
val PCROSS_EQ_EMPTY : thm = |- !s t. s PCROSS t = {} <=> s = {} \/ t = {}
val PCROSS_EMPTY : thm = |- (!s. s PCROSS {} = {}) /\ (!t. {} PCROSS t = {})
val SUBSET_PCROSS : thm =
  |- !s t s' t'.
         s PCROSS t SUBSET s' PCROSS t' <=>
         s = {} \/ t = {} \/ s SUBSET s' /\ t SUBSET t'
val PCROSS_MONO : thm =
  |- !s t s' t'.
         s SUBSET s' /\ t SUBSET t' ==> s PCROSS t SUBSET s' PCROSS t'
val PCROSS_EQ : thm =
  |- !s s' t t'.
         s PCROSS t = s' PCROSS t' <=>
         (s = {} \/ t = {}) /\ (s' = {} \/ t' = {}) \/ s = s' /\ t = t'
val UNIV_PCROSS_UNIV : thm = |- (:A^M) PCROSS (:A^N) = (:A^(M,N)finite_sum)
val HAS_SIZE_PCROSS : thm =
  |- !s t m n. s HAS_SIZE m /\ t HAS_SIZE n ==> s PCROSS t HAS_SIZE m * n
val FINITE_PCROSS : thm =
  |- !s t. FINITE s /\ FINITE t ==> FINITE (s PCROSS t)
val FINITE_PCROSS_EQ : thm =
  |- !s t. FINITE (s PCROSS t) <=> s = {} \/ t = {} \/ FINITE s /\ FINITE t
val IMAGE_FSTCART_PCROSS : thm =
  |- !s t. IMAGE fstcart (s PCROSS t) = (if t = {} then {} else s)
val IMAGE_SNDCART_PCROSS : thm =
  |- !s t. IMAGE sndcart (s PCROSS t) = (if s = {} then {} else t)
val PCROSS_INTER : thm =
  |- (!s t u. s PCROSS (t INTER u) = s PCROSS t INTER s PCROSS u) /\
     (!s t u. (s INTER t) PCROSS u = s PCROSS u INTER t PCROSS u)
val PCROSS_UNION : thm =
  |- (!s t u. s PCROSS (t UNION u) = s PCROSS t UNION s PCROSS u) /\
     (!s t u. (s UNION t) PCROSS u = s PCROSS u UNION t PCROSS u)
val PCROSS_DIFF : thm =
  |- (!s t u. s PCROSS (t DIFF u) = s PCROSS t DIFF s PCROSS u) /\
     (!s t u. (s DIFF t) PCROSS u = s PCROSS u DIFF t PCROSS u)
val INTER_PCROSS : thm =
  |- !s s' t t'.
         s PCROSS t INTER s' PCROSS t' = (s INTER s') PCROSS (t INTER t')
val PCROSS_UNIONS_UNIONS : thm =
  |- !f g. UNIONS f PCROSS UNIONS g = UNIONS {s PCROSS t | s IN f /\ t IN g}
val PCROSS_UNIONS : thm =
  |- (!s f. s PCROSS UNIONS f = UNIONS {s PCROSS t | t IN f}) /\
     (!f t. UNIONS f PCROSS t = UNIONS {s PCROSS t | s IN f})
val CASEWISE_DEF : thm =
  |- CASEWISE [] f x = (@y. T) /\
     CASEWISE (CONS h t) f x =
     (if ?y. FST h y = x then SND h f (@y. FST h y = x) else CASEWISE t f x)
val CASEWISE : thm =
  |- CASEWISE [] f x = (@y. T) /\
     CASEWISE (CONS (s,t) clauses) f x =
     (if ?y. s y = x then t f (@y. s y = x) else CASEWISE clauses f x)
val CASEWISE_CASES : thm =
  |- !clauses c x.
         (?s t a.
              MEM (s,t) clauses /\ s a = x /\ CASEWISE clauses c x = t c a) \/
         ~(?s t a. MEM (s,t) clauses /\ s a = x) /\
         CASEWISE clauses c x = (@y. T)
val CASEWISE_WORKS : thm =
  |- !clauses c.
         (!s t s' t' x y.
              MEM (s,t) clauses /\ MEM (s',t') clauses /\ s x = s' y
              ==> t c x = t' c y)
         ==> ALL (\(s,t). !x. CASEWISE clauses c (s x) = t c x) clauses
val admissible : thm =
  |- !p (<<) s t.
         admissible (<<) p s t <=>
         (!f g a.
              p f a /\ p g a /\ (!z. z << s a ==> f z = g z)
              ==> t f a = t g a)
val tailadmissible : thm =
  |- !(<<) s p t.
         tailadmissible (<<) p s t <=>
         (?P G H.
              (!f a y. P f a /\ y << G f a ==> y << s a) /\
              (!f g a.
                   (!z. z << s a ==> f z = g z)
                   ==> (P f a <=> P g a) /\ G f a = G g a /\ H f a = H g a) /\
              (!f a. p f a ==> t f a = (if P f a then f (G f a) else H f a)))
val superadmissible : thm =
  |- !(<<) p s t.
         superadmissible (<<) p s t <=>
         admissible (<<) (\f a. T) s p ==> tailadmissible (<<) p s t
val MATCH_SEQPATTERN : thm =
  |- _MATCH x (_SEQPATTERN r s) =
     (if ?y. r x y then _MATCH x r else _MATCH x s)
val ADMISSIBLE_CONST : thm = |- !p s c. admissible (<<) p s (\f. c)
val ADMISSIBLE_BASE : thm =
  |- !(<<) p s t.
         (!f a. p f a ==> t a << s a) ==> admissible (<<) p s (\f x. f (t x))
val ADMISSIBLE_COMB : thm =
  |- !(<<) p s g y.
         admissible (<<) p s g /\ admissible (<<) p s y
         ==> admissible (<<) p s (\f x. g f x (y f x))
val ADMISSIBLE_RAND : thm =
  |- !(<<) p s g y.
         admissible (<<) p s y ==> admissible (<<) p s (\f x. g x (y f x))
val ADMISSIBLE_LAMBDA : thm =
  |- !(<<) p s t.
         admissible (<<) (\f (u,x). p f x) (\(u,x). s x) (\f (u,x). t f u x)
         ==> admissible (<<) p s (\f x u. t f u x)
val ADMISSIBLE_NEST : thm =
  |- !(<<) p s t.
         admissible (<<) p s t /\ (!f a. p f a ==> t f a << s a)
         ==> admissible (<<) p s (\f x. f (t f x))
val ADMISSIBLE_COND : thm =
  |- !(<<) p P s h k.
         admissible (<<) p s P /\
         admissible (<<) (\f x. p f x /\ P f x) s h /\
         admissible (<<) (\f x. p f x /\ ~P f x) s k
         ==> admissible (<<) p s (\f x. if P f x then h f x else k f x)
val ADMISSIBLE_MATCH : thm =
  |- !(<<) p s e c.
         admissible (<<) p s e /\ admissible (<<) p s (\f x. c f x (e f x))
         ==> admissible (<<) p s (\f x. _MATCH (e f x) (c f x))
val ADMISSIBLE_SEQPATTERN : thm =
  |- !(<<) p s c1 c2 e.
         admissible (<<) p s (\f x. ?y. c1 f x (e f x) y) /\
         admissible (<<) (\f x. p f x /\ (?y. c1 f x (e f x) y)) s
         (\f x. c1 f x (e f x)) /\
         admissible (<<) (\f x. p f x /\ ~(?y. c1 f x (e f x) y)) s
         (\f x. c2 f x (e f x))
         ==> admissible (<<) p s
             (\f x. _SEQPATTERN (c1 f x) (c2 f x) (e f x))
val ADMISSIBLE_UNGUARDED_PATTERN : thm =
  |- !(<<) p s pat e t y.
         admissible (<<) p s pat /\
         admissible (<<) p s e /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x) s t /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x) s y
         ==> admissible (<<) p s
             (\f x.
                  _UNGUARDED_PATTERN (GEQ (pat f x) (e f x))
                  (GEQ (t f x) (y f x)))
val ADMISSIBLE_GUARDED_PATTERN : thm =
  |- !(<<) p s pat q e t y.
         admissible (<<) p s pat /\
         admissible (<<) p s e /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x /\ q f x) s t /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x) s q /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x /\ q f x) s y
         ==> admissible (<<) p s
             (\f x.
                  _GUARDED_PATTERN (GEQ (pat f x) (e f x)) (q f x)
                  (GEQ (t f x) (y f x)))
val ADMISSIBLE_NSUM : thm =
  |- !(<<) p s h a b.
         admissible (<<) (\f (k,x). a x <= k /\ k <= b x /\ p f x)
         (\(k,x). s x)
         (\f (k,x). h f x k)
         ==> admissible (<<) p s (\f x. nsum (a x..b x) (h f x))
val ADMISSIBLE_SUM : thm =
  |- !(<<) p s h a b.
         admissible (<<) (\f (k,x). a x <= k /\ k <= b x /\ p f x)
         (\(k,x). s x)
         (\f (k,x). h f x k)
         ==> admissible (<<) p s (\f x. sum (a x..b x) (h f x))
val ADMISSIBLE_MAP : thm =
  |- !(<<) p s h l.
         admissible (<<) p s l /\
         admissible (<<) (\f (y,x). p f x /\ MEM y (l f x)) (\(y,x). s x)
         (\f (y,x). h f x y)
         ==> admissible (<<) p s (\f x. MAP (h f x) (l f x))
val ADMISSIBLE_MATCH_SEQPATTERN : thm =
  |- !(<<) p s c1 c2 e.
         admissible (<<) p s (\f x. ?y. c1 f x (e f x) y) /\
         admissible (<<) (\f x. p f x /\ (?y. c1 f x (e f x) y)) s
         (\f x. _MATCH (e f x) (c1 f x)) /\
         admissible (<<) (\f x. p f x /\ ~(?y. c1 f x (e f x) y)) s
         (\f x. _MATCH (e f x) (c2 f x))
         ==> admissible (<<) p s
             (\f x. _MATCH (e f x) (_SEQPATTERN (c1 f x) (c2 f x)))
val ADMISSIBLE_IMP_SUPERADMISSIBLE : thm =
  |- !(<<) p s t. admissible (<<) p s t ==> superadmissible (<<) p s t
val SUPERADMISSIBLE_CONST : thm = |- !p s c. superadmissible (<<) p s (\f. c)
val SUPERADMISSIBLE_TAIL : thm =
  |- !(<<) p s t.
         admissible (<<) p s t /\
         (!f a. p f a ==> (!y. y << t f a ==> y << s a))
         ==> superadmissible (<<) p s (\f x. f (t f x))
val SUPERADMISSIBLE_COND : thm =
  |- !(<<) p P s h k.
         admissible (<<) p s P /\
         superadmissible (<<) (\f x. p f x /\ P f x) s h /\
         superadmissible (<<) (\f x. p f x /\ ~P f x) s k
         ==> superadmissible (<<) p s (\f x. if P f x then h f x else k f x)
val SUPERADMISSIBLE_MATCH_SEQPATTERN : thm =
  |- !(<<) p s c1 c2 e.
         admissible (<<) p s (\f x. ?y. c1 f x (e f x) y) /\
         superadmissible (<<) (\f x. p f x /\ (?y. c1 f x (e f x) y)) s
         (\f x. _MATCH (e f x) (c1 f x)) /\
         superadmissible (<<) (\f x. p f x /\ ~(?y. c1 f x (e f x) y)) s
         (\f x. _MATCH (e f x) (c2 f x))
         ==> superadmissible (<<) p s
             (\f x. _MATCH (e f x) (_SEQPATTERN (c1 f x) (c2 f x)))
val SUPERADMISSIBLE_MATCH_UNGUARDED_PATTERN : thm =
  |- !(<<) p s e pat arg.
         (!f a t u.
              p f a /\ pat t = e a /\ pat u = e a ==> arg a t = arg a u) /\
         (!f a t. p f a /\ pat t = e a ==> (!y. y << arg a t ==> y << s a))
         ==> superadmissible (<<) p s
             (\f x. match e x with pat t -> f (arg x t))
val SUPERADMISSIBLE_MATCH_GUARDED_PATTERN : thm =
  |- !(<<) p s e pat q arg.
         (!f a t u.
              p f a /\ pat t = e a /\ q a t /\ pat u = e a /\ q a u
              ==> arg a t = arg a u) /\
         (!f a t.
              p f a /\ q a t /\ pat t = e a
              ==> (!y. y << arg a t ==> y << s a))
         ==> superadmissible (<<) p s
             (\f x. match e x with pat t when q x t -> f (arg x t))
val WF_REC_TAIL_GENERAL' : thm =
  |- !P G H H'.
         WF (<<) /\
         (!f g x.
              (!z. z << x ==> f z = g z)
              ==> (P f x <=> P g x) /\ G f x = G g x /\ H' f x = H' g x) /\
         (!f x y. P f x /\ y << G f x ==> y << x) /\
         (!f x. H f x = (if P f x then f (G f x) else H' f x))
         ==> (?f. !x. f x = H f x)
val WF_REC_CASES : thm =
  |- !(<<) clauses.
         WF (<<) /\
         ALL
         (\(s,t). ?P G H.
                      (!f a y. P f a /\ y << G f a ==> y << s a) /\
                      (!f g a.
                           (!z. z << s a ==> f z = g z)
                           ==> (P f a <=> P g a) /\
                               G f a = G g a /\
                               H f a = H g a) /\
                      (!f a. t f a = (if P f a then f (G f a) else H f a)))
         clauses
         ==> (?f. !x. f x = CASEWISE clauses f x)
val WF_REC_CASES' : thm =
  |- !(<<) clauses.
         WF (<<) /\ ALL (\(s,t). tailadmissible (<<) (\f a. T) s t) clauses
         ==> (?f. !x. f x = CASEWISE clauses f x)
val RECURSION_CASEWISE : thm =
  |- !clauses. (?(<<). WF (<<) /\
                       ALL (\(s,t). tailadmissible (<<) (\f a. T) s t)
                       clauses) /\
               (!s t s' t' f x y.
                    MEM (s,t) clauses /\ MEM (s',t') clauses
                    ==> s x = s' y
                    ==> t f x = t' f y)
               ==> (?f. ALL (\(s,t). !x. f (s x) = t f x) clauses)
val RECURSION_CASEWISE_PAIRWISE : thm =
  |- !clauses. (?(<<). WF (<<) /\
                       ALL (\(s,t). tailadmissible (<<) (\f a. T) s t)
                       clauses) /\
               ALL (\(s,t). !f x y. s x = s y ==> t f x = t f y) clauses /\
               PAIRWISE
               (\(s,t) (s',t'). !f x y. s x = s' y ==> t f x = t' f y)
               clauses
               ==> (?f. ALL (\(s,t). !x. f (s x) = t f x) clauses)
val SUPERADMISSIBLE_T : thm =
  |- superadmissible (<<) (\f x. T) s t <=> tailadmissible (<<) (\f x. T) s t
val RECURSION_SUPERADMISSIBLE : thm =
  |- !clauses. (?(<<). WF (<<) /\
                       ALL (\(s,t). superadmissible (<<) (\f a. T) s t)
                       clauses) /\
               ALL (\(s,t). !f x y. s x = s y ==> t f x = t f y) clauses /\
               PAIRWISE
               (\(s,t) (s',t'). !f x y. s x = s' y ==> t f x = t' f y)
               clauses
               ==> (?f. ALL (\(s,t). !x. f (s x) = t f x) clauses)
val REFL : term -> thm = <fun>
val BETA : term -> thm = <fun>
val ASSUME : term -> thm = <fun>
val new_axiom : term -> thm = <fun>
val new_basic_definition : term -> thm = <fun>
val BETA_CONV : term -> thm = <fun>
val NO_CONV : conv = <fun>
val ALL_CONV : conv = <fun>
val SYM_CONV : term -> thm = <fun>
val BETAS_CONV : conv = <fun>
val new_definition : term -> thm = <fun>
val ITAUT : term -> thm = <fun>
val derive_nonschematic_inductive_relations : term -> thm = <fun>
val prove_inductive_relations_exist : term -> thm = <fun>
val ETA_CONV : term -> thm = <fun>
val SELECT_CONV : term -> thm = <fun>
val TAUT : term -> thm = <fun>
val CONTRAPOS_CONV : term -> thm = <fun>
val TAUT : term -> thm = <fun>
val COND_ELIM_CONV : term -> thm = <fun>
val PRESIMP_CONV : conv = <fun>
val CONJ_ACI_RULE : term -> thm = <fun>
val DISJ_ACI_RULE : term -> thm = <fun>
val CONJ_CANON_CONV : term -> thm = <fun>
val DISJ_CANON_CONV : term -> thm = <fun>
val NNF_CONV : conv = <fun>
val NNFC_CONV : conv = <fun>
val SKOLEM_CONV : conv = <fun>
val PRENEX_CONV : conv = <fun>
val WEAK_DNF_CONV : conv = <fun>
val DNF_CONV : conv = <fun>
val WEAK_CNF_CONV : conv = <fun>
val CNF_CONV : conv = <fun>
val LAMBDA_ELIM_CONV : conv = <fun>
val CONDS_ELIM_CONV : conv = <fun>
val CONDS_CELIM_CONV : conv = <fun>
val new_definition : term -> thm = <fun>
val GEN_BETA_CONV : term -> thm = <fun>
val let_CONV : term -> thm = <fun>
val NUM_CANCEL_CONV : term -> thm = <fun>
val NUM_EVEN_CONV : conv = <fun>
val NUM_ODD_CONV : conv = <fun>
val NUM_SUC_CONV : term -> thm = <fun>
val NUM_ADD_CONV : term -> thm = <fun>
val NUM_MULT_CONV : term -> thm = <fun>
val NUM_EXP_CONV : term -> thm = <fun>
val NUM_LT_CONV : term -> thm = <fun>
val NUM_LE_CONV : term -> thm = <fun>
val NUM_EQ_CONV : term -> thm = <fun>
val NUM_GT_CONV : conv = <fun>
val NUM_GE_CONV : conv = <fun>
val NUM_PRE_CONV : term -> thm = <fun>
val NUM_SUB_CONV : term -> thm = <fun>
val NUM_DIV_CONV : term -> thm = <fun>
val NUM_MOD_CONV : term -> thm = <fun>
val NUM_FACT_CONV : term -> thm = <fun>
val NUM_MAX_CONV : conv = <fun>
val NUM_MIN_CONV : conv = <fun>
val NUM_REL_CONV : term -> thm = <fun>
val NUM_RED_CONV : term -> thm = <fun>
val NUM_REDUCE_CONV : conv = <fun>
val num_CONV : term -> thm = <fun>
val EXPAND_CASES_CONV : conv = <fun>
val NUM_NORMALIZE_CONV : term -> thm = <fun>
val NUM_SIMPLIFY_CONV : conv = <fun>
val NUM_RING : term -> thm = <fun>
val UNWIND_CONV : conv = <fun>
val MATCH_CONV : conv = <fun>
val FORALL_UNWIND_CONV : conv = <fun>
val REAL_INT_LE_CONV : conv = <fun>
val REAL_INT_LT_CONV : conv = <fun>
val REAL_INT_GE_CONV : conv = <fun>
val REAL_INT_GT_CONV : conv = <fun>
val REAL_INT_EQ_CONV : conv = <fun>
val REAL_INT_NEG_CONV : conv = <fun>
val REAL_INT_MUL_CONV : conv = <fun>
val REAL_INT_ADD_CONV : conv = <fun>
val REAL_INT_SUB_CONV : conv = <fun>
val REAL_INT_POW_CONV : conv = <fun>
val REAL_INT_ABS_CONV : conv = <fun>
val REAL_INT_RED_CONV : term -> thm = <fun>
val REAL_INT_REDUCE_CONV : conv = <fun>
val REAL_ARITH : term -> thm = <fun>
val REAL_ARITH : term -> thm = <fun>
val REAL_INT_RAT_CONV : conv = <fun>
val REAL_RAT_LE_CONV : conv = <fun>
val REAL_RAT_LT_CONV : conv = <fun>
val REAL_RAT_GE_CONV : conv = <fun>
val REAL_RAT_GT_CONV : conv = <fun>
val REAL_RAT_EQ_CONV : conv = <fun>
val REAL_RAT_NEG_CONV : term -> thm = <fun>
val REAL_RAT_ABS_CONV : conv = <fun>
val REAL_RAT_INV_CONV : conv = <fun>
val REAL_RAT_ADD_CONV : conv = <fun>
val REAL_RAT_SUB_CONV : conv = <fun>
val REAL_RAT_MUL_CONV : conv = <fun>
val REAL_RAT_DIV_CONV : conv = <fun>
val REAL_RAT_POW_CONV : conv = <fun>
val REAL_RAT_MAX_CONV : conv = <fun>
val REAL_RAT_MIN_CONV : conv = <fun>
val REAL_RAT_RED_CONV : term -> thm = <fun>
val REAL_RAT_REDUCE_CONV : conv = <fun>
val REAL_POLY_NEG_CONV : term -> thm = <fun>
val REAL_POLY_ADD_CONV : term -> thm = <fun>
val REAL_POLY_SUB_CONV : term -> thm = <fun>
val REAL_POLY_MUL_CONV : term -> thm = <fun>
val REAL_POLY_POW_CONV : term -> thm = <fun>
val REAL_POLY_CONV : term -> thm = <fun>
val REAL_POLY_CONV : term -> thm = <fun>
val REAL_RING : term -> thm = <fun>
val REAL_ARITH : term -> thm = <fun>
val REAL_FIELD : term -> thm = <fun>
val INT_ARITH : term -> thm = <fun>
val INT_LE_CONV : conv = <fun>
val INT_LT_CONV : conv = <fun>
val INT_GE_CONV : conv = <fun>
val INT_GT_CONV : conv = <fun>
val INT_EQ_CONV : conv = <fun>
val INT_NEG_CONV : conv = <fun>
val INT_MUL_CONV : conv = <fun>
val INT_ADD_CONV : conv = <fun>
val INT_SUB_CONV : conv = <fun>
val INT_POW_CONV : conv = <fun>
val INT_ABS_CONV : conv = <fun>
val INT_MAX_CONV : conv = <fun>
val INT_MIN_CONV : conv = <fun>
val INT_POLY_CONV : term -> thm = <fun>
val INT_RING : term -> thm = <fun>
val INT_DIV_CONV : term -> thm = <fun>
val INT_REM_CONV : term -> thm = <fun>
val INT_RED_CONV : term -> thm = <fun>
val INT_REDUCE_CONV : conv = <fun>
val INTEGER_RULE : term -> thm = <fun>
val INTEGER_RULE : term -> thm = <fun>
val NUM_TO_INT_CONV : conv = <fun>
val ARITH_RULE : term -> thm = <fun>
val NUMBER_RULE : term -> thm = <fun>
val SET_RULE : term -> thm = <fun>
val HAS_SIZE_CONV : term -> thm = <fun>
val NUMSEG_CONV : conv = <fun>
val EXPAND_SUM_CONV : conv = <fun>
val instantiate_casewise_recursion : term -> thm = <fun>
val pure_prove_recursive_function_exists : term -> thm = <fun>
val prove_general_recursive_function_exists : term -> thm = <fun>
val define : term -> thm = <fun>
val AP_THM : thm -> term -> thm = <fun>
val ALPHA : term -> term -> thm = <fun>
val ALPHA_CONV : term -> term -> thm = <fun>
val GEN_ALPHA_CONV : term -> term -> thm = <fun>
val thenc_ : conv -> conv -> conv = <fun>
val orelsec_ : conv -> conv -> conv = <fun>
val FIRST_CONV : conv list -> conv = <fun>
val EVERY_CONV : conv list -> conv = <fun>
val REPEATC : conv -> conv = <fun>
val CHANGED_CONV : conv -> conv = <fun>
val TRY_CONV : conv -> conv = <fun>
val RATOR_CONV : conv -> conv = <fun>
val RAND_CONV : conv -> conv = <fun>
val LAND_CONV : conv -> conv = <fun>
val COMB2_CONV : conv -> conv -> conv = <fun>
val COMB_CONV : conv -> conv = <fun>
val ABS_CONV : conv -> conv = <fun>
val BINDER_CONV : conv -> term -> thm = <fun>
val SUB_CONV : conv -> term -> thm = <fun>
val BINOP_CONV : (term -> thm) -> term -> thm = <fun>
val ONCE_DEPTH_CONV : conv -> conv = <fun>
val DEPTH_CONV : conv -> conv = <fun>
val REDEPTH_CONV : conv -> conv = <fun>
val TOP_DEPTH_CONV : conv -> conv = <fun>
val TOP_SWEEP_CONV : conv -> conv = <fun>
val DEPTH_BINOP_CONV : term -> (term -> thm) -> term -> thm = <fun>
val PATH_CONV : string -> conv -> conv = <fun>
val PAT_CONV : term -> conv -> conv = <fun>
val SUBS_CONV : thm list -> term -> thm = <fun>
val CACHE_CONV : (term -> thm) -> term -> thm = <fun>
val DISJ1 : thm -> term -> thm = <fun>
val PART_MATCH : (term -> term) -> thm -> term -> thm = <fun>
val GEN_PART_MATCH : (term -> term) -> thm -> term -> thm = <fun>
val HIGHER_REWRITE_CONV : thm list -> bool -> term -> thm = <fun>
val REWR_CONV : thm -> term -> thm = <fun>
val IMP_REWR_CONV : thm -> term -> thm = <fun>
val ORDERED_REWR_CONV : (term -> term -> bool) -> thm -> term -> thm = <fun>
val apply_prover : prover -> term -> thm = <fun>
val GEN_REWRITE_CONV : (conv -> conv) -> thm list -> conv = <fun>
val PURE_REWRITE_CONV : thm list -> conv = <fun>
val REWRITE_CONV : thm list -> conv = <fun>
val PURE_ONCE_REWRITE_CONV : thm list -> conv = <fun>
val ONCE_REWRITE_CONV : thm list -> conv = <fun>
val ONCE_SIMPLIFY_CONV : simpset -> thm list -> conv = <fun>
val SIMPLIFY_CONV : simpset -> thm list -> conv = <fun>
val SIMP_CONV : thm list -> conv = <fun>
val PURE_SIMP_CONV : thm list -> conv = <fun>
val ONCE_SIMP_CONV : thm list -> conv = <fun>
val AC : thm -> term -> thm = <fun>
val GEN_NNF_CONV : bool -> conv * (term -> thm * thm) -> conv = <fun>
val ASSOC_CONV : thm -> term -> thm = <fun>
val PROP_ATOM_CONV : conv -> conv = <fun>
val MESON : thm list -> term -> thm = <fun>
val GABS_CONV : conv -> term -> thm = <fun>
val prove_recursive_functions_exist : thm -> term -> thm = <fun>
val new_recursive_definition : thm -> term -> thm = <fun>
val LIST_CONV : conv -> conv = <fun>
val REAL_IDEAL_CONV : term list -> term -> thm = <fun>
val VALID : tactic -> tactic = <fun>
val then_ : tactic -> tactic -> tactic = <fun>
val thenl_ : tactic -> tactic list -> tactic = <fun>
val orelse_ : tactic -> tactic -> tactic = <fun>
val FAIL_TAC : string -> tactic = <fun>
val NO_TAC : tactic = <fun>
val ALL_TAC : tactic = <fun>
val TRY : tactic -> tactic = <fun>
val REPEAT : tactic -> tactic = <fun>
val EVERY : tactic list -> tactic = <fun>
val FIRST : tactic list -> tactic = <fun>
val MAP_EVERY : ('a -> tactic) -> 'a list -> tactic = <fun>
val MAP_FIRST : ('a -> tactic) -> 'a list -> tactic = <fun>
val CHANGED_TAC : tactic -> tactic = <fun>
val REPLICATE_TAC : int -> tactic -> tactic = <fun>
val FIND_ASSUM : thm_tactic -> term -> tactic = <fun>
val POP_ASSUM : thm_tactic -> tactic = <fun>
val ASSUM_LIST : (thm list -> tactic) -> tactic = <fun>
val POP_ASSUM_LIST : (thm list -> tactic) -> tactic = <fun>
val EVERY_ASSUM : thm_tactic -> tactic = <fun>
val FIRST_ASSUM : thm_tactic -> tactic = <fun>
val RULE_ASSUM_TAC : (thm -> thm) -> tactic = <fun>
val USE_THEN : string -> thm_tactic -> tactic = <fun>
val REMOVE_THEN : string -> thm_tactic -> tactic = <fun>
val ASM : (thm list -> tactic) -> thm list -> tactic = <fun>
val HYP : (thm list -> tactic) -> string -> thm list -> tactic = <fun>
val CONV_TAC : conv -> tactic = <fun>
val REFL_TAC : tactic = <fun>
val ABS_TAC : tactic = <fun>
val MK_COMB_TAC : tactic = <fun>
val AP_TERM_TAC : tactic = <fun>
val AP_THM_TAC : tactic = <fun>
val BINOP_TAC : tactic = <fun>
val SUBST_ALL_TAC : thm -> tactic = <fun>
val BETA_TAC : tactic = <fun>
val SUBST_VAR_TAC : thm -> tactic = <fun>
val DISCH_TAC : tactic = <fun>
val EQ_TAC : tactic = <fun>
val UNDISCH_TAC : term -> tactic = <fun>
val SPEC_TAC : term * term -> tactic = <fun>
val X_GEN_TAC : term -> tactic = <fun>
val EXISTS_TAC : term -> tactic = <fun>
val GEN_TAC : tactic = <fun>
val CONJ_TAC : tactic = <fun>
val DISJ1_TAC : tactic = <fun>
val DISJ2_TAC : tactic = <fun>
val TRANS_TAC : thm -> term -> tactic = <fun>
val DISCH_THEN : thm_tactic -> tactic = <fun>
val STRIP_GOAL_THEN : thm_tactic -> tactic = <fun>
val STRIP_TAC : tactic = <fun>
val UNDISCH_THEN : term -> thm_tactic -> tactic = <fun>
val FIRST_X_ASSUM : thm_tactic -> tactic = <fun>
val SUBGOAL_THEN : term -> thm_tactic -> tactic = <fun>
val SUBGOAL_TAC : string -> term -> tactic list -> tactic = <fun>
val X_META_EXISTS_TAC : term -> tactic = <fun>
val META_SPEC_TAC : term -> thm -> tactic = <fun>
val CHEAT_TAC : tactic = <fun>
val RECALL_ACCEPT_TAC : ('a -> thm) -> 'a -> goal -> goalstate = <fun>
val ANTS_TAC : tactic = <fun>
val mk_goalstate : goal -> goalstate = <fun>
val ITAUT_TAC : tactic = <fun>
val GEN_REWRITE_TAC : (conv -> conv) -> thm list -> tactic = <fun>
val PURE_REWRITE_TAC : thm list -> tactic = <fun>
val REWRITE_TAC : thm list -> tactic = <fun>
val PURE_ONCE_REWRITE_TAC : thm list -> tactic = <fun>
val ONCE_REWRITE_TAC : thm list -> tactic = <fun>
val PURE_ASM_REWRITE_TAC : thm list -> tactic = <fun>
val ASM_REWRITE_TAC : thm list -> tactic = <fun>
val PURE_ONCE_ASM_REWRITE_TAC : thm list -> tactic = <fun>
val ONCE_ASM_REWRITE_TAC : thm list -> tactic = <fun>
val SIMP_TAC : thm list -> tactic = <fun>
val PURE_SIMP_TAC : thm list -> tactic = <fun>
val ONCE_SIMP_TAC : thm list -> tactic = <fun>
val ASM_SIMP_TAC : thm list -> tactic = <fun>
val PURE_ASM_SIMP_TAC : thm list -> tactic = <fun>
val ONCE_ASM_SIMP_TAC : thm list -> tactic = <fun>
val EXPAND_TAC : string -> tactic = <fun>
val FIX_TAC : string -> tactic = <fun>
val INTRO_TAC : string -> tactic = <fun>
val MONO_TAC : goal -> goalstate = <fun>
val BOOL_CASES_TAC : term -> tactic = <fun>
val ASM_CASES_TAC : term -> tactic = <fun>
val COND_CASES_TAC : tactic = <fun>
val SELECT_ELIM_TAC : tactic = <fun>
val GEN_MESON_TAC : int -> int -> int -> thm list -> tactic = <fun>
val ASM_MESON_TAC : thm list -> tactic = <fun>
val MESON_TAC : thm list -> tactic = <fun>
val IMP_REWRITE_TAC : thm list -> tactic = <fun>
val TARGET_REWRITE_TAC : thm list -> thm -> tactic = <fun>
val HINT_EXISTS_TAC : tactic = <fun>
val SEQ_IMP_REWRITE_TAC : thm list -> tactic = <fun>
val CASE_REWRITE_TAC : thm -> tactic = <fun>
val LET_TAC : tactic = <fun>
val INDUCT_TAC : tactic = <fun>
val NUM_REDUCE_TAC : tactic = <fun>
val LIST_INDUCT_TAC : tactic = <fun>
val REAL_ARITH_TAC : tactic = <fun>
val REAL_ARITH_TAC : tactic = <fun>
val ASM_REAL_ARITH_TAC : tactic = <fun>
val INT_ARITH_TAC : tactic = <fun>
val ASM_INT_ARITH_TAC : tactic = <fun>
val INTEGER_TAC : tactic = <fun>
val INTEGER_TAC : tactic = <fun>
val ARITH_TAC : tactic = <fun>
val ASM_ARITH_TAC : tactic = <fun>
val NUMBER_TAC : tactic = <fun>
val SET_TAC : thm list -> tactic = <fun>
val LABEL_TAC : string -> thm_tactic = <fun>
val ASSUME_TAC : thm_tactic = <fun>
val ACCEPT_TAC : thm_tactic = <fun>
val SUBST1_TAC : thm_tactic = <fun>
val SUBST_ALL_TAC : thm -> tactic = <fun>
val SUBST_VAR_TAC : thm -> tactic = <fun>
val MP_TAC : thm_tactic = <fun>
val X_CHOOSE_TAC : term -> thm_tactic = <fun>
val CHOOSE_TAC : thm_tactic = <fun>
val DISJ_CASES_TAC : thm_tactic = <fun>
val CONTR_TAC : thm_tactic = <fun>
val MATCH_ACCEPT_TAC : thm_tactic = <fun>
val MATCH_MP_TAC : thm_tactic = <fun>
val CONJUNCTS_THEN2 : thm_tactic -> thm_tactic -> thm_tactic = <fun>
val DISJ_CASES_THEN2 : thm_tactic -> thm_tactic -> thm_tactic = <fun>
val STRIP_ASSUME_TAC : thm_tactic = <fun>
val STRUCT_CASES_THEN : thm_tactic -> thm_tactic = <fun>
val STRUCT_CASES_TAC : thm_tactic = <fun>
val META_SPEC_TAC : term -> thm -> tactic = <fun>
val DESTRUCT_TAC : string -> thm_tactic = <fun>
val TARGET_REWRITE_TAC : thm list -> thm -> tactic = <fun>
val CASE_REWRITE_TAC : thm -> tactic = <fun>
